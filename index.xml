<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>EiEddie&#39;s Mind</title>
    <link>https://example.org/</link>
    <description>Recent content on EiEddie&#39;s Mind</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 07 Jan 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>文章处理管线</title>
      <link>https://example.org/docs/article-processing-pipeline/</link>
      <pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/article-processing-pipeline/</guid>
      <description>&lt;h1 id=&#34;文章处理管线&#34;&gt;文章处理管线&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e7%ab%a0%e5%a4%84%e7%90%86%e7%ae%a1%e7%ba%bf&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;这篇文章将介绍结合本地 Obsidian 知识库与远程站点的文章处理体系, 聚焦于在本地与 hugo 搭建的静态网站中都实现良好的显示效果, 并构建一套相对自动化的文章发布管线.&lt;/p&gt;&#xA;&lt;p&gt;我们构建的文章处理流程如下所示:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;本地使用 Obsidian 编写与管理.&lt;/li&gt;&#xA;&lt;li&gt;使用 pandoc 处理文档, 使其符合 hugo 的文档规范.&lt;/li&gt;&#xA;&lt;li&gt;使用 hugo 打包为静态站点.&lt;/li&gt;&#xA;&lt;li&gt;发布到托管服务.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;因为 Windows 系统对于文件名过于苛刻的限制, 并且我们需要使用命令行工具进行自动化, 将在 Linux 环境下进行处理.&#xA;为了照顾本地知识库, 它明显在 Windows 下更方便, 可以将处理管线布置在 WSL 中, 它与 Windows 配合得非常好.&#xA;关于 hugo 搭建站点的内容可以查看 &lt;a href=&#34;https://example.org/docs/static-site-with-hugo/&#34;&gt;这篇文章&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;格式化文档&#34;&gt;格式化文档&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%bc%e5%bc%8f%e5%8c%96%e6%96%87%e6%a1%a3&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;首先要做的就是保证文章格式能够被 pandoc 正确处理, 且被 hugo 正确识别, 因此一方面要保证元数据的正确, 另一方面要确保正文中没有不被 Obsidian, pandoc 和 hugo 支持的 Markdown 语法.&lt;/p&gt;&#xA;&lt;p&gt;hugo 依赖于 &lt;code&gt;title&lt;/code&gt; 而非文件名显示文章标题, 使用 &lt;code&gt;date&lt;/code&gt; 标记文章修改时间, 并且会读取 &lt;code&gt;tags&lt;/code&gt; 来分类文章.&#xA;为了避免流程出错, 与减轻心智负担, 可以在 Obsidian 中安装 &lt;a href=&#34;https://github.com/platers/obsidian-linter&#34;&gt;Linter&lt;/a&gt; 插件, 它可以自动格式化文档, 并重排与补全元数据.&#xA;将 Linter 的 &lt;a href=&#34;https://platers.github.io/obsidian-linter/settings/yaml-rules/#yaml-title-alias&#34;&gt;标题别名&lt;/a&gt; 部分设置打开, 便可以自动从第一个 &lt;code&gt;#&lt;/code&gt; 标签处获取文章标题, 并填写到元数据区, 另外还会将标题名作为别名写入.&#xA;如果以前在使用 &lt;code&gt;datetime&lt;/code&gt; 字段储存文档修改或编写日期, &lt;strong&gt;强烈建议改为 &lt;code&gt;date&lt;/code&gt; 字段&lt;/strong&gt;, 因为这一键名在 Obsidian 与 hugo 两端都受到良好的支持.&lt;/p&gt;</description>
    </item>
    <item>
      <title>为 Hugo 添加数学支持</title>
      <link>https://example.org/docs/hugo-with-math/</link>
      <pubDate>Sun, 04 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/hugo-with-math/</guid>
      <description>&lt;h1 id=&#34;为-hugo-添加数学支持&#34;&gt;为 Hugo 添加数学支持&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba-hugo-%e6%b7%bb%e5%8a%a0%e6%95%b0%e5%ad%a6%e6%94%af%e6%8c%81&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文将聚焦于为 hugo 生成的静态站点添加数学公式渲染支持, 我们将使用 MathJax, 因为相比 KaTeX, 它支持更多 \(\LaTeX\) 语法, 例如 &lt;code&gt;align&lt;/code&gt; 对齐环境等.&lt;/p&gt;&#xA;&lt;p&gt;关于 hugo 的 &lt;em&gt;联合文件系统&lt;/em&gt; 与 &lt;em&gt;注入点&lt;/em&gt; 相关内容, 请看 &lt;a href=&#34;https://example.org/docs/static-site-with-hugo/&#34;&gt;这篇文章&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;首先在 &lt;code&gt;layouts/partials&lt;/code&gt; 中新建 &lt;code&gt;mathjax.html&lt;/code&gt;, 用于作为组件被调用.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!-- layouts/partials/mathjax.html --&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{{ if or .Params.math .Site.Params.math }}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  window.&lt;span style=&#34;color:#a6e22e&#34;&gt;MathJax&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;tex&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;inlineMath&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\\(&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\\)&amp;#39;&lt;/span&gt;]],&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;displayMath&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$$&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$$&amp;#39;&lt;/span&gt;]]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;options&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;skipHtmlTags&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;script&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;noscript&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;style&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;textarea&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pre&amp;#39;&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{{ end }}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码引入了 MathJax, 并配置渲染块标识符, 内联公式为 &lt;code&gt;\\(...\\)&lt;/code&gt;, 行间公式为 &lt;code&gt;\$\$...\$\$&lt;/code&gt;.&#xA;不使用 &lt;code&gt;$...$&lt;/code&gt; 与 &lt;code&gt;\\[...\\]&lt;/code&gt; 的理由将在后文叙述.&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 Hugo 搭建静态站点</title>
      <link>https://example.org/docs/static-site-with-hugo/</link>
      <pubDate>Sun, 04 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/static-site-with-hugo/</guid>
      <description>&lt;h1 id=&#34;使用-hugo-搭建静态站点&#34;&gt;使用 Hugo 搭建静态站点&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8-hugo-%e6%90%ad%e5%bb%ba%e9%9d%99%e6%80%81%e7%ab%99%e7%82%b9&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在本地知识库软件编写文章在很多时候已经足够满足我参考的需要, 但若遇上呈给别人台鉴的情况, 终归不够方便.&#xA;另外文章虽在 GitHub 保存, 但其缺失对元数据的整理功能, 对于必要的 Markdown 拓展语法支持也不佳, 更关键的是, 其使用的 KaTeX 数学引擎较为简陋, 难以招架文章中出现的连篇累牍的公式.&#xA;无奈之下, 恐怕建立一个阅览站点成了唯一可行的选择.&lt;/p&gt;&#xA;&lt;p&gt;本篇文章着重介绍站点本身的配置与搭建, 关于内容的编写与发布请看 &lt;a href=&#34;https://example.org/docs/article-processing-pipeline/&#34;&gt;这篇文章&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;主题选择&#34;&gt;主题选择&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e9%a2%98%e9%80%89%e6%8b%a9&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我希望站点整体上是静态的, 没有过分到眼花缭乱的小动画与动态效果, 主题风格简洁严肃, 就像一本书或一页纸一样, 仅用来供人阅览而不喧宾夺主.&#xA;最后我选择的主题是 &lt;a href=&#34;https://github.com/alex-shpak/hugo-book&#34;&gt;book&lt;/a&gt;, 效果和它的名字一样沉静.&#xA;然而不得不说的是, 或许我下面的要求过分了点, 没有让我完全满意的主题, book 也不例外.&#xA;于是只好对它进行一番改造了.&lt;/p&gt;&#xA;&lt;h2 id=&#34;特殊语法支持&#34;&gt;特殊语法支持&lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%b9%e6%ae%8a%e8%af%ad%e6%b3%95%e6%94%af%e6%8c%81&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;一些 Markdown 方言提供了特别有益的拓展语法, 例如 &lt;code&gt;admonitions&lt;/code&gt;, 我们希望尽可能地使其可用.&#xA;幸运地是 book 主题本身就支持这一语法, 因此我们并不需要大费周章配置.&#xA;但如果是不支持此语法的主题, 可以额外安装一个 &lt;a href=&#34;https://github.com/KKKZOZ/hugo-admonitions&#34;&gt;hugo-admonitions&lt;/a&gt; 主题, 并将其置于主要主题之前, 这样便可覆盖原主题来提供 admonitions 支持, 如下&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;theme = [&amp;quot;hugo-admonitions&amp;quot;, &amp;quot;book&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;blockquote class=&#39;book-hint note&#39;&gt;&#xA;&lt;p&gt;一定注意 hugo-admonitions 应该放置于主要主题 &amp;ndash; 这里是 book&amp;ndash; 前面, 因为主题的使用是从前到后的.&lt;/p&gt;&#xA;&lt;p&gt;另外, 这就是一个 admonition.&lt;/p&gt;</description>
    </item>
    <item>
      <title>带有单位的物理计算</title>
      <link>https://example.org/docs/calc-with-unit/</link>
      <pubDate>Sat, 03 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/calc-with-unit/</guid>
      <description>&lt;h1 id=&#34;带有单位的物理计算&#34;&gt;带有单位的物理计算&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%a6%e6%9c%89%e5%8d%95%e4%bd%8d%e7%9a%84%e7%89%a9%e7%90%86%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;mathematica&#34;&gt;Mathematica&lt;a class=&#34;anchor&#34; href=&#34;#mathematica&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Mathematica&lt;/strong&gt; 中可以带单位计算; 同样, 可以获取任意物理常数, 并以任意精度进行计算.&lt;/p&gt;&#xA;&lt;p&gt;要使用物理常数, 首先使用 &lt;code&gt;Quantity&lt;/code&gt; 函数获取它并保存在变量里, 接着就可以在运算中使用这一常数的带有单位的精确值. 例如&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;h = Quantity[&amp;quot;PlanckConstant&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;获取了&lt;em&gt;普朗克常量&lt;/em&gt;的值并保存在变量 &lt;code&gt;h&lt;/code&gt; 中.&lt;/p&gt;&#xA;&lt;p&gt;如果想要知道该常数在国际单位制下的准确值, 可以使用函数 &lt;code&gt;UnitConvert&lt;/code&gt;. 例如&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;UnitConvert@Quantity[&amp;quot;PlanckConstant&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;将给出结果&#xA;&lt;/p&gt;&#xA;$$\frac{132521403}{200000000000000000000000000000000000000000} \mathrm{kg ~ m^2 / s}$$&lt;p&gt;要定义带有单位的变量, 依旧使用 &lt;code&gt;Quantity&lt;/code&gt;, 只需如下所示&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Quantity[600*^6, &amp;quot;Hz&amp;quot;] (* 给出 600000000 Hz *)&#xA;&#xA;Quantity[1, &amp;quot;kg m/s^2&amp;quot;] (* 给出 1 kg m/s^2 *)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;软件在解析单位时较慢, 但识别较为精确.&lt;/p&gt;&#xA;&lt;p&gt;还可以使用语法 &lt;code&gt;Ctrl+=&lt;/code&gt; 输入, 这其实是&lt;em&gt;自然语言输入&lt;/em&gt;, 可以替换函数 &lt;code&gt;Quantity&lt;/code&gt;, 只需按下 &lt;code&gt;Ctrl+=&lt;/code&gt; 后输入想要的常数或带单位量即可. 例如 &lt;code&gt;600*^6Hz&lt;/code&gt;, &lt;code&gt;1 kg m/s^2&lt;/code&gt;, &lt;code&gt;Planck Constant&lt;/code&gt; 等等, 都可被正常识别.&lt;/p&gt;</description>
    </item>
    <item>
      <title>量子力学中的角动量</title>
      <link>https://example.org/docs/qm-angular-momentum/</link>
      <pubDate>Mon, 15 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/qm-angular-momentum/</guid>
      <description>&lt;h1 id=&#34;量子力学中的角动量&#34;&gt;量子力学中的角动量&lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8f%e5%ad%90%e5%8a%9b%e5%ad%a6%e4%b8%ad%e7%9a%84%e8%a7%92%e5%8a%a8%e9%87%8f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在量子力学中, 除了我们能够想象的沿轨道运动和绕自转轴转动的公转角动量与自转角动量, 这两者分别称为轨道角动量与自旋角动量, 对于任意 \(\mathbf{J}\), 只要其分量 \(J_\alpha\) 满足&#xA;&lt;/p&gt;&#xA;$$ [J_\alpha, J_\beta] = \mathrm{i} \hbar \, \varepsilon_{\alpha \beta \gamma} \, J_\gamma $$&lt;p&gt;&#xA;则我们称它为一种&lt;strong&gt;角动量&lt;/strong&gt;.&#xA;角动量都具有以下对易关系&#xA;&lt;/p&gt;&#xA;$$[\mathbf{J}^2, J_\alpha] = 0$$&lt;p&gt;&#xA;这说明角动量的值与某一个角动量分量可以被同时测得, 一般我们选择 \(z\) 轴分量 \(J_z\).&lt;/p&gt;&#xA;&lt;p&gt;我们将角动量值 \(\mathbf{J}^2\) 与 \(z\) 轴角动量 \(J_z\) 的共同本征态记作 \(\ket{\lambda, m}\), 其中 \(\mathbf{J}^2 \ket{\lambda, m} = \lambda \hbar^2 \ket{\lambda, m}\), \(J_z \ket{\lambda, m} = m \hbar \ket{\lambda, m}\).&lt;/p&gt;&#xA;&lt;h2 id=&#34;阶梯算符&#34;&gt;阶梯算符&lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b6%e6%a2%af%e7%ae%97%e7%ac%a6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;定义两个重要的&lt;strong&gt;阶梯算符&lt;/strong&gt; \(J_\pm := J_x \pm \mathrm{i} J_y\).&#xA;这两个算符不是厄米算符, 因此它不能对应一种可观测的力学量.&#xA;我们可以发现它的对易关系&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>若尔当标准型</title>
      <link>https://example.org/docs/jordan-normal-form/</link>
      <pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/jordan-normal-form/</guid>
      <description>&lt;h1 id=&#34;若尔当标准型&#34;&gt;若尔当标准型&lt;a class=&#34;anchor&#34; href=&#34;#%e8%8b%a5%e5%b0%94%e5%bd%93%e6%a0%87%e5%87%86%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;我们对若尔当标准型的讨论始于两个最基本与最常用的问题:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如何将线性空间 \(V\) 分解为线性变换 \(A\) 的不变子空间 \(V_i\) 的直和?&lt;/li&gt;&#xA;&lt;li&gt;如何使线性变换 \(A\) 在 \(V\) 的一组基上具有最简洁的矩阵形式?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;对于问题一, 一个合理的附加条件是 \(A\) 在这些不变子空间 \(V_i\) 上具有良好的性质, 这样要研究 \(A\), 只需在每个更小的空间上研究, 并且充分利用那些性质, 最后汇总为 \(V\) 即可.&#xA;问题二则是为了方便计算, 我们可以利用这种简洁矩阵的性质, 提供远比普通矩阵乘法等更优的算法.&lt;/p&gt;&#xA;&lt;p&gt;对于这两个问题, 我们首先想到的应该是线性变化的对角化.&#xA;对于可对角化的线性变换, 充要条件之一便是线性空间 \(V\) 可以被分解为特征子空间的直和 \(V = E_{\lambda_1} \oplus E_{\lambda_2} \oplus \cdots \oplus E_{\lambda_r}\).&#xA;并且我们知道这一变换在其特征向量组成的基下是对角矩阵.&#xA;这样两个问题就都得到解决.&#xA;遗憾的是, 并非每一个矩阵都可以对角化. 我们要讨论的便是一种类似对角化的, 可以对每个变换进行的分解.&lt;/p&gt;</description>
    </item>
    <item>
      <title>可交换的线性变换</title>
      <link>https://example.org/docs/commutative-lt/</link>
      <pubDate>Sat, 01 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/commutative-lt/</guid>
      <description>&lt;h1 id=&#34;可交换的线性变换&#34;&gt;可交换的线性变换&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e4%ba%a4%e6%8d%a2%e7%9a%84%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;这篇文章讨论可交换的线性变换, 即对于线性变换 \(A\), \(B\), 有 \(AB = BA\).&lt;/p&gt;&#xA;&lt;h2 id=&#34;引理&#34;&gt;引理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;对于多项式 \(f\), \(f(A)\) 与 \(B\) 可交换的充要条件是 \(A\), \(B\) 可交换.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;h2 id=&#34;充要条件&#34;&gt;充要条件&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%85%e8%a6%81%e6%9d%a1%e4%bb%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;复数域上线性变换 \(A\), \(B\) 可交换的充要条件是:&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;\(A\) 的每个广义特征空间 \(E_{\lambda}\) 都是 \(B\) 的不变子空间.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;p&gt;其中&lt;em&gt;广义特征空间&lt;/em&gt; \(E_{\lambda} = \{\mathbf{v} ~ | ~ (A - \lambda I)^m \; \mathbf{v} = \mathbf{0}, m \in \mathbb{N}_+\}\).&#xA;线性空间 \(V\) 总是可以分解为其上某一线性变换的广义特征空间的直和.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;:&lt;br&gt;&#xA;&lt;strong&gt;充分性&lt;/strong&gt;:&#xA;任取 \(A\) 在重数 \(m\) 的广义特征空间 \(E_{\lambda}\), \(\forall \mathbf{v} \in E_{\lambda}; B \mathbf{v} \in E_{\lambda}\).&#xA;于是 \(B (A - \lambda I)^m \mathbf{v} = B \; \mathbf{0} = \mathbf{0}\), \((A - \lambda I)^m B \mathbf{v} = (A - \lambda I)^m (B \mathbf{v}) = \mathbf{0}\).&#xA;注意到 \((A - \lambda I)^m\) 是关于 \(A\) 的多项式, 由此可得 \(E_{\lambda}\) 上 \(A\) 与 \(B\) 可交换.&lt;/p&gt;</description>
    </item>
    <item>
      <title>密度流体的动态模拟</title>
      <link>https://example.org/docs/dynamic-simulation-of-density-fluids/</link>
      <pubDate>Sun, 26 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/dynamic-simulation-of-density-fluids/</guid>
      <description>&lt;h1 id=&#34;密度流体的动态模拟&#34;&gt;密度流体的动态模拟&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%86%e5%ba%a6%e6%b5%81%e4%bd%93%e7%9a%84%e5%8a%a8%e6%80%81%e6%a8%a1%e6%8b%9f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;我们将不可压缩流体的模拟分为两类, 一类聚焦于流体本身, 另一类则聚焦依托于流场的标量场.&#xA;前者称为&lt;strong&gt;体积流体&lt;/strong&gt;, 如水与空气二相的模拟, 我们更关心流体本身的运动;&#xA;后者称为&lt;strong&gt;密度流体&lt;/strong&gt;, 如充斥于密闭容器中的浊液的模拟, 我们关注的是溶质的物质的量密度这一标量.&#xA;需要注意的是这两个词仅为本篇文章的约定, 而非正式的学术用语.&lt;/p&gt;&#xA;&lt;p&gt;本文讲述了不可压缩密度流体的运动学模拟.&#xA;纵览符合这一条件的流场, 如附加温度场, 容质的密度场等, 其标量场都耦合于流体的速度场.&#xA;这是指标量会被流体输运, 例如温度的对流;&#xA;标量场同时可以反过来影响速度场, 例如渗透压导致的流体运动, 但我们一般不认为它会破坏流体的不可压缩性, 否则这将导致被求解方程的形式变得极端复杂.&lt;/p&gt;&#xA;&lt;p&gt;写出不可压缩流体的&lt;em&gt;纳维 - 斯托克斯方程&lt;/em&gt;:&#xA;&lt;/p&gt;&#xA;$$\nabla \cdot \mathbf{u} = 0$$&lt;p&gt;&#xA;&lt;/p&gt;&#xA;$$\frac{\mathrm{D} \mathbf{u}}{\mathrm{D} t} = -\nabla \frac{p}{\rho} + \nu \nabla^2 \mathbf{u} + \mathbf{a}$$&lt;p&gt;&#xA;前者是质量守恒定律对应的连续性方程在不可压缩, 即 \(\rho \equiv \mathrm{const}\) 时的推论;&#xA;后者是牛顿第二定律.&#xA;其中 \(\nu\) 是&lt;em&gt;运动粘度&lt;/em&gt;, \(\nu := \mu/\rho\), \(\mu\) 是&lt;em&gt;动力粘度&lt;/em&gt;.&#xA;流体力学中, 我们一般用 \(\mathbf{u}\) 代表速度.&lt;/p&gt;&#xA;&lt;p&gt;后式中出现的&lt;em&gt;随质导数&lt;/em&gt;, 或称&lt;em&gt;物质导数&lt;/em&gt; \(\frac{\mathrm{D}}{\mathrm{D} t} := \frac{\partial}{\partial t} + (\mathbf{u} \cdot \nabla)\).&#xA;这一式中前者表示欧拉导数; 后者表示拉格朗日导数, 即由于流体的运动带来的变化, 这个效应称为移流.&#xA;将其拆开可以写为&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>从中科大回来的时候我母亲就预言了我的今天</title>
      <link>https://example.org/docs/long-time-ago-a-essay/</link>
      <pubDate>Sun, 17 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/long-time-ago-a-essay/</guid>
      <description>&lt;h1 id=&#34;从中科大回来的时候我母亲就预言了我的今天&#34;&gt;从中科大回来的时候我母亲就预言了我的今天&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8e%e4%b8%ad%e7%a7%91%e5%a4%a7%e5%9b%9e%e6%9d%a5%e7%9a%84%e6%97%b6%e5%80%99%e6%88%91%e6%af%8d%e4%ba%b2%e5%b0%b1%e9%a2%84%e8%a8%80%e4%ba%86%e6%88%91%e7%9a%84%e4%bb%8a%e5%a4%a9&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;*&lt;strong&gt;邓平红&lt;/strong&gt; (知乎@wishkind)&lt;/p&gt;&#xA;&lt;p&gt;1982 年, 我不辞而别, 离开了中科大, 想要跳到长江自杀.&lt;/p&gt;&#xA;&lt;p&gt;因为, 当时寝室同学宋元璋在暗中联络金华的汤杰, 常熟的刘国圣给我捣鬼, 我作为中科大 826 系的学生会主席, 元旦来了, 不知道如何搞班级活动.&lt;/p&gt;&#xA;&lt;p&gt;同学晚上聊天到零点, 然后立即停止, 第二天六点种准时起床. 我在这种环境睡不着觉, 因为我在中学虽然是和同学睡在一个教室, 但是, 我睡觉的时候, 同学们都会睡觉, 因为, 我在中学的成绩一直是全校第一名, 我的脑筋坏了, 不能通宵达旦学习, 不能听老师念经, 我只是在有个别疑问的时候, 去找老师问问, 其它时间全是自学, 我一般只需要把课本的目录浏览, 然后, 针对疑问做几个题目, 就可以了, 所以, 我到了九点多钟就要睡觉.&lt;/p&gt;&#xA;&lt;p&gt;同学们也因此跟着睡觉.&lt;/p&gt;&#xA;&lt;p&gt;但是, 大学就不是我主宰, 寝室同学有三个在暗中捣鬼, 两个安徽的同学汤枫保持中立, 陆宁龙的父亲是芜湖师范大学的政治教授, 他劝我不要去搞文艺, 要用自己的长处对付同学的短处, 我的长处就是读书.&lt;/p&gt;&#xA;&lt;p&gt;但是, 我那个时候被魔鬼控制了, 自卑忧郁.&lt;/p&gt;&#xA;&lt;p&gt;我在临近元旦的一次考试, 微积分考了 98 分, 我就很痛苦, 我感觉脑袋有点问题, 不能做到百分之百的精确.&lt;/p&gt;&#xA;&lt;p&gt;我在很小时候, 仔细观察了我的鸡巴, 为何有个洞呢? 这个洞会通向什么地方? 我翻开看看, 想想到底会通向什么地方?&lt;/p&gt;&#xA;&lt;p&gt;等我走进大学, 翻到一本书, 说手淫会导致痴呆.&lt;/p&gt;&#xA;&lt;p&gt;我想, 我小时候做的就是手淫, 现在我晚上睡不着觉, 将来要变痴呆, 那是多么耻辱啊. 于是, 我终于走上了自杀的道路.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ESP32 环境配置与开发</title>
      <link>https://example.org/docs/esp32-dev/</link>
      <pubDate>Sat, 05 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/esp32-dev/</guid>
      <description>&lt;h1 id=&#34;esp32-环境配置与开发&#34;&gt;ESP32 环境配置与开发&lt;a class=&#34;anchor&#34; href=&#34;#esp32-%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae%e4%b8%8e%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;我必须承认, esp idf 是我配置过最困难的开发环境.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;本篇文章的开发环境选择是 &lt;strong&gt;Visual Studio Code&lt;/strong&gt; 与 &lt;strong&gt;esp idf&lt;/strong&gt;.&#xA;以 &lt;a href=&#34;https://www.waveshare.net/wiki/ESP32-S3-Nano&#34;&gt;&lt;strong&gt;微雪电子 ESP32-S3-Nano&lt;/strong&gt; 开发板&lt;/a&gt; 为例; 这款开发板理论上与 &lt;strong&gt;Arduino Nano esp32&lt;/strong&gt; 开发板完全兼容.&#xA;在 &lt;a href=&#34;https://docs.arduino.cc/resources/pinouts/ABX00083-full-pinout.pdf&#34;&gt;这里&lt;/a&gt; 可以找到 Arduino 开发板的引脚定义.&lt;/p&gt;&#xA;&lt;h2 id=&#34;esp-idf-安装与配置&#34;&gt;esp idf 安装与配置&lt;a class=&#34;anchor&#34; href=&#34;#esp-idf-%e5%ae%89%e8%a3%85%e4%b8%8e%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;esp idf 有两种安装途径: 通过官方安装器; 或是通过 VSCode 插件安装.&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint warning&#39;&gt;&#xA;&lt;p&gt;上述两种方式安装的 esp idf 互不兼容.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;鉴于我们将在 VSCode 中进行开发, 所以最好选择第二种: 通过插件安装.&lt;/p&gt;&#xA;&lt;p&gt;具体的安装过程可以在 &lt;a href=&#34;https://docs.espressif.com/projects/vscode-esp-idf-extension/zh_CN/latest/installation.html&#34;&gt;官方教程&lt;/a&gt; 找到.&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装-usb-设备驱动&#34;&gt;安装 USB 设备驱动&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85-usb-%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;安装 &lt;a href=&#34;https://zadig.akeo.ie&#34;&gt;Zadig&lt;/a&gt;. 启动它, 选择 &lt;em&gt;Options &amp;gt; List All Devices&lt;/em&gt;.&#xA;此时应该能在下拉菜单中找到两个 &lt;code&gt;USB JTAG/serial debug unit&lt;/code&gt;, 分别以 &lt;code&gt;Interface 0&lt;/code&gt; 与 &lt;code&gt;Interface 2&lt;/code&gt; 区分. 下面分别设置这两个的驱动.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mahony 非线性互补滤波器</title>
      <link>https://example.org/docs/mahony-complementary-filter/</link>
      <pubDate>Mon, 30 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/mahony-complementary-filter/</guid>
      <description>&lt;h1 id=&#34;mahony-非线性互补滤波器&#34;&gt;Mahony 非线性互补滤波器&lt;a class=&#34;anchor&#34; href=&#34;#mahony-%e9%9d%9e%e7%ba%bf%e6%80%a7%e4%ba%92%e8%a1%a5%e6%bb%a4%e6%b3%a2%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;Mahony 互补滤波算法是一种成熟的姿态估计算法, 旨在融合多种传感器的数据来估计最优姿态. 本篇文章将介绍这一滤波器的数学推导与应用.&lt;/p&gt;&#xA;&lt;p&gt;在第一章中, 我们先约定文章中使用的符号, 并对不同传感器的数据进行建模;&#xA;第二章, 从刚体的运动学入手, 使用李群与李代数作为分析工具;&#xA;第三章介绍优化姿态的方法, 并引出两个滤波器: &lt;strong&gt;直接互补滤波器&lt;/strong&gt; (&lt;strong&gt;Direct Complementary Filter&lt;/strong&gt;) 与&lt;strong&gt;被动互补滤波器&lt;/strong&gt; (&lt;strong&gt;Passive Complementary Filter&lt;/strong&gt;);&#xA;第四章在被动互补滤波器的基础上讨论更方便的向量版本, 称为&lt;strong&gt;显式互补滤波器&lt;/strong&gt; (&lt;strong&gt;Explicit Complementary Filter&lt;/strong&gt;);&#xA;在第五章中, 我们进一步讨论显式互补滤波器的四元数版本.&#xA;本文将不涉及系统的 Lyapunov 稳定性分析.&lt;/p&gt;&#xA;&lt;p&gt;本文主要编译自 Mahony 等人发表在 &lt;em&gt;IEEE Transactions on Automatic Control&lt;/em&gt; 上的论文&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;符号约定与传感器数据建模&#34;&gt;符号约定与传感器数据建模&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%a6%e5%8f%b7%e7%ba%a6%e5%ae%9a%e4%b8%8e%e4%bc%a0%e6%84%9f%e5%99%a8%e6%95%b0%e6%8d%ae%e5%bb%ba%e6%a8%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;文章中 \([\cdot]_\times\) 表示向量的外积矩阵, 它是一个反对称矩阵.&#xA;使用 \(\dot{R} := \partial R := \frac{\mathrm{d} R}{\mathrm{d} t}\) 表示求导.&#xA;线性函数 \(\mathrm{vex}(\cdot)\) 表示将李代数, 即反对称矩阵转为向量;&#xA;类似地, 我们有 \(\mathrm{wedge}(\cdot)\) 将向量转为李代数.&#xA;另外, 约定线性函数 \(\mathbb{P}_a(A) := \frac{1}{2} (A - A^T)\) 将矩阵映射为一个反对称矩阵.&lt;/p&gt;</description>
    </item>
    <item>
      <title>异步非阻塞串口数据接收</title>
      <link>https://example.org/docs/async-serial/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/async-serial/</guid>
      <description>&lt;h1 id=&#34;异步非阻塞串口数据接收&#34;&gt;异步非阻塞串口数据接收&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e%e4%b8%b2%e5%8f%a3%e6%95%b0%e6%8d%ae%e6%8e%a5%e6%94%b6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;异步&#34;&gt;异步?&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;异步 (asynchronous)&lt;/em&gt; 编程是一种并发的编程模式, 可以有效节省 CPU 阻塞等待 I/O 事件造成的时间浪费, 借以提高性能.&lt;/p&gt;&#xA;&lt;p&gt;在这里也简单介绍一下 &lt;em&gt;并行 (parallel)&lt;/em&gt; 与 &lt;em&gt;并发 (concurrent)&lt;/em&gt; 的区别. 并发是指多个任务可以被同时运行的现象; 但需要注意的是, 并发在某一时刻可能并不一定有多个任务在运行. 但是并行是严格的多线程工作模式, 在某一时刻有多个任务在同时工作. 于是很容易看出, 并行也被包含在并发之中.&lt;/p&gt;&#xA;&lt;p&gt;异步的核心在于一个字 &amp;ldquo;&lt;strong&gt;等&lt;/strong&gt;&amp;rdquo;. 简而言之, 异步编程好似去食堂窗口买饭, 当你告诉他你要点的餐以后, 不是一定要在窗口前等着, 而是可以去做点别的事情, 比如买瓶饮料什么的, 直到老板通知你取餐, 这就是一次异步事件. 在编程时我们调用一个异步 API, 若它不能立刻返回结果, 那么也不会阻塞等待, 而是立刻向后执行; 直到获取到结果再通知我们进行处理.&lt;/p&gt;&#xA;&lt;p&gt;不同的语言有各色的异步支持, &lt;code&gt;JavaScript&lt;/code&gt; 和 &lt;code&gt;Rust&lt;/code&gt; 的异步模型都很有代表性. &lt;code&gt;JavaScript&lt;/code&gt; 中, 异步函数可以返回一个 &lt;code&gt;Promise&lt;/code&gt; 对象, 其名字形象地说明了它的功能: 我承诺完成你要的操作; 潜台词则是我保证 &lt;strong&gt;将来&lt;/strong&gt; 会完成你要的操作, 不一定是立刻做到. &lt;code&gt;Rust&lt;/code&gt; 的 &lt;code&gt;Future&lt;/code&gt; 机制则更为直白: 你的任务我将来会完成的.&lt;/p&gt;&#xA;&lt;p&gt;非多线程的异步程序的本质是 CPU 的 &lt;strong&gt;时分复用&lt;/strong&gt;, 它用划分时间片交替运行各项任务来模拟同时运行每项任务. 必须指出, 有些语言实际上使用多线程实现的异步, 在这种情况下可以实现真正的并行, 即每个时刻多项任务同时被运行. 于是很容易推断, 若 CPU 本来就没有空闲时间, 那么非多线程的异步也并不能提高效率. 这也是为什么异步大多都被用于 I/O 操作, 因为可以有效利用好 I/O 事件中因为等待而空闲的 CPU 时间. 若是 CPU 密集型的工作, 例如科学计算等, 使用异步模型反而会因为时间片切换而损失性能. 这种情况更适合用多线程的方法提高效率.&lt;/p&gt;</description>
    </item>
    <item>
      <title>三维空间中刚体运动的描述</title>
      <link>https://example.org/docs/rigid-movement/</link>
      <pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/rigid-movement/</guid>
      <description>&lt;h1 id=&#34;三维空间中刚体运动的描述&#34;&gt;三维空间中刚体运动的描述&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e7%bb%b4%e7%a9%ba%e9%97%b4%e4%b8%ad%e5%88%9a%e4%bd%93%e8%bf%90%e5%8a%a8%e7%9a%84%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;刚体运动由旋转与平移组成, 与旋转类似, 可以用矩阵来表示:&#xA;&lt;/p&gt;&#xA;$$&#xA;T =&#xA;\begin{pmatrix}&#xA;R &amp; \mathbf{\rho} \\&#xA;  &amp; 1&#xA;\end{pmatrix}&#xA;$$&lt;p&gt;&#xA;其中 \(R\) 是旋转矩阵, \(\mathbf{v}\) 是表征平移的向量.&#xA;刚体运动矩阵作用于三维向量的齐次坐标上.&lt;/p&gt;&#xA;&lt;p&gt;同样与旋转类似, 所有刚体运动矩阵构成一个群, 称为 &lt;em&gt;特殊欧氏群&lt;/em&gt; \(SE(3)\).&lt;/p&gt;&#xA;&lt;p&gt;\(SE(3)\) 也是一个 &lt;em&gt;李群&lt;/em&gt;, 它的 &lt;em&gt;李代数&lt;/em&gt; \(\mathfrak{se} (3)\) 中的元素为如下形式:&#xA;&lt;/p&gt;&#xA;$$\begin{pmatrix}&#xA;\theta [\hat{\mathbf{\omega}}]_\times &amp; \mathbf{v} \\&#xA;                                      &amp; 0&#xA;\end{pmatrix}$$&lt;p&gt;&#xA;这里 \([\hat{\mathbf{\omega}}]_\times\) 表示单位向量的外积矩阵.&lt;/p&gt;&#xA;&lt;p&gt;本篇文章的工作是推导 \(SE(3)\), \(\mathfrak{se}(3)\) 与 \(\mathbb{R}^6\) 中元素的互相转换.&#xA;\(\mathbb{R}^6\) 中的元素也被称为 &lt;em&gt;运动旋量&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;引理&#34;&gt;引理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;$$\boxed{&#xA;\begin{pmatrix}&#xA;\theta [\hat{\mathbf{\omega}}]_\times &amp; \mathbf{v} \\&#xA;                                      &amp; 0&#xA;\end{pmatrix}^n =&#xA;\begin{pmatrix}&#xA;\theta^n [\hat{\mathbf{\omega}}]_\times^n &amp;&#xA;\theta^{n-1} [\hat{\mathbf{\omega}}]_\times^{n-1} \mathbf{v} \\&#xA;                                          &amp; 0&#xA;\end{pmatrix}&#xA;}$$&lt;p&gt;直接计算便可得到.&lt;/p&gt;</description>
    </item>
    <item>
      <title>三维空间中旋转的描述</title>
      <link>https://example.org/docs/rigid-rotation/</link>
      <pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/rigid-rotation/</guid>
      <description>&lt;h1 id=&#34;三维空间中旋转的描述&#34;&gt;三维空间中旋转的描述&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e7%bb%b4%e7%a9%ba%e9%97%b4%e4%b8%ad%e6%97%8b%e8%bd%ac%e7%9a%84%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;三维空间中所有正交且行列式为 \(1\) 的矩阵组成一个群, 称为 &lt;em&gt;特殊正交群&lt;/em&gt; \(SO(3)\),&#xA;其中的每个元素都代表一种三维空间中的旋转.&lt;/p&gt;&#xA;&lt;p&gt;另外, \(SO(3)\) 也是一个 &lt;em&gt;李群&lt;/em&gt;, 它的 &lt;em&gt;李代数&lt;/em&gt; \(\mathfrak{so}(3)\) 中的元素是轴角向量的外积矩阵.&lt;/p&gt;&#xA;&lt;p&gt;本篇文章的工作是推导 \(SO(3)\), \(\mathfrak{so}(3)\) 与 \(\mathbb{R}^3\) 中元素的互相转换.&lt;/p&gt;&#xA;&lt;h2 id=&#34;引理&#34;&gt;引理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;$$\boxed{&#xA;[\mathbf{\omega}]_\times^2 = \mathbf{\omega} \mathbf{\omega}^T - \|\mathbf{\omega}\|^2 I&#xA;}$$$$\begin{align*}&#xA;([\mathbf{\omega}]_\times^2)_{ij} &amp;= \varepsilon_{imk} \omega_m ~ \varepsilon_{knj} \omega_n \\&#xA;                                  &amp;= \varepsilon_{kim} \varepsilon_{knj} ~ \omega_m \omega_n \\&#xA;                                  &amp;= (\delta_{in} \delta_{mj} - \delta_{ij} \delta_{mn}) \omega_m \omega_n \\&#xA;                                  &amp;= \omega_i \omega_j - \delta_{ij} \omega_m \omega_m \\&#xA;                                  &amp;= (\mathbf{\omega} \mathbf{\omega}^T - \|\mathbf{\omega}\|^2 I)_{ij}&#xA;\end{align*}$$&lt;hr&gt;&#xA;$$\boxed{&#xA;[\mathbf{\omega}]_\times^3 = - \|\mathbf{\omega}\|^2 [\mathbf{\omega}]_\times&#xA;}$$$$\begin{align*}&#xA;[\mathbf{\omega}]_\times^3 &amp;= (\mathbf{\omega} \mathbf{\omega}^T - \|\mathbf{\omega}\|^2 I) [\mathbf{\omega}]_\times \\&#xA;                           &amp;= \mathbf{\omega} \mathbf{\omega}^T [\mathbf{\omega}]_\times - \|\mathbf{\omega}\|^2 [\mathbf{\omega}]_\times \\&#xA;                           &amp;= \mathbf{\omega} ([\mathbf{\omega}]_\times \mathbf{\omega})^T - \|\mathbf{\omega}\|^2 [\mathbf{\omega}]_\times \\&#xA;                           &amp;= \mathbf{\omega} (\mathbf{\omega} \times \mathbf{\omega})^T - \|\mathbf{\omega}\|^2 [\mathbf{\omega}]_\times \\&#xA;                           &amp;= - \|\mathbf{\omega}\|^2 [\mathbf{\omega}]_\times&#xA;\end{align*}$$&lt;hr&gt;&#xA;$$\boxed{&#xA;\mathrm{rank} [\mathbf{\omega}]_\times = 2&#xA;}$$&lt;p&gt;&#xA;其中 \(\mathbf{\omega} \in \mathbb{R}^3 \backslash \{0\}\).&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用泰勒展开的运动预测</title>
      <link>https://example.org/docs/time-series-forecasting-using-taylor/</link>
      <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/time-series-forecasting-using-taylor/</guid>
      <description>&lt;h1 id=&#34;使用泰勒展开的运动预测&#34;&gt;使用泰勒展开的运动预测&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e6%b3%b0%e5%8b%92%e5%b1%95%e5%bc%80%e7%9a%84%e8%bf%90%e5%8a%a8%e9%a2%84%e6%b5%8b&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在 \(n\) 维空间运动的物体, 其运动方程总可以写成 \(n\) 个关于时间 \(t\) 的参数方程.&lt;/p&gt;&#xA;&lt;p&gt;进一步地, 将关于 \(t\) 的参数方程泰勒展开为关于 \(t\) 的多项式函数, 可以显式得到其表达式,&#xA;并且可以计算出超过当前时刻, 也就是未来时刻的位置.&#xA;当超出当前时刻的时间不长, 运动轨迹是平滑的且分辨率足够高时, 可以认为此级数收敛于实际的位置.&lt;/p&gt;&#xA;&lt;p&gt;泰勒展开所需的各阶导数可以通过数值计算获得.&lt;/p&gt;&#xA;&lt;h2 id=&#34;参数获取&#34;&gt;参数获取&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e6%95%b0%e8%8e%b7%e5%8f%96&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;假如我们已经获得位置关于时间的一系列数据 \(\{r_n\}\), 其中 \(r_n\) 是当前时刻的数据.&#xA;它也可以被记作 \(r_n^{(0)}\). 对应的时刻记为 \(t_n\), 或 \(t_n^{(0)}\).&lt;/p&gt;&#xA;&lt;p&gt;根据函数导数的公式, 自然地我们想到当前时刻位置的一阶导数为 \(r_n^{(1)} = \frac{r_n - r_{n-1}}{\Delta t_n}\),&#xA;其中 \(\Delta t_n := t_n - t_{n-1}\),&#xA;以及过去时刻的导数同理.&lt;/p&gt;&#xA;&lt;p&gt;于是, 我们获得了 \(n-1\) 个一阶导数组成的序列 \(\{r_n^{(1)}\}\). 进一步可以计算二阶乃至 \(n-1\) 阶导数:&lt;/p&gt;&#xA;$$r_n^{(m)} = \frac{r_n^{(m-1)} - r_{n-1}^{(m-1)}}{\Delta t_n^{(m-1)}}$$$$\Delta t_n^{(m)} = \frac{\Delta t_n^{(m-1)} + \Delta t_{n-1}^{(m-1)}}{2}$$&lt;p&gt;另外 \(\Delta t_n^{(0)} := \Delta t_n\).&lt;/p&gt;</description>
    </item>
    <item>
      <title>抛体运动弹道解算</title>
      <link>https://example.org/docs/ballistics/</link>
      <pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/ballistics/</guid>
      <description>&lt;h1 id=&#34;抛体运动弹道解算&#34;&gt;抛体运动弹道解算&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%9b%e4%bd%93%e8%bf%90%e5%8a%a8%e5%bc%b9%e9%81%93%e8%a7%a3%e7%ae%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;模型&#34;&gt;模型&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;本文考虑使用 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%e9%98%bb%e5%8a%9b#%e9%9b%b7%e8%ab%be%e6%95%b8%e5%be%88%e4%bd%8e%e6%99%82%e7%9a%84%e9%98%bb%e5%8a%9b&#34;&gt;&lt;em&gt;线性阻力&lt;/em&gt;&lt;/a&gt; 模型.&#xA;事实上, 在空气中运动的阻力应该由 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%e9%98%bb%e5%8a%9b#%e9%ab%98%e9%80%9f%e6%99%82%e7%9a%84%e9%98%bb%e5%8a%9b&#34;&gt;&lt;em&gt;二次阻力&lt;/em&gt;&lt;/a&gt; 描述, 关于二者的对比将在 &lt;a href=&#34;#%e4%b8%8e%e4%ba%8c%e6%ac%a1%e9%98%bb%e5%8a%9b%e7%9a%84%e5%af%b9%e6%af%94&#34;&gt;后文&lt;/a&gt; 给出.&lt;/p&gt;&#xA;&lt;p&gt;之所以使用线性阻力, 是因为如此一来物体的运动微分方程&lt;/p&gt;&#xA;$$m \dot{\mathbf{v}} = -k \mathbf{v} - m g \hat{\mathbf{j}}$$&lt;p&gt;有封闭解. 进一步令 \(\mu := \frac{k}{m}\), 上式化为&lt;/p&gt;&#xA;$$\dot{\mathbf{v}} = -\mu \mathbf{v} - g \hat{\mathbf{j}}$$&lt;p&gt;容易解得&lt;/p&gt;&#xA;$$\mathbf{v} = \mathrm{e}^{-\mu t} \mathbf{v}_0 - \mu^{-1} (1-\mathrm{e}^{-\mu t}) g \hat{\mathbf{j}}$$&lt;p&gt;积分得&lt;/p&gt;&#xA;$$&#xA;\mathbf{r} = \mathbf{r}_0 - \mu^{-1} (1-\mathrm{e}^{-\mu t}) \mathbf{v}_0 - \mu^{-2} (\mu t + \mathrm{e}^{-\mu t} - 1) g \, \hat{\mathbf{j}}&#xA;$$&lt;p&gt;这就是线性阻力情况下的运动方程. 它也可以很轻松地分解为两个方向来运算.&lt;/p&gt;&#xA;&lt;h3 id=&#34;与二次阻力的对比&#34;&gt;与二次阻力的对比&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8e%e4%ba%8c%e6%ac%a1%e9%98%bb%e5%8a%9b%e7%9a%84%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;当速度较大 (\(\sim 20 ~ \mathrm{m/s}\)) 时, 弹丸在空气中运动的 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%e9%9b%b7%e8%af%ba%e6%95%b0#%e6%b5%81%e4%bd%93%e4%b8%ad%e7%9a%84%e7%90%83&#34;&gt;&lt;em&gt;雷诺数&lt;/em&gt;&lt;/a&gt; 很大, 并不适用于线性阻力.&#xA;但是在上升过程中, 速度逐渐下降, 雷诺数也逐渐变小, 于是在上升阶段用线性阻力模型的误差也不是很大.&lt;/p&gt;</description>
    </item>
    <item>
      <title>约定式提交</title>
      <link>https://example.org/docs/conventional-commits/</link>
      <pubDate>Sun, 26 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/conventional-commits/</guid>
      <description>&lt;h1 id=&#34;约定式提交&#34;&gt;约定式提交&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%a6%e5%ae%9a%e5%bc%8f%e6%8f%90%e4%ba%a4&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;约定式提交规定了一套编写 &lt;code&gt;git&lt;/code&gt; 提交信息的规范, 方便写出清晰, 突出重点, 分类明确的提交信息, 尤其在团队协作时十分必要.&lt;/p&gt;&#xA;&lt;p&gt;本文中介绍的规范有别于标准的 &lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;约定式提交规范&lt;/a&gt;, 在一些方面做了让步, 方便新手编写.&lt;/p&gt;&#xA;&lt;h2 id=&#34;概述&#34;&gt;概述&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;一个提交应由以下几部分组成&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;类型&amp;gt;: &amp;lt;描述&amp;gt;&#xA;&#xA;[正文]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;em&gt;类型&lt;/em&gt; 字段见下文 &lt;a href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;类型&lt;/a&gt; 一章.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;描述&lt;/em&gt; 应当是对提交的一句话总结, 力求简洁清楚, 重点分明. 对于描述部分的详细解释, 可以写在 &lt;em&gt;正文&lt;/em&gt; 部分. 正文并非必要, 最好只在提交十分复杂, 或是包含了多个不同修改时编写.&lt;/p&gt;&#xA;&lt;p&gt;要使用约定式提交, 需要对提交本身进行规范:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拆分不同文件的修改.&lt;br&gt;&#xA;例如文档的修改与源代码的修改应该分开提交;&#xA;配置文件, 测试代码, 编译脚本等等都应该尽量分离.&#xA;可以阅读 &lt;a href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;类型&lt;/a&gt; 一章, 了解哪些修改应该单独提交.&#xA;拆分提交的方法在 &lt;a href=&#34;https://example.org/docs/git-tips/#%e6%8b%86%e5%88%86%e6%8f%90%e4%ba%a4&#34;&gt;这里&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;尽量更细致地进行提交, 一次提交一个功能的修改.&lt;br&gt;&#xA;也就是说, 不要一股脑将全部文件的修改送入版本库.&#xA;例如在某一源代码文件中, 既修改了数据的展示方式, 又修改了某 API 的实现,&#xA;那它们应该被拆分为两个提交.&lt;/li&gt;&#xA;&lt;li&gt;避免过于细小的提交.&lt;br&gt;&#xA;某些微小又不重要的提交,&#xA;例如文档中某个拼写或代码某处符号后的空格, 可以等后面修改此文件时一并提交.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;描述与正文部分尽量使用 &lt;code&gt;markdown&lt;/code&gt; 语言标记. 特别地, 提到文件名时应使用反引号 &lt;code&gt;`&lt;/code&gt; 括起.&#xA;在正文中陈列多条修改时使用 &lt;code&gt;markdown&lt;/code&gt; 的列表语法.&lt;/p&gt;&#xA;&lt;p&gt;当修改过多以至于无法细致提交时, 可以在描述处写 &lt;strong&gt;多次提交&lt;/strong&gt;, 转而在正文处陈列.&#xA;但是强烈建议涉及业务功能的修改不要这样, 以免淹没在不重要的琐碎提交中.&lt;/p&gt;</description>
    </item>
    <item>
      <title>`git` 子模块</title>
      <link>https://example.org/docs/git-submodule/</link>
      <pubDate>Sat, 25 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/git-submodule/</guid>
      <description>&lt;h1 id=&#34;git-子模块&#34;&gt;&lt;code&gt;git&lt;/code&gt; 子模块&lt;a class=&#34;anchor&#34; href=&#34;#git-%e5%ad%90%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;git&lt;/code&gt; &lt;em&gt;子模块 (submodule)&lt;/em&gt; 是挂于某 &lt;code&gt;git&lt;/code&gt; 仓库下的子仓库. 当父仓库想使用第三方或者是与主业务分离的模块时, 可以通过将其注册为子模块来增加灵活性.&lt;/p&gt;&#xA;&lt;h2 id=&#34;添加子模块&#34;&gt;添加子模块&lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0%e5%ad%90%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;通过在父仓库使用&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;git submodule add &amp;lt;url&amp;gt; &amp;lt;path&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;可以在 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 地址处添加一个子模块.&lt;/p&gt;&#xA;&lt;p&gt;其中, &lt;code&gt;url&lt;/code&gt; 可以为远程仓库地址, 也可以是本地仓库地址. 例如, 要把下面的 &lt;code&gt;new_repo&lt;/code&gt; 仓库添加为 &lt;code&gt;repo&lt;/code&gt; 的子模块, 可以使用命令:&lt;br&gt;&#xA;&lt;code&gt;git submodule add ./3rd/new_repo 3rd/new_repo&lt;/code&gt;&lt;br&gt;&#xA;其中 &lt;code&gt;./3rd/new_repo&lt;/code&gt; 即为本地仓库的 &lt;code&gt;url&lt;/code&gt;. 需要注意的是本地 &lt;code&gt;url&lt;/code&gt; 前面的 &lt;code&gt;./&lt;/code&gt; 或 &lt;code&gt;../&lt;/code&gt; 是必须的, &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 也不能省略.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;repo&#xA;├─ .git&#xA;└─ 3rd&#xA;    └─ new_repo&#xA;        └─ .git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;另外一个远程仓库的例子. 若想把 &lt;code&gt;github.com/user/new_repo.git&lt;/code&gt; 仓库添加为 &lt;code&gt;repo&lt;/code&gt; 的子模块, 并要求 &lt;code&gt;new_repo&lt;/code&gt; 放置在 &lt;code&gt;3rd&lt;/code&gt; 文件夹内, 可以使用命令:&lt;br&gt;&#xA;&lt;code&gt;git submodule add github.com/user/new_repo 3rd&lt;/code&gt;&lt;br&gt;&#xA;如果不指定后面的路径 &lt;code&gt;3rd&lt;/code&gt;, 则会直接把 &lt;code&gt;new_repo&lt;/code&gt; 克隆到父仓库目录下.&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于知识库框架结构的一些想法</title>
      <link>https://example.org/docs/repo-struct/</link>
      <pubDate>Sat, 25 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/repo-struct/</guid>
      <description>&lt;h1 id=&#34;关于知识库框架结构的一些想法&#34;&gt;关于知识库框架结构的一些想法&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e4%ba%8e%e7%9f%a5%e8%af%86%e5%ba%93%e6%a1%86%e6%9e%b6%e7%bb%93%e6%9e%84%e7%9a%84%e4%b8%80%e4%ba%9b%e6%83%b3%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;因为我的各种文档或笔记过于分散凌乱, 非常需要进行统一管理. 但是使用的技术栈千差万别, 有纯文字用 &lt;code&gt;markdown&lt;/code&gt; 写的, 有使用 &lt;code&gt;jupyter&lt;/code&gt; 笔记本内嵌代码的, 有使用 &lt;code&gt;mathematica&lt;/code&gt; 的, 有用 &lt;code&gt;typst&lt;/code&gt; 和 &lt;code&gt;latex&lt;/code&gt; 写更专业的出版级文档的, 也有主要写代码附文说明的. 现有的知识库框架不可能支持如此多种类的文件管理, 事实上传统的知识库软件仅能做到管理文字内容, 并且也很难做到与其他编辑器的通用. 例如编写代码另附文档的情况, 势必要在其他编辑器处进行代码的编辑, 也当然希望在那里就完成文档的修改, 而不必打开特定的知识库管理或文档软件.&lt;/p&gt;&#xA;&lt;p&gt;我想通过 &lt;code&gt;git submodule&lt;/code&gt; 与 &lt;code&gt;obsidian&lt;/code&gt; 协同构建一个包罗万象的知识库框架, 力图让专业的软件做专业的事, 而不必让知识库管理它能力范围之外的文件, 例如源代码啊, 交互式笔记本啊什么的.&lt;/p&gt;&#xA;&lt;h2 id=&#34;obsidian-与-git-submodule&#34;&gt;&lt;code&gt;obsidian&lt;/code&gt; 与 &lt;code&gt;git submodule&lt;/code&gt;&lt;a class=&#34;anchor&#34; href=&#34;#obsidian-%e4%b8%8e-git-submodule&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;obsidian&lt;/code&gt; 本质上还是文字编辑软件, 在不加插件的前提下, 只有基础的文字编辑功能 (依托 &lt;code&gt;markdown&lt;/code&gt; 标记语言). 因此我们只让 &lt;code&gt;obsidian&lt;/code&gt; 管理博文和各类文档, 并辅以 &lt;code&gt;git&lt;/code&gt; 进行版本控制.&lt;/p&gt;&#xA;&lt;p&gt;项目结构如下:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;.&#xA;├─ Blog&#xA;└─ Work&#xA;    ├─ A&#xA;    └─ B&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中 &lt;code&gt;Blog&lt;/code&gt; 是记录日常或简单知识的文章; 而偏知识向或更专业的, 以及不使用 &lt;code&gt;markdown&lt;/code&gt; 语言写的内容都放置于 &lt;code&gt;Work&lt;/code&gt; 目录下, 每组另外再分目录.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git Tips</title>
      <link>https://example.org/docs/git-tips/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/git-tips/</guid>
      <description>&lt;h1 id=&#34;git-tips&#34;&gt;Git Tips&lt;a class=&#34;anchor&#34; href=&#34;#git-tips&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文件管理&#34;&gt;文件管理&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工作区&#34;&gt;工作区&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8c%ba&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;工作区&lt;/em&gt; 即整个工作空间的根目录, 也就是 &lt;code&gt;.git&lt;/code&gt; 目录存在的那一级目录. 对每个文件的修改都在这里进行.&lt;/p&gt;&#xA;&lt;p&gt;特殊地, 被 &lt;code&gt;.gitignore&lt;/code&gt; 排除的文件或目录不属于工作区. 这些文件将被彻底排除出 &lt;code&gt;git&lt;/code&gt; 的管理, &lt;strong&gt;对他们的操作也无法使用 &lt;code&gt;git&lt;/code&gt; 回退或恢复&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;暂存区&#34;&gt;暂存区&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%82%e5%ad%98%e5%8c%ba&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;当在工作区进行操作后, 使用 &lt;code&gt;git add&lt;/code&gt; 命令将修改的文件 &lt;em&gt;添加 (add)&lt;/em&gt; 到 &lt;em&gt;暂存区&lt;/em&gt;. 暂存区可以继续添加或移除文件, 直到使用 &lt;code&gt;git commit&lt;/code&gt; 命令将区内的文件一次性 &lt;em&gt;提交 (commit)&lt;/em&gt; 到版本库中.&lt;/p&gt;&#xA;&lt;h3 id=&#34;文件状态&#34;&gt;文件状态&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;被 &lt;code&gt;git&lt;/code&gt; 管理的文件有以下几种状态:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;U&lt;/code&gt;, &lt;code&gt;untrack&lt;/code&gt;: &lt;em&gt;未跟踪&lt;/em&gt;&lt;br&gt;&#xA;这是新创建的文件, 此前在工作区从未出现. 例如在工作区新建某一源代码文件, 并且写入部分内容, 这个文件就处于未跟踪状态.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;M&lt;/code&gt;, &lt;code&gt;modified&lt;/code&gt;: &lt;em&gt;已修改&lt;/em&gt;&lt;br&gt;&#xA;这是之前已被提交过的文件, 但是经过了一些修改, 使其与之前不同了. 例如在更改某一方法的实现等等.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;staged&lt;/code&gt;: &lt;em&gt;已暂存&lt;/em&gt;&lt;br&gt;&#xA;当把工作区的文件添加到暂存区后, 其状态就变为已暂存.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;committed&lt;/code&gt;: &lt;em&gt;已提交&lt;/em&gt;&lt;br&gt;&#xA;当把暂存区的文件提交到仓库后, 其状态就变为已提交.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;快速操作&#34;&gt;快速操作&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e9%80%9f%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;为-git-设置代理&#34;&gt;为 &lt;code&gt;git&lt;/code&gt; 设置代理&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba-git-%e8%ae%be%e7%bd%ae%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;git config --global http.proxy &amp;quot;http://127.0.0.1:7890&amp;quot; # 端口待定&#xA;git config --global https.proxy &amp;quot;https://127.0.0.1:7890&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;查看提交历史&#34;&gt;查看提交历史&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8b%e6%8f%90%e4%ba%a4%e5%8e%86%e5%8f%b2&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;git log&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;或以 &lt;code&gt;ascii&lt;/code&gt; 图形的方式展示树状分支结构:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows 下的现代 C/C&#43;&#43; 开发环境配置</title>
      <link>https://example.org/docs/vscode-cmake-with-msvc/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/vscode-cmake-with-msvc/</guid>
      <description>&lt;h1 id=&#34;windows-下的现代-cc-开发环境配置&#34;&gt;Windows 下的现代 C/C++ 开发环境配置&lt;a class=&#34;anchor&#34; href=&#34;#windows-%e4%b8%8b%e7%9a%84%e7%8e%b0%e4%bb%a3-cc-%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;首先应该确保电脑上有这些必需的软件:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CMake&lt;/li&gt;&#xA;&lt;li&gt;Ninja&lt;/li&gt;&#xA;&lt;li&gt;vcpkg&lt;/li&gt;&#xA;&lt;li&gt;MSVC 套件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;msvc-安装&#34;&gt;MSVC 安装&lt;a class=&#34;anchor&#34; href=&#34;#msvc-%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;可以使用 &lt;a href=&#34;https://visualstudio.microsoft.com/zh-hans/downloads/&#34;&gt;&lt;em&gt;Visual Studio 安装工具&lt;/em&gt;&lt;/a&gt; 针对性地安装 MSVC 套件而不必安装全套 Visual Studio .&lt;/p&gt;&#xA;&lt;p&gt;只需在下载的 Visual Studio Installer 中选择 &lt;strong&gt;单个组件 → 编译器、生成工具和运行时 → MSVC vXXX - VS 2022 C++ x64/x86 生成工具&lt;/strong&gt; 选项进行安装. 建议安装最新版本.&lt;/p&gt;&#xA;&lt;p&gt;MSVC 环境必须经过初始化才可以使用. 安装完成后会自动出现 &lt;em&gt;Developer Command Prompt for VS 20xx&lt;/em&gt; (即 &lt;em&gt;开发人员命令提示符&lt;/em&gt; ) 和 &lt;em&gt;Developer PowerShell for VS 20xx&lt;/em&gt; (即 &lt;em&gt;开发人员 PowerShell&lt;/em&gt; ), 这两个终端就是已经初始化的环境, 在这两个终端中可以直接调用编译器. 另外 Visual Studio 还提供了初始化脚本来初始化编译器环境.&lt;/p&gt;&#xA;&lt;h2 id=&#34;vcpkg-安装&#34;&gt;vcpkg 安装&lt;a class=&#34;anchor&#34; href=&#34;#vcpkg-%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;访问 vcpkg 的 GitHub 仓库以查看安装说明.&lt;/p&gt;</description>
    </item>
    <item>
      <title>在移动介质中安装操作系统</title>
      <link>https://example.org/docs/linux-to-go/</link>
      <pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/linux-to-go/</guid>
      <description>&lt;h1 id=&#34;在移动介质中安装操作系统&#34;&gt;在移动介质中安装操作系统&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e7%a7%bb%e5%8a%a8%e4%bb%8b%e8%b4%a8%e4%b8%ad%e5%ae%89%e8%a3%85%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;所需工具:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装了任意 linux 发行版的电脑&lt;/li&gt;&#xA;&lt;li&gt;此处使用安装了 debian 的 VMware 虚拟机&lt;/li&gt;&#xA;&lt;li&gt;系统安装光盘文件 (&lt;code&gt;.iso&lt;/code&gt; 文件)&lt;/li&gt;&#xA;&lt;li&gt;我选择的发行版是 debian&lt;/li&gt;&#xA;&lt;li&gt;容量足够的移动介质 (如 U 盘)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&lt;h2 id=&#34;1-检查移动介质-如-u-盘-的分区表类型&#34;&gt;1. 检查移动介质 (如 U 盘) 的分区表类型&lt;a class=&#34;anchor&#34; href=&#34;#1-%e6%a3%80%e6%9f%a5%e7%a7%bb%e5%8a%a8%e4%bb%8b%e8%b4%a8-%e5%a6%82-u-%e7%9b%98-%e7%9a%84%e5%88%86%e5%8c%ba%e8%a1%a8%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们计划使用更现代的 &lt;code&gt;UEFI&lt;/code&gt; 引导操作系统启动,&#xA;为了具有更好的兼容性, 移动介质的分区表类型应为 &lt;code&gt;GPT&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;因此第一步是将 &lt;code&gt;MBR&lt;/code&gt; 类型的移动介质转换为 &lt;code&gt;GPT&lt;/code&gt; 分区表类型.&#xA;假如你的介质已为 &lt;code&gt;GPT&lt;/code&gt;, 可以跳过此章.&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-检查分区表类型&#34;&gt;1.1. 检查分区表类型&lt;a class=&#34;anchor&#34; href=&#34;#11-%e6%a3%80%e6%9f%a5%e5%88%86%e5%8c%ba%e8%a1%a8%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;fdisk&lt;/code&gt; 命令检查介质:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# fdisk -l&#xA;Disk /dev/sdb: 15.24 GiB, 16358834176 bytes, 31950848 sectors&#xA;Disk model: SD/MMC&#xA;Units: sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;Disklabel type: dos&#xA;Disk identifier: 0x00109879&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;上面显示了在我的机器上返回的信息, 其中:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
