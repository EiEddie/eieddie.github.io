[{"id":0,"href":"/docs/calc-with-unit/","title":"带有单位的物理计算","section":"Docs","content":"带有单位的物理计算# Mathematica# Mathematica 中可以带单位计算; 同样, 可以获取任意物理常数, 并以任意精度进行计算.\n要使用物理常数, 首先使用 Quantity 函数获取它并保存在变量里, 接着就可以在运算中使用这一常数的带有单位的精确值. 例如\nh = Quantity[\u0026quot;PlanckConstant\u0026quot;] 获取了普朗克常量的值并保存在变量 h 中.\n如果想要知道该常数在国际单位制下的准确值, 可以使用函数 UnitConvert. 例如\nUnitConvert@Quantity[\u0026quot;PlanckConstant\u0026quot;] 将给出结果 $$\\frac{132521403}{200000000000000000000000000000000000000000} \\mathrm{kg ~ m^2 / s}$$要定义带有单位的变量, 依旧使用 Quantity, 只需如下所示\nQuantity[600*^6, \u0026quot;Hz\u0026quot;] (* 给出 600000000 Hz *) Quantity[1, \u0026quot;kg m/s^2\u0026quot;] (* 给出 1 kg m/s^2 *) 软件在解析单位时较慢, 但识别较为精确.\n还可以使用语法 Ctrl+= 输入, 这其实是自然语言输入, 可以替换函数 Quantity, 只需按下 Ctrl+= 后输入想要的常数或带单位量即可. 例如 600*^6Hz, 1 kg m/s^2, Planck Constant 等等, 都可被正常识别.\n要将带单位的运算结果约化为最简单的国际单位, 或是转化为想要的其他单位, 依旧使用 UnitConvert. 具体操作可以查看该函数的文档.\n在处理常数时, 其实软件也会将所需常数也视为一个单位来处理, 这样可以将两者通过同一套自然的方式统一起来.\nJulia# 一些简单的物理计算可以在 Julia 中完成, 物理常数与带单位的量通过包 Unitful 提供支持. 需要注意的是 Julia 只能完成数值计算, 无法进行符号计算.\n使用 using Unitful.DefaultSymbols 激活单位功能, 此时就可以为数值添加单位, 例如 1kg*m/s^2 给出结果 1 kg m s^-2 等等. 对于没有以变量形式给出的单位, 可以使用单位字符串 u\u0026quot;\u0026quot; 指定, 例如 1u\u0026quot;eV\u0026quot; 给出 1 电子伏特. 阅读 文档 以获取更多信息.\n单位同样也被注册为函数, 作为转换器, 使用目标单位可以将物理量转换为以该单位表示, 例如 J(1u\u0026quot;eV\u0026quot;) 与 1u\u0026quot;eV\u0026quot; |\u0026gt; J 都会将能量单位电子伏特的值转为按焦耳为单位 1.602176634e-19 J. 同样支持语法 u\u0026quot;eV\u0026quot;(1J) 或 1J |\u0026gt; u\u0026quot;eV\u0026quot;.\nUnitful 内置了许多带单位物理常量, 但是无法全部一次性加载到环境中, 必须显式 include. 可供使用的物理常数列举在 文档 中,\n"},{"id":1,"href":"/docs/commutative-lt/","title":"可交换的线性变换","section":"Docs","content":"可交换的线性变换# 这篇文章讨论可交换的线性变换, 即对于线性变换 \\(A\\), \\(B\\), 有 \\(AB = BA\\).\n引理# \\(f(A)\\) 与 \\(B\\) 可交换的充要条件是 \\(A\\), \\(B\\) 可交换.\n充要条件# 复数域上线性变换 \\(A\\), \\(B\\) 可交换的充要条件是: \u0026gt; \\(A\\) 的每个广义特征空间 \\(E_{\\lambda}\\) 都是 \\(B\\) 的不变子空间.\n其中广义特征空间 \\(E_{\\lambda} = \\{\\mathbf{v} ~ | ~ (A - \\lambda I)^m \\; \\mathbf{v} = \\mathbf{0}, m \\in \\mathbb{N}_+\\}\\). 线性空间 \\(V\\) 总是可以分解为其上某一线性变换的广义特征空间的直和.\n证明:\n充分性: 任取 \\(A\\) 在重数 \\(m\\) 的广义特征空间 \\(E_{\\lambda}\\), \\(\\forall \\mathbf{v} \\in E_{\\lambda}; B \\mathbf{v} \\in E_{\\lambda}\\). 于是 \\(B (A - \\lambda I)^m \\mathbf{v} = B \\; \\mathbf{0} = \\mathbf{0}\\), \\((A - \\lambda I)^m B \\mathbf{v} = (A - \\lambda I)^m (B \\mathbf{v}) = \\mathbf{0}\\). 注意到 \\((A - \\lambda I)^m\\) 是关于 \\(A\\) 的多项式, 由此可得 \\(E_{\\lambda}\\) 上 \\(A\\) 与 \\(B\\) 可交换.\n将复数域上向量空间 \\(V\\) 分解为广义特征空间的直和 \\(V = E_{\\lambda_1} \\oplus E_{\\lambda_2} \\oplus \\dots \\oplus E_{\\lambda_r}\\), 其中 \\(E_{\\lambda_i}\\) 是对应于特征值 \\(\\lambda_i\\) 的广义特征空间. 任取 \\(\\mathbf{u} \\in V\\), \\(\\mathbf{u} = \\sum_i k_i \\mathbf{v}_i\\), 其中 \\(\\mathbf{v}_i \\in E_{\\lambda_i}\\). 对于任意 \\(\\mathbf{v}_i\\) 都有 \\(A\\), \\(B\\) 可交换, 故对于其线性组合 \\(\\mathbf{u}\\) 也可交换.\n综上, \\(A\\), \\(B\\) 在 \\(V\\) 上可交换.\n必要性: 若 \\(A\\), \\(B\\) 可交换, 则对任意 \\(\\mathbf{v} \\in E_{\\lambda}\\), 都有 \\((A - \\lambda I)^m (B \\mathbf{v}) = B ((A - \\lambda I)^m \\mathbf{v}) = B \\; \\mathbf{0} = \\mathbf{0}\\). 故 \\(B \\mathbf{v} \\in E_{\\lambda}\\). 即 \\(E_{\\lambda}\\) 是 \\(B\\) 的不变子空间.\n"},{"id":2,"href":"/docs/dynamic-simulation-of-density-fluids/","title":"密度流体的动态模拟","section":"Docs","content":"密度流体的动态模拟# 我们将不可压缩流体的模拟分为两类, 一类聚焦于流体本身, 另一类则聚焦依托于流场的标量场. 前者称为体积流体, 如水与空气二相的模拟, 我们更关心流体本身的运动; 后者称为密度流体, 如充斥于密闭容器中的浊液的模拟, 我们关注的是溶质的物质的量密度这一标量. 需要注意的是这两个词仅为本篇文章的约定, 而非正式的学术用语.\n本文讲述了不可压缩密度流体的运动学模拟. 纵览符合这一条件的流场, 如附加温度场, 容质的密度场等, 其标量场都耦合于流体的速度场. 这是指标量会被流体输运, 例如温度的对流; 标量场同时可以反过来影响速度场, 例如渗透压导致的流体运动, 但我们一般不认为它会破坏流体的不可压缩性, 否则这将导致被求解方程的形式变得极端复杂.\n写出不可压缩流体的纳维 - 斯托克斯方程: $$\\nabla \\cdot \\mathbf{u} = 0$$ $$\\frac{\\mathrm{D} \\mathbf{u}}{\\mathrm{D} t} = -\\nabla \\frac{p}{\\rho} + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{a}$$ 前者是质量守恒定律对应的连续性方程在不可压缩, 即 \\(\\rho \\equiv \\mathrm{const}\\) 时的推论; 后者是牛顿第二定律. 其中 \\(\\nu\\) 是运动粘度, \\(\\nu := \\mu/\\rho\\), \\(\\mu\\) 是动力粘度. 流体力学中, 我们一般用 \\(\\mathbf{u}\\) 代表速度.\n后式中出现的随质导数, 或称物质导数 \\(\\frac{\\mathrm{D}}{\\mathrm{D} t} := \\frac{\\partial}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\). 这一式中前者表示欧拉导数; 后者表示拉格朗日导数, 即由于流体的运动带来的变化, 这个效应称为移流. 将其拆开可以写为 $$\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla \\frac{p}{\\rho} - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{a}$$接下来, 我们将首先讨论速度场的模拟, 这一过程中积累的经验可以被移用到标量场的模拟内. 必须注意: 本文将聚焦于视觉效果而非真实的物理过程. 本文主要参考 Stam 发表的论文1.\n速度场# 为了在计算机中模拟, 需要对空间进行离散化. 最显而易见的方式是网格法. 这一方法将空间划分为许多细密的网格, 每一格点都保存有这一位置的模拟量, 在这里是速度 \\(\\mathbf{u}\\). 当网格划分地足够细时, 我们认为系统的演化收敛于连续情况, 这是显然的.\n值得注意的是, 为了方便施予边界条件, 我们将网格靠外再扩充一层. 这一层并不属于网格的范围, 也不参与计算, 它被称为幽灵层; 而紧贴幽灵层的, 属于网格范围的最外层被称为边界. 对于我们希望观察的密闭容器, 微分方程的边界条件可以被简单地设置为: 幽灵层是边界的相反数. 这样便可保证边界的动能被幽灵层全部消耗, 不会有速度逸散出去. 在下面的每一步后, 都必须重新设置幽灵层的值, 以保证边界条件始终满足.\n算子分裂# 速度场的模拟将被分为几个步骤顺序进行, 这是由于时间离散化导致的妥协, 但我们仍可以认为当时间步取得足够小时, 最终的效果与理想的连续时间演化相差甚微.\n首先进行的是将源, 即外加的力或加速度添加到速度场中; 其次是扩散 (diffuse), 这使流体表现出粘性; 接着是平流 (advect), 这使速度随流体运动而运输, 形成速度流. 每一步都必须在设定的边界条件下进行; 并且都要进行投影 (project), 以保证流体不可压缩.\n我们之所以这样做, 是因为以下两点.\n第一, 方程中 \\(-\\nabla \\frac{p}{\\rho}\\) 项的作用是保证流体的不可压缩性, 即 \\(\\nabla \\cdot \\mathbf{u} = 0\\). 此处的进一步论述可以查看后文 投影 一节.\n第二, 方程可以被拆分为以下形式: $$\\mathbf{u}^*(t+\\mathrm{d}t) = \\mathbf{u}(t) + \\mathbf{a} \\; \\mathrm{d}t + \\nu \\nabla^2 \\mathbf{u} \\; \\mathrm{d}t - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} \\; \\mathrm{d}t$$ 上式中 \\(\\mathbf{u}(t)\\) 是 \\(t\\) 时刻的速度; \\(\\mathbf{u}^*(t+\\mathrm{d}t)\\) 是 \\(t + \\mathrm{d}t\\) 时刻的速度, \\((\\cdot)^*\\) 代表此时的速度因为方程中缺少 \\(-\\nabla \\frac{p}{\\rho}\\) 一项而导致散度不为 \\(0\\), 即不可压缩性被破坏. \\(\\mathbf{u}\\) 代表在 \\(t \\sim t+\\mathrm{d}t\\) 内某个时间的速度, 在式中出现多次时每次对应的时间都不同. 由拉格朗日中值定理, 这一时间必然存在以使上式成立.\n定义 \\(\\mathbf{u}^{\\mathrm{f}*} := \\mathbf{u}(t) + \\mathbf{a} \\; \\mathrm{d}t\\) 为加入源后的速度场, 注意此时仍然不满足不可压缩性;\n\\(\\mathbf{u}^{\\mathrm{d}*} := \\mathbf{u}^{\\mathrm{f}*} + \\nu \\nabla^2 \\mathbf{u} \\; \\mathrm{d}t\\) 为扩散后的速度场;\n\\(\\mathbf{u}^* = \\mathbf{u}^{\\mathrm{v}*} := \\mathbf{u}^{\\mathrm{d}*} - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} \\; \\mathrm{d}t\\) 为平流后的速度场.\n此时便可以明显看出顺序进行几个步骤. 为了保证物理实际, 对每个得到的中间步骤 (除加入源后的) 进行投影, 最后得到的场 \\(\\mathbf{u}\\) 便是推进了时间 \\(\\mathrm{d}t\\) 的不可压缩的速度. 用图表示为 $$\\mathbf{u}(t) \\rightarrow \\mathbf{u}^{\\mathrm{f}*} \\rightarrow \\mathbf{u}^{\\mathrm{d}*} \\rightarrow \\mathbf{u}^{\\mathrm{d}} \\rightarrow (\\mathbf{u}^{*} = \\mathbf{u}^{\\mathrm{v}*}) \\rightarrow \\mathbf{u}(t+\\mathrm{d}t)$$一个被回避的问题是我们只说明了每一个步骤中使用的 \\(\\mathbf{u}\\) 的存在性, 而没有给出其具体取值. Stam 的指导是使用前一步计算出的速度. 这一指导的动机在于始终避免用具有散度的不正常速度进行计算, 同时保证速度的实时性. 下面的章节将展示具体的计算过程.\n上面的方法被称为算子分裂. 它将耦合的复杂方程拆分为几个简单便于求解的方程, 降低了处理难度. 值得注意的是扩散与对流的顺序似乎是任意的, 但只要考虑到扩散过程会将速度平滑化, 有助于避免出现尖锐的速度区, 就会知道将其放置于更靠前的位置可以改善后续步骤的数值稳定性与精度, 因此这一顺序更加合理.\n扩散# 扩散对应的方程为 $$\\frac{\\partial \\mathbf{u}}{\\partial t} = \\nu \\nabla^2 \\mathbf{u}$$ 将其写为离散时间形式 $$\\mathbf{u}^{\\mathrm{d}*}(t+\\Delta t) = \\mathbf{u}(t) + (\\nu \\nabla^2 \\mathbf{u}(t)) \\Delta t$$较为困难的是将 Laplace 算子 \\(\\nabla^2\\) 进行空间的离散化. 在平面直角坐标系中, 有 \\(\\nabla^2 = \\partial_x^2 + \\partial_y^2\\); 并且 $$\\frac{\\partial \\mathbf{u}(\\mathbf{r})}{\\partial x} = \\frac{\\mathbf{u}(\\mathbf{r}+\\mathrm{d}\\mathbf{x}) - \\mathbf{u}(\\mathbf{r})}{\\mathrm{d}x}$$ $$\\frac{\\partial^2 \\mathbf{u}(\\mathbf{r})}{\\partial x^2} = \\frac{(\\mathbf{u}(\\mathbf{r}+\\mathrm{d}\\mathbf{x}) - \\mathbf{u}(\\mathbf{r})) - (\\mathbf{u}(\\mathbf{r}) - \\mathbf{u}(\\mathbf{r}-\\mathrm{d}\\mathbf{x}))} {\\mathrm{d}x^2}$$ 对 \\(y\\) 求偏导同理. 整理并离散化可得 $$\\begin{align} \\nabla^2 \\mathbf{u}(\\mathbf{r}) = \u0026 \\frac{\\mathbf{u}(\\mathbf{r}+\\Delta \\mathbf{x}) + \\mathbf{u}(\\mathbf{r}-\\Delta \\mathbf{x}) - 2 \\mathbf{u}(\\mathbf{r})}{\\Delta x^2} \\\\ \u0026 + \\frac{\\mathbf{u}(\\mathbf{r}+\\Delta \\mathbf{y}) + \\mathbf{u}(\\mathbf{r}-\\Delta \\mathbf{y}) - 2 \\mathbf{u}(\\mathbf{r})}{\\Delta y^2} \\end{align}$$ 为了计算方便, 我们要求每个格子都是正方形. 设其边长为 \\(l\\), 则 $$\\begin{align} \\nabla^2 \\mathbf{u} = \u0026 \\frac{\\mathbf{u}(x+\\Delta x) + \\mathbf{u}(x-\\Delta x) - 2 \\mathbf{u}}{l^2} \\\\ \u0026 + \\frac{\\mathbf{u}(y+\\Delta y) + \\mathbf{u}(y-\\Delta y) - 2 \\mathbf{u}}{l^2} \\\\ = \u0026 \\frac{\\mathbf{u}(x+\\Delta x) + \\mathbf{u}(x-\\Delta x) + \\mathbf{u}(y+\\Delta y) + \\mathbf{u}(y-\\Delta y) - 4 \\mathbf{u}}{l^2} \\end{align}$$ 这样一来, \\(\\nabla^2\\) 只与当前位置格子, 以及与这一格子直接相邻的 4 格的速度, 他们整体呈十字形分布. 如果要求更高精度, 可以将四个角点也纳入考虑, 但对于我们需要的流体模拟来说上述 5 个点已经足够. 我们将四个邻点之和记作 \\(\\sum_\\mathrm{nbr} \\mathbf{u} := \\mathbf{u}(x+\\Delta x) + \\mathbf{u}(x-\\Delta x) + \\mathbf{u}(y+\\Delta y) + \\mathbf{u}(y-\\Delta y)\\).\n将我们上面求得的 Laplace 算子代入方程, 得到 $$\\mathbf{u}^{\\mathrm{d}*}(t+\\Delta t) - \\mathbf{u}(t) = \\nu \\Delta t \\; \\nabla^2 \\mathbf{u}(\\tau)$$ 其中 \\(\\tau \\in [t, t+\\Delta t]\\). 选择更靠后的时间更有利于保证系统保持最新, 若选择 \\(\\tau = t+\\Delta t\\) 则有 $$\\mathbf{u}^{\\mathrm{d}*} - \\mathbf{u} = \\nu \\Delta t \\; \\nabla^2 \\mathbf{u}^{\\mathrm{d}*}$$ 将上面计算得到的离散 Laplace 算子代入, 得 $$\\begin{align} \\mathbf{u}^{\\mathrm{d}*} - \\mathbf{u} \u0026= \\frac{\\nu \\Delta t}{l^2} \\; (\\sum_{\\mathrm{nbr}} \\mathbf{u}^{\\mathrm{d}*} - 4 \\mathbf{u}^{\\mathrm{d}*}) \\\\ \\Leftrightarrow (1 + 4k) \\mathbf{u}^{\\mathrm{d}*} \u0026= \\mathbf{u} + k \\sum_{\\mathrm{nbr}} \\mathbf{u}^{\\mathrm{d}*} \\\\ \\Leftrightarrow \\mathbf{u}^{\\mathrm{d}*} \u0026= \\frac{\\mathbf{u} + k \\sum_{\\mathrm{nbr}} \\mathbf{u}^{\\mathrm{d}*}}{1 + 4k} \\end{align}$$ 其中 \\(k = \\frac{\\nu \\Delta t}{l^2}\\).\n上式给出了一种使用逐格遍历网格来求解扩散方程的方法, 称为 Gauss\u0026ndash;Seidel 迭代法. 为了提高精度, 通常要按上式迭代数次. 注意, 左侧为迭代结果, 右侧为对原始网格与结果缓冲区的操作. 这一迭代法需要逐格计算, 每次对单个格点的计算依赖于前几步计算, 这一点可以从右侧的求和看出. 这一特性保证了计算时始终能够使用最新的信息, 提高了收敛速度; 但也导致了算法不易并行化.\n扩散前, 需要设置合适的边界条件; 扩散过程结束后, 需要对 \\(\\mathbf{u}^{\\mathrm{d}*}\\) 进行投影得到 \\(\\mathbf{u}^{\\mathrm{d}}\\), 以消除速度场的散度, 保证流体不可压.\n平流# 平流对应的方程为 $$\\frac{\\partial \\mathbf{u}}{\\partial t} = - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u}$$求解这一方程可以使用朴素的欧拉法, 即计算每个微小时间段内的演进, 但是这一方法在速度较大或时间步长过长时数值不稳定. 为了解决这一问题, 我们使用 半 Lagrangian 法 来求解方程.\n半 Lagrangian 法基于这样一个事实:\n对于依赖位置与时间的连续函数 \\(\\phi(\\mathbf{r}, t)\\), 当 \\(\\frac{\\partial \\phi}{\\partial t} = (\\mathbf{v} \\cdot \\nabla) \\phi\\), 则始终有 \\(\\phi(\\mathbf{r} + \\mathrm{d}\\mathbf{r}, t) = \\phi(\\mathbf{r}, t + \\mathrm{d}t)\\), 其中 \\(\\mathrm{d}\\mathbf{r} = \\mathbf{v} \\mathrm{d}t\\).\n下面我们证明这一定理.\n$$\\phi(\\mathbf{r}, t + \\mathrm{d}t) = \\phi(\\mathbf{r}, t) + \\frac{\\partial}{\\partial t} \\phi \\; \\mathrm{d}t$$ $$\\begin{align} \\phi(\\mathbf{r} + \\mathrm{d}\\mathbf{r}, t) \u0026= \\phi(\\mathbf{r}, t) + \\frac{\\partial}{\\partial \\mathbf{r}} \\phi \\cdot \\mathrm{d}\\mathbf{r} \\\\ \u0026= \\phi(\\mathbf{r}, t) + \\frac{\\partial}{\\partial \\mathbf{r}} \\phi \\cdot \\mathbf{v} \\mathrm{d}t \\\\ \u0026= \\phi(\\mathbf{r}, t) + \\mathbf{v} \\cdot \\frac{\\partial}{\\partial \\mathbf{r}} \\phi \\; \\mathrm{d}t \\\\ \u0026= \\phi(\\mathbf{r}, t) + (\\mathbf{v} \\cdot \\nabla) \\phi \\; \\mathrm{d}t \\end{align}$$ 于是 \\(\\phi(\\mathbf{r} + \\mathrm{d}\\mathbf{r}, t) = \\phi(\\mathbf{r}, t + \\mathrm{d}t)\\).\n将这一定理应用到 \\(\\mathbf{u}\\) 的两个分量上, 并令 \\(\\mathbf{v} := -\\mathbf{u}\\), 可以得到 $$\\mathbf{u}^{\\mathrm{v}*} = \\mathbf{u}(\\mathbf{r}, t + \\mathrm{d}t) = \\mathbf{u}(\\mathbf{r} - \\mathbf{u} \\mathrm{d}t, t)$$ 于是求 \\(\\mathrm{d}t\\) 时间之后的速度场等价于将每个点向后平移 \\(\\mathbf{u}\\mathrm{d}t\\) 得到的速度场. 这样取得的结果面对较长时间步长时仍然具有较好的数值稳定性.\n需要注意的是, 格点 \\(\\mathbf{r}\\) 总是处于有序的整数位置, 因此总是可以准确获知其对应的速度, 因为速度被存在相应位置的变量中. 但对格点 \\(\\mathbf{r}\\) 计算 \\(\\mathbf{r}' := \\mathbf{r} - \\mathbf{u} \\mathrm{d}t\\) 得到的值却总是不会出现在整数位置处, 因此如何获取其速度是我们面对的挑战. 一个简单的方法是对包围 \\(\\mathbf{r}'\\) 的四点所对应的速度进行插值, 以此结果作为该点的速度. 所使用的插值方法可以是双线性插值或其他. 这一方法的重大弊端是取得的速度并非精确值, 它总是具有较大的误差, 这是由于插值而引入的. 当我们将平流方法应用在要求严格守恒 (物质的量守恒或质量守恒) 的组分上时, 这一组分的守恒要求便被破坏, 只能通过其他方法来弥补.\n同上, 平流前需要设置合适的边界条件; 平流后需要对 \\(\\mathbf{u}^{*} = \\mathbf{u}^{\\mathrm{v}*}\\) 进行投影得到 \\(\\mathbf{u}\\), 以消除速度场的散度, 保证流体不可压.\n投影# 对纳维-斯托克斯方程两侧求散度, 可得 $$\\frac{\\partial}{\\partial t} \\nabla \\cdot \\mathbf{u} = -\\nabla^2 \\frac{p}{\\rho} - \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla) \\mathbf{u}) + \\nu \\nabla^2 (\\nabla \\cdot \\mathbf{u}) + \\nabla \\cdot \\mathbf{a}$$ 我们的目标为使 \\(\\nabla \\cdot \\mathbf{u} = 0\\), 代入上式得 $$0 = -\\rho^{-1} \\nabla^2 p - \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla) \\mathbf{u}) + \\nabla \\cdot \\mathbf{a}$$ 由亥姆霍兹分解定理, \\(\\mathbf{a} = \\nabla \\phi + \\nabla \\times \\mathbf{A}\\), 代入后因为 \\(\\nabla \\cdot \\nabla \\times \\mathbf{A} = 0\\), 将前一项并入 \\(p\\) 中, 得 $$\\nabla^2 p = -\\rho \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla) \\mathbf{u}) + \\rho \\nabla^2 \\phi$$ 于是得到了关于压强的泊松方程. 这一压强的结果是使方程速度无散的必要条件. 可以证明当边界条件与初值条件合适时, 这也是充分条件.\n在具体实践中, 我们希望将一个具有散度的场 \\(\\mathbf{u}^*\\) 转为无散场 \\(\\mathbf{u}\\). 使用亥姆霍兹分解定理, 将 \\(\\mathbf{u}^*\\) 分解为标量势 \\(\\phi\\) 与矢量势 \\(\\mathbf{A}\\): \\(\\mathbf{u}^* = \\nabla \\phi + \\nabla \\times \\mathbf{A}\\), 此时两侧取散度得 $$\\begin{align} \\nabla \\cdot \\mathbf{u}^* \u0026= \\nabla^2 \\phi + \\nabla \\cdot \\nabla \\times \\mathbf{A} \\\\ \u0026= \\nabla^2 \\phi \\end{align}$$ 因此投影的重点是找到原场 \\(\\mathbf{u}^*\\) 的标势, 将其梯度从原场中剔除, 只留下矢势的旋度场 \\(\\mathbf{u} = \\nabla \\times \\mathbf{A} = \\mathbf{u}^* - \\nabla \\phi\\). 这时 \\(\\mathbf{u}\\) 是无散的. 标势 \\(\\phi\\) 可通过求解泊松方程取得 $$\\nabla^2 \\phi = \\nabla \\cdot \\mathbf{u}^*$$标量场# 一个与速度场耦合的标量场主要用于产生我们要的视觉效果, 如温度或物质浓度等. 此量随速度场迁移, 并在一定程度上改变速度分布. 以温度场为例简要说明以上两点.\n标量场的方程与一般情况下描述此量的偏微分方程极为相似, 例如无源的热传导方程 $$\\frac{\\partial T}{\\partial t} = \\kappa \\nabla^2 T$$ 这同时也是描述物质扩散的微分方程. 在具有外部的速度场时, 只需将欧拉导数替换为物质导数即可 $$\\begin{align} \u0026 \\frac{\\mathrm{D} T}{\\mathrm{D} t} = \\kappa \\nabla^2 T \\\\ =\u0026 (\\mathbf{u} \\cdot \\nabla) T + \\frac{\\partial T}{\\partial t} \u0026 \\end{align}$$求解这一方程的过程与我们上面介绍的方法完全一致. 对于其他参量, 若能写出微分方程, 也可按照上述方式改写为与速度场耦合的形式并求解.\nJ. Stam, \u0026ldquo;Real-Time Fluid Dynamics for Games\u0026rdquo;, Proceedings of the Game Developers Conference, Mar 2003\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":3,"href":"/docs/async-serial/","title":"异步非阻塞串口数据接收","section":"Docs","content":"异步非阻塞串口数据接收# 异步?# 异步 (asynchronous) 编程是一种并发的编程模式, 可以有效节省 CPU 阻塞等待 I/O 事件造成的时间浪费, 借以提高性能.\n在这里也简单介绍一下 并行 (parallel) 与 并发 (concurrent) 的区别. 并发是指多个任务可以被同时运行的现象; 但需要注意的是, 并发在某一时刻可能并不一定有多个任务在运行. 但是并行是严格的多线程工作模式, 在某一时刻有多个任务在同时工作. 于是很容易看出, 并行也被包含在并发之中.\n异步的核心在于一个字 \u0026ldquo;等\u0026rdquo;. 简而言之, 异步编程好似去食堂窗口买饭, 当你告诉他你要点的餐以后, 不是一定要在窗口前等着, 而是可以去做点别的事情, 比如买瓶饮料什么的, 直到老板通知你取餐, 这就是一次异步事件. 在编程时我们调用一个异步 API, 若它不能立刻返回结果, 那么也不会阻塞等待, 而是立刻向后执行; 直到获取到结果再通知我们进行处理.\n不同的语言有各色的异步支持, JavaScript 和 Rust 的异步模型都很有代表性. JavaScript 中, 异步函数可以返回一个 Promise 对象, 其名字形象地说明了它的功能: 我承诺完成你要的操作; 潜台词则是我保证 将来 会完成你要的操作, 不一定是立刻做到. Rust 的 Future 机制则更为直白: 你的任务我将来会完成的.\n非多线程的异步程序的本质是 CPU 的 时分复用, 它用划分时间片交替运行各项任务来模拟同时运行每项任务. 必须指出, 有些语言实际上使用多线程实现的异步, 在这种情况下可以实现真正的并行, 即每个时刻多项任务同时被运行. 于是很容易推断, 若 CPU 本来就没有空闲时间, 那么非多线程的异步也并不能提高效率. 这也是为什么异步大多都被用于 I/O 操作, 因为可以有效利用好 I/O 事件中因为等待而空闲的 CPU 时间. 若是 CPU 密集型的工作, 例如科学计算等, 使用异步模型反而会因为时间片切换而损失性能. 这种情况更适合用多线程的方法提高效率.\n异步模型的通知机制, 也就是当任务完成时如何处理结果, 是各种异步模型要解决的核心问题, 不同的解决方案也催生出不同的异步模型. 最为简单的方法自然是传递一个回调函数, 当任务完成时调用回调来处理结果. 这也被称为 事件驱动 (Event Driven) 模型.\nlibuv 使用# libuv 是 c 语言编写的强调异步 I/O 的多平台支持库. 我们的目标是使用它编写异步的接收串口数据程序.\n我们以异步打开文件来举例:\nuv_fs_t open_req; void on_open(uv_fs_t *req) { if (req-\u0026gt;result \u0026gt;= 0) { // do something... } } int main() { const char* fname = \u0026#34;/...\u0026#34;; uv_fs_open(uv_default_loop(), \u0026amp;open_req, fname, O_RDONLY, 0, on_open); uv_run(uv_default_loop(), UV_RUN_DEFAULT); uv_fs_req_cleanup(\u0026amp;open_req); return 0; }"},{"id":4,"href":"/docs/ballistics/","title":"抛体运动弹道解算","section":"Docs","content":"抛体运动弹道解算# 模型# 本文考虑使用 线性阻力 模型. 事实上, 在空气中运动的阻力应该由 二次阻力 描述, 关于二者的对比将在 后文 给出.\n之所以使用线性阻力, 是因为如此一来物体的运动微分方程\n$$m \\dot{\\mathbf{v}} = -k \\mathbf{v} - m g \\hat{\\mathbf{j}}$$有封闭解. 进一步令 \\(\\mu := \\frac{k}{m}\\), 上式化为\n$$\\dot{\\mathbf{v}} = -\\mu \\mathbf{v} - g \\hat{\\mathbf{j}}$$容易解得\n$$\\mathbf{v} = \\mathrm{e}^{-\\mu t} \\mathbf{v}_0 - \\mu^{-1} (1-\\mathrm{e}^{-\\mu t}) g \\hat{\\mathbf{j}}$$积分得\n$$ \\mathbf{r} = \\mathbf{r}_0 - \\mu^{-1} (1-\\mathrm{e}^{-\\mu t}) \\mathbf{v}_0 - \\mu^{-2} (\\mu t + \\mathrm{e}^{-\\mu t} - 1) g \\, \\hat{\\mathbf{j}} $$这就是线性阻力情况下的运动方程. 它也可以很轻松地分解为两个方向来运算.\n与二次阻力的对比# 当速度较大 (\\(\\sim 20 ~ \\mathrm{m/s}\\)) 时, 弹丸在空气中运动的 雷诺数 很大, 并不适用于线性阻力. 但是在上升过程中, 速度逐渐下降, 雷诺数也逐渐变小, 于是在上升阶段用线性阻力模型的误差也不是很大.\n下面的图展示了无阻力, 线性阻力与二次阻力在初速 \\(20 ~ \\mathrm{m/s}\\), 射角 \\(60^\\circ\\) 时的运动轨迹, 可以看到上升阶段两条阻力曲线都十分接近, 随着下降时速度越来越快才逐渐分离.\n显然两种阻力的系数量纲不同, 于是其值也必然不同. 找到合适的线性阻力系数就成为逼近真实情况的重点之一. 在流体中的二次阻力可以用 \\(f = \\frac{1}{2} \\rho v^2 C_d S\\) 计算, 其中 \\(\\rho\\) 为流体密度; \\(C_d\\) 为阻力系数, 由实验得出; \\(S\\) 为参考面积. 我们希望由此推出线性阻力的系数, 使二者轨迹相差无几.\n我们令 \\(\\kappa = \\frac{1}{2} \\frac{\\rho C_d S}{m}\\), 于是二次阻力情况下加速度 \\(\\mathbf{a}_f = -\\kappa |\\mathbf{v}| \\mathbf{v}\\); 对比线性阻力情况下 \\(\\mathbf{a}_f = -\\mu \\mathbf{v}\\), 可以看出重点是找到一个合适的 \\(\\mu\\), 使得其在 \\(\\mathbf{v}\\) 不断变化的时候仍有 \\(\\mu \\sim \\kappa |\\mathbf{v}|\\).\n一种朴素的想法是使 \\(\\mu\\) 等于 \\(\\kappa |\\mathbf{v}|\\) 的均值. 也就是令\n$$\\mu = \\kappa \\frac{\\int_{0}^{t} |\\mathbf{v}| ~ \\mathrm{d} t}{t}$$注意到二次阻力模型下运动方程\n$$\\begin{align*} \\dot{v}_x \u0026= -\\kappa |\\mathbf{v}| ~ v_x \\\\ \\dot{v}_y \u0026= -\\kappa |\\mathbf{v}| ~ v_y - g \\end{align*}$$蕴含一个 \\(|\\mathbf{v}|\\). 只考虑 \\(x\\) 方向, 可得\n$$\\begin{align*} \\int_{0}^{t} \\kappa |\\mathbf{v}| ~ \\mathrm{d} t \u0026= -\\int_{0}^{t} \\frac{\\dot{v}_x}{v_x} ~ \\mathrm{d} t \\\\ \u0026= -\\int_{v_{0x}}^{v_x} \\frac{\\mathrm{d} v_x}{v_x} \\\\ \u0026= \\ln{\\frac{v_{0x}}{v_x}} \\end{align*}$$于是 \\(\\mu = t^{-1} \\ln{(v_{0x}/v_x)}\\).\n可以通过欧拉法取得 \\(v_x\\) 的数值解, 对于给定的 \\(t\\), 可以认为在这段时间内 ( \\(0 \\sim t\\) ) 使用 \\(\\mu\\) 的线性阻力模型与使用 \\(\\kappa\\) 的二次阻力模型取得的轨迹相差无几.\n但是应该注意, 随着 \\(t\\) 的增大, \\(v_x\\) 逐渐减小趋近于 \\(0\\), 因此 \\(t\\) 不宜取得太大. 实际应用中, 可以用射角 \\(45^\\circ\\), 在上升到最高点之前的时间段计算的 \\(\\mu\\) 来作为通用结果使用.\n上图展示了参数为 \\(\\kappa\\) 的二次阻力模型与计算得到的使用 \\(\\mu\\) 的线性阻力模型, 以及无阻力模型在 \\(y\\) 方向上的差值. 射角 \\(60^\\circ\\), 初速 \\(20 ~ \\mathrm{m/s}\\). 可以看出线性阻力模型在 \\(x \u003e 15 ~ \\mathrm{m}\\) 时才有显著的偏差.\n轨迹方程# 将运动方程中 \\(t\\) 消去, 即为轨迹方程.\n我们先将初速度 \\(\\mathbf{v}_0\\) 分解为 \\(v_0 ~ (\\cos{\\theta}, \\sin{\\theta})\\), 而后在 \\(x\\) 方向解出 \\(t\\):\n$$t = \\mu^{-1} \\ln{\\frac{v_0 \\cos{\\theta}}{v_0 \\cos{\\theta} - \\mu x}}$$之后将其代入 \\(y\\) 方向, 化简得\n$$ y - \\frac{g}{\\mu^2 v_0} (\\mu x \\sec{\\theta} - v_0 \\ln{\\frac{v_0}{v_0 - \\mu x \\sec{\\theta}}}) - x \\tan{\\theta} = 0 $$轨迹上的点 \\((x, y)\\) 都应满足于上面的方程, 这便是轨迹方程.\n在初速 \\(v_0\\) 确定的情况下, 这是关于 \\(\\theta\\) 的一个方程. 想要得到给定轨道上一点 \\((x, y)\\) 的情况下 \\(\\theta\\) 的值, 只需解这个方程就好. 可以用诸如 牛顿法 等数值方法来获得相当精确的解.\n确定初值# 牛顿法等迭代方法是初值敏感的, 初值的选取决定了迭代的次数与最终精度. 对于有多个根的函数, 初值还决定了最终结果是哪一个根.\n显而易见, 对于一般的目标, 抛体运动总有两条可达的轨迹. 一条是在上升时到达, 一条则在下降时. 我们总是更喜欢上升时到达的情况, 因为这样运动的时间短, 且可以使用线性阻力模型更精确地模拟, 误差更小. 这就对初值的选取提出了要求.\n令轨迹方程左边为目标函数 \\(f(\\theta)\\), 规定定义域为 \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\) 的子集, 作图观察 (曲线; \\(\\mu = 0.01\\), \\(v = 20 ~ \\mathrm{m/s}\\), \\((x, y) = (5, 0.5)\\)):\n显然有两个解. 并且容易想到上升时到达的轨迹, 射角小于下降时到达的, 于是左边一根即为所求射角.\n对目标函数求导并令其等于 \\(0\\), 可以得到其极值. 容易证明, 其极值至多一个, 且为最小值. 这里直接给出目标函数的最小值点:\n$$\\theta = \\arctan{\\frac{v_0^2}{g x}} - \\arctan{\\frac{\\mu x}{\\sqrt{v_0^2 + x^2 ((g / v_0)^2 - \\mu^2)}}}$$假如我们将初值选在最小值点的左侧, 那么迭代求出的根就是较小的一根. 进一步我们想到, 相较于 区间最左端的点 或 最小值点左邻域内的点, 不妨取这两点连线, 即图上斜线与 \\(x\\) 轴的交点, 这样更接近于根. 如此一来还可以避开上述两点附近数值不稳定的区域.\n排除不可达点# 给定的目标点并不总是有可达的抛体轨迹. 若是能在计算前将其排除, 便可避免再在繁杂的计算中消耗时间. 需要注意的是, 排除过程也需耗时, 且对于每个输入数据都需要计算, 因此需要平衡前期排除与正式计算间的平衡, 以优化耗时.\n射角范围# 实际应用中, 射角几乎总是不能达到 \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\), 于是若目标点与原点的夹角大于射角的最大值, 那么显然不能到达.\n尤其注意, 当夹角小于射角最小值时, 仍然有可能到达, 因为物体在重力作用下会下坠.\n包络线# 另外, 若是无阻力模型都到达不了的点, 那么线性乃至于二次阻力模型也一定不可达. 因此可以使用抛物线的包络线来检查, 若是在包络线以外 (以上) 的点, 一定是不可达点.\n对于无阻力的抛体运动, 可以直接写出其运动方程\n$$\\begin{align*} x \u0026= v_0 t \\cos{\\theta} \\\\ y \u0026= v_0 t \\sin{\\theta} - \\frac{1}{2} g t^2 \\end{align*}$$两式联立消去 \\(t\\), 得到\n$$\\begin{align*} y \u0026= v_0 \\sin{\\theta} ~ \\frac{x}{v_0 \\cos{\\theta}} - \\frac{1}{2} g (\\frac{x}{v_0 \\cos{\\theta}})^2 \\\\ \u0026= x \\tan{\\theta} - \\frac{g x^2}{2 v_0^2} \\sec^2{\\theta} \\\\ \u0026= x \\tan{\\theta} - \\frac{g x^2}{2 v_0^2} (1 + \\tan^2{\\theta}) \\end{align*}$$以 \\(\\theta\\) 为未知数, 若是其恰有一解, 则上述轨迹方程处于临界状态; 若目标点再稍抬高则不可达. 注意到上述方程为关于 \\(\\tan{\\theta}\\) 的二次方程, 且 \\(\\tan{x}\\) 在 \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\) 内为双射, 于是令\n$$\\begin{align*} \\Delta \u0026= x^2 - 4 \\frac{g x^2}{2 v_0^2} (\\frac{g x^2}{2 v_0^2} + y) \\\\ \u0026= 0 \\end{align*}$$即\n$$y = -\\frac{g}{2 v_0^2} x^2 + \\frac{v_0^2}{2 g}$$这便是抛体运动的包络线方程. 若点 \\((x, y)\\) 在方程之上, 则不可到达.\n其他# 在实际计算中对于根号与分式要特别注意, 防止出现超出定义域的情况. 可以在计算前简要判断一下, 确保各函数的自变量都在其定义域内.\n代码实现# 代码 [Web] 由 julia 编写. Benchmark 显示其性能十分卓越:\n#@benchmark θ([5.,0.5], 20., 9.8, 0.1, (-pi/6,pi/3)) BenchmarkTools.Trial: 10000 samples with 223 evaluations per sample. Range (min … max): 331.390 ns … 19.150 μs ┊ GC (min … max): 0.00% … 97.41% Time (median): 335.426 ns ┊ GC (median): 0.00% Time (mean ± σ): 363.941 ns ± 333.661 ns ┊ GC (mean ± σ): 1.97% ± 2.52% Memory estimate: 80 bytes, allocs estimate: 2. 可以看到计算一次的时间仅为 \\(335.426 ~ \\mathrm{ns}\\) (中位数), 占用 \\(80\\) 字节空间.\n"},{"id":5,"href":"/docs/conventional-commits/","title":"约定式提交","section":"Docs","content":"约定式提交# 约定式提交规定了一套编写 git 提交信息的规范, 方便写出清晰, 突出重点, 分类明确的提交信息, 尤其在团队协作时十分必要.\n本文中介绍的规范有别于标准的 约定式提交规范, 在一些方面做了让步, 方便新手编写.\n概述# 一个提交应由以下几部分组成\n\u0026lt;类型\u0026gt;: \u0026lt;描述\u0026gt; [正文] 类型 字段见下文 类型 一章.\n描述 应当是对提交的一句话总结, 力求简洁清楚, 重点分明. 对于描述部分的详细解释, 可以写在 正文 部分. 正文并非必要, 最好只在提交十分复杂, 或是包含了多个不同修改时编写.\n要使用约定式提交, 需要对提交本身进行规范:\n拆分不同文件的修改.\n例如文档的修改与源代码的修改应该分开提交; 配置文件, 测试代码, 编译脚本等等都应该尽量分离. 可以阅读 类型 一章, 了解哪些修改应该单独提交. 拆分提交的方法在 这里. 尽量更细致地进行提交, 一次提交一个功能的修改.\n也就是说, 不要一股脑将全部文件的修改送入版本库. 例如在某一源代码文件中, 既修改了数据的展示方式, 又修改了某 API 的实现, 那它们应该被拆分为两个提交. 避免过于细小的提交.\n某些微小又不重要的提交, 例如文档中某个拼写或代码某处符号后的空格, 可以等后面修改此文件时一并提交. 描述与正文部分尽量使用 markdown 语言标记. 特别地, 提到文件名时应使用反引号 ` 括起. 在正文中陈列多条修改时使用 markdown 的列表语法.\n当修改过多以至于无法细致提交时, 可以在描述处写 多次提交, 转而在正文处陈列. 但是强烈建议涉及业务功能的修改不要这样, 以免淹没在不重要的琐碎提交中.\n当目标未完成时, 在 \u0026lt;类型\u0026gt; 之后, 冒号 : 之前添加一个问号 ? 来注明. 例如要为用户页面添加一个新的按钮, 只完成了前端的 UI 绘制, 但后端并没有写相应业务代码. 此时若必须提交, 那么就要添加一个未完成标签 ?. 不能编译或运行的代码必须添加未完成标签. 原则上, 上述修改不允许提交, 未完成标签是与实际情况的无奈妥协. 一个最佳实践是: 将未完成的工作都提交到开发分支, 如 dev; 等目标全部完成后, 将这些提交全部 压缩 为一个提交, 再合并到主线. 不要将未完成的修改合并进去.\n在分支 合并 (merge) 时可以不遵守约定式提交, 但是也要具有统一的规范.\n相较于标准规范, 取消了关于 提交范围 (scope) 和强制说明 破坏性提交 的部分; 增加了未完成标签.\n类型# feat: 新功能, 新特性. fix: 修改 bug. perf: 在不影响代码内部行为的前提下, 更改代码, 对程序性能进行优化. refactor: 代码重构. 在不影响代码内部行为, 功能下的代码修改. docs: 文档修改. style: 代码格式修改. 例如添加分号, 修改或添加空格, 更改缩进格式等. test: 测试的新增, 修改. build: 影响项目构建或依赖项修改. revert: 恢复上一次提交. ci: 持续集成相关文件修改. chore: 其他修改, 即不在上述类型中的修改. 例如 .gitignore 的修改. 更多规范# 每个提交都必须使用类型字段前缀, 它由一个名词构成, 诸如 feat 或 fix, 其后接必要的冒号（英文半角）和空格. 当一个提交为应用或类库实现了新功能时, 必须使用 feat 类型. 当一个提交为应用修复了 bug 时, 必须使用 fix 类型. 在简短描述之后, 可以编写较长的提交正文, 为代码变更提供额外的上下文信息. 正文必须起始于描述字段结束的一个空行后. 提交的正文内容自由编写, 并使用空行分隔不同段落. 所有符号都建议使用半角符号. 可选的破坏性提交说明# 破坏性提交是指不能与修改前代码或 API 相兼容的修改, 例如删除或重命名 API, 修改函数的参数类型或返回类型等等. 若进行了破坏性提交, 可在正文后空一行编写破坏性提交说明. 说明以 BREAKING CHANGE: 起头, 空一格写内容. 若内容有多条, 可换行按列表语法陈列. 破坏性提交也可以加注标签: 在 \u0026lt;类型\u0026gt; 之后, 冒号 : 之前添加一个叹号 ! 来注明.\n若仓库从一开始就执意没有说明破坏性提交, 则后续都不要添加; 直到进入稳定发布版本再添加.\n参考# 约定式提交规范\n"}]