[{"id":0,"href":"/docs/hugo-with-math/","title":"为 Hugo 添加数学支持","section":"Docs","content":"为 Hugo 添加数学支持# 本文将聚焦于为 hugo 生成的静态站点添加数学公式渲染支持, 我们将使用 MathJax, 因为相比 KaTeX, 它支持更多 \\(\\LaTeX\\) 语法, 例如 align 对齐环境等.\n关于 hugo 的 联合文件系统 与 注入点 相关内容, 请看 这篇文章.\n首先在 layouts/partials 中新建 mathjax.html, 用于作为组件被调用.\n\u0026lt;!-- layouts/partials/mathjax.html --\u0026gt; {{ if or .Params.math .Site.Params.math }} \u0026lt;script\u0026gt; window.MathJax = { tex: { inlineMath: [[\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;]] }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;] } }; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; {{ end }}这段代码引入了 MathJax, 并配置渲染块标识符, 内联公式为 \\\\(...\\\\), 行间公式为 \\$\\$...\\$\\$. 不使用 $...$ 与 \\\\[...\\\\] 的理由将在后文叙述.\n被 {{ }} 括起来的部分为 模板, 它将作为占位符被解析器用正文替换, 也可作为判断语句. 文件中的模板是一个判断, 意味仅当文章元数据启用了 math 或站点配置中启用了 math, 才会引入 MathJax 渲染. 为了全局启用, 可以在站点配置文件 hugo.toml 中声明\n[params] math = true接下来需要将上述文件引入主题, 我们使用 book 主题提供的 \u0026lt;head\u0026gt; 末尾处的注入点 layouts/partials/docs/inject/head.html. 将下面的内容放入此文件\n\u0026lt;!-- layouts/partials/docs/inject/head.html --\u0026gt; {{ partial \u0026#34;mathjax.html\u0026#34; . }}这段模板会把上面编写的 partial/mathjax.html 引入. 于是最终 MathJax 相关代码将会出现在页面 html \u0026lt;head\u0026gt; 标签结尾处.\n此时理论上就可以使用了, 但是会出现一些 bug, 例如公式块内如果出现 Markdown 语法, 例如 \\$\\$A_n*B_m\\$\\$ 中出现了一个 Markdown 强调块 _..._, 此时 hugo 将会先按 Markdown 解析, 将 _..._ 替换成特定的样式, 如此一来公式就不能被正确渲染了. 为了避免这种问题, 我们启用 Markdown 解析时的 透传 功能1, 在 hugo.toml 中配置\n[markup.goldmark.extensions.passthrough] enable = true delimiters = { block = [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;]], inline = [[\u0026#39;\\(\u0026#39;, \u0026#39;\\)\u0026#39;]] }这会要求 Markdown 解析器将上述标识符中包裹的内容不做任何处理, 直接移交渲染流水线的下一层, 即 MathJax 处理, 于是公式便可正常渲染.\n但事情没有这么简单. 我们习惯使用 $...$ 来编写行内公式, 为何这里不启用对 $ 的支持呢? 因为日常行文中 $ 是一个常见的符号, 而且在很多编程语言中作为关键符号存在. 如果我们启用了 $...$ 支持, 由于 Hugo 的透传机制是先于 Markdown 解析运作的, 即使是包裹在 ` 内的 $ 块也会被渲染为公式. 另外, 在 hugo 中转义 $ 需要双转义 \\\\\\\\$, 因为渲染流水线有 Goldmark, 即 hugo 的 Markdown 解析器, 和 MathJax 两层, \\\\\\\\$ 经过 Goldmark 后变为 \\\\$, 而后 MathJax 才知道这不是公式定界符, 从而将其格式化为正常的美元符号 $.\n综合各方面考虑, 我们将额外添加一个环节, 先使用 pandoc 将 $ 定界的内联公式块 $...$ 转为 \\\\(...\\\\), 这样既能在平时使用更熟悉的语法写作, 又避免了纠缠不清的 $. 另外, 还有一些补全 Goldmark 漏洞的规则, 例如 \\$\\$...\\$\\$ 会被识别为行间公式, 于是我们在编写 pandoc 过滤器时将内联代码块内的双美元符号 \\$\\$ 进行转义 \\\\$\\\\$; 内联代码块中如果出现这种模式 \\\\\\\\$ 就会被识别为一个转义的反斜杠与一个美元符号 \\\\$, 因此干脆将所有的 \\\\ 都转义.\n下面是能够达成我们目标的 lua 过滤器, 用于被 pandoc 使用\n-- math-delimiter.lua function Math(el) if el.mathtype == \u0026#34;InlineMath\u0026#34; then -- $...$ -\u0026gt; \\(...\\) return pandoc.RawInline(\u0026#34;markdown\u0026#34;, \u0026#34;\\\\(\u0026#34; .. el.text .. \u0026#34;\\\\)\u0026#34;) end return nil end function Code(el) local s = el.text -- \\ -\u0026gt; \\\\ s = s:gsub(\u0026#34;\\\\\u0026#34;, \u0026#34;\\\\\\\\\u0026#34;) -- $$ -\u0026gt; \\$\\$ s = s:gsub(\u0026#34;%$%$\u0026#34;, \u0026#34;\\\\$\\\\$\u0026#34;) el.text = s return el end并且应当以下面的方式使用\npandoc -s in.md -t markdown --lua-filter=math-delimiter.lua -o out.md不要忘记 -s/--standalone=true 参数, 否则你的元数据将被吞掉.\nHugo+Mathjax的正确姿势\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":1,"href":"/docs/static-site-with-hugo/","title":"使用 Hugo 搭建静态站点","section":"Docs","content":"使用 Hugo 搭建静态站点# 在本地知识库软件编写文章在很多时候已经足够满足我参考的需要, 但若遇上呈给别人台鉴的情况, 终归不够方便. 另外文章虽在 GitHub 保存, 但其缺失对元数据的整理功能, 对于必要的 Markdown 拓展语法支持也不佳, 更关键的是, 其使用的 KaTeX 数学引擎较为简陋, 难以招架文章中出现的连篇累牍的公式. 无奈之下, 恐怕建立一个阅览站点成了唯一可行的选择.\n主题选择# 我希望站点整体上是静态的, 没有过分到眼花缭乱的小动画与动态效果, 主题风格简洁严肃, 就像一本书或一页纸一样, 仅用来供人阅览而不喧宾夺主. 最后我选择的主题是 book, 效果和它的名字一样沉静. 然而不得不说的是, 或许我下面的要求过分了点, 没有让我完全满意的主题, book 也不例外. 于是只好对它进行一番改造了.\n格式化文档# 首先要做的就是保证文章格式能够被 hugo 正确识别, 因此一方面要保证元数据的正确, 另一方面要确保正文中没有不被支持的 Markdown 语法. 我们的目的是文章能够在 Obsidian 与 hugo 两端都能被正确渲染. 日后发布文章或博客的工作流将是使用 Obsidian 编写, 并在本地查看审阅, 待满意后使用 hugo 打包并推送服务器上线.\nhugo 依赖于 title 而非文件名显示文章标题, 使用 date 标记文章修改时间, 并且会读取 tags 来分类文章. 为了避免流程出错, 与减轻心智负担, 可以在 Obsidian 中安装 Linter 插件, 它可以自动格式化文档, 并重排与补全元数据. 将 Linter 的 标题别名 部分设置打开, 便可以自动从第一个 # 标签处获取文章标题, 并填写到元数据区, 另外还会将标题名作为别名写入. 如果以前在使用 datetime 字段储存文档修改或编写日期, 强烈建议改为 date 字段, 因为这一键名在 Obsidian 与 hugo 两端都受到良好的支持.\n建议将 Linter 的 确保中日韩文与英文数字之间有一个空格 选项中的引号 \u0026quot; ' 删除, 否则中文引号之后也会加入一个空格, 有时会破坏排版.\nbook 或其他主题提供了一些元数据字段来控制其行为, 例如 bookToC 将会控制是否默认展开该文章的目录. 关于 book 的控制字段可以查看其 文档.\nObsidian 中有些非标准的拓展 Markdown 语法, 例如 Wiki 链接 等, 都建议关闭, 因为难以被 hugo 与其他平台的标准化 Markdown 渲染器支持.\n但对于一些特别有益的拓展语法, 例如 admonitions, 我们希望尽可能地使其可用. 幸运地是 book 主题本身就支持这一语法, 因此我们并不需要大费周章配置. 但如果是不支持此语法的主题, 可以额外安装一个 hugo-admonitions 主题, 并将其置于主要主题之前, 这样便可覆盖原主题来提供 admonitions 支持, 如下\ntheme = [\u0026quot;hugo-admonitions\u0026quot;, \u0026quot;book\u0026quot;] 一定注意 hugo-admonitions 应该放置于主要主题 \u0026ndash; 这里是 book\u0026ndash; 前面, 因为主题的使用是从前到后的.\n另外, 这就是一个 admonition.\n定制字体# hugo 管理站点的方式是 联合文件系统. 简单地说, 站点的各项文件配置都是分层的, 放置在上层的文件将会覆盖下层. 目录层级如下所示.\n\u0026lt;root\u0026gt; \u0026lt;root\u0026gt;/themes/\u0026lt;theme-a\u0026gt; ... 因此, layouts/baseof.html 将会覆盖 themes/book/layouts/baseof.html, 其余目录和文件皆是同理.\n我希望站点正文字体使用衬线体, 以此增强内容的出版物质感, 更有 \u0026ldquo;文章感\u0026rdquo;. book 主题提供了设置字体的 定制文件 assets/_fonts.scss, 我们修改它即可更换字体.\n将下面的内容填入此文件中\n/* assets/_fonts.scss */ @import url(\u0026#39;https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400;600\u0026amp;family=Inter:wght@300;400;600\u0026amp;family=JetBrains+Mono:wght@400;700\u0026amp;display=swap\u0026#39;); :root { --paper-font-body: \u0026#34;Source Serif 4\u0026#34;, \u0026#34;Noto Serif SC\u0026#34;, \u0026#34;serif\u0026#34;; --paper-font-ui: \u0026#34;Inter\u0026#34;, \u0026#34;system-ui\u0026#34;, \u0026#34;-apple-system\u0026#34;, \u0026#34;Segoe UI\u0026#34;, \u0026#34;Helvetica Neue\u0026#34;, \u0026#34;Arial\u0026#34;; --paper-font-mono: \u0026#34;Iosevka\u0026#34;, \u0026#34;JetBrains Mono\u0026#34;, \u0026#34;ui-monospace\u0026#34;, \u0026#34;SFMono-Regular\u0026#34;, \u0026#34;Menlo\u0026#34;, \u0026#34;monospace\u0026#34;; } html, body { font-family: var(--paper-font-body); } h1, h2, h3, h4, h5, h6 { font-family: var(--paper-font-ui); } code, pre { font-family: var(--paper-font-mono); font-size: 0.95em; }这将设置正文字体为衬线体, 标题为无衬线体, 代码块为等宽无衬线体.\n添加文章修改时间# book 中同样也有修改时间的原生支持, 但是需要与 GitHub 仓库进行集成, 这是一个比较苛刻的条件, 我无法做到, 因此我将手动实现一个放置在左下角的文章修改时间. 如果你对 book 中提供的修改时间显示有兴趣, 可以去看 站点配置 中 enableGitInfo 与 BookLastChangeLink 两个字段. 只有这两者都被正确配置, 时间显示才会开启.\n一般来说, 几乎每个主题都会预留 注入点 (inject). 它们是主题中空的占位文件, 等待着被来自上层的文件覆盖. 它们已经被主题中的各项文件引用, 但因为是空的, 不会有任何效果, 当它们被覆盖后, 新文件的内容就会出现在站点中. 这是一种非侵入式的个性化手段. book 主题中提供的注入点可以在 GitHub 自述文件 中找到.\n我将利用 book 在页面内容之后的注入点 layouts/partials/docs/inject/content-after.html 来手动实现一个修改时间显示, 它会读取文档元数据 date 字段来格式化为相应的日期显示.\n\u0026lt;!-- layouts/partials/docs/inject/content-after.html --\u0026gt; {{ $date := .Lastmod | default .Date }} {{ if not .IsHome }} {{ with $date }} \u0026lt;div class=\u0026#34;flex flex-wrap justify-between\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex align-center text-sm text-muted\u0026#34;\u0026gt; \u0026lt;!--img src=\u0026#34;{{ partial \u0026#34;docs/icon\u0026#34; \u0026#34;calendar\u0026#34; }}\u0026#34; class=\u0026#34;book-icon\u0026#34; alt=\u0026#34;{{ partial \u0026#34;docs/text/i18n\u0026#34; \u0026#34;Calendar\u0026#34; }}\u0026#34; /--\u0026gt; \u0026lt;span class=\u0026#34;overline\u0026#34; style=\u0026#34;font-style:italic;\u0026#34;\u0026gt;Last updated: {{ .Format (default \u0026#34;January 2, 2006\u0026#34; $.Site.Params.BookDateFormat) }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ end }}以及其配套的样式 overline\n/* assets/_custom.scss */ .overline { display: inline-block; position: relative; display: block; margin-top: 16px; } /* 伪元素作为横线 */ .overline::before { /* background-color: currentColor; */ background: var(--gray-200); content: \u0026#34;\u0026#34;; position: absolute; left: 0; top: 0; width:100%; height: 2px; z-index: 2; pointer-events: none; transform: translateY(-200%); }这段代码将从文档元数据字段 date 中读取日期, 并按站点设置 BookDateFormat 中规定的样式格式化. 最后的显示效果为左下角的 Last updated: January 2, 2006, 斜体, 上方覆盖一条与文字等长的灰色分割线.\n数学支持# 关于为 hugo 添加 MathJax 支持, 请看 这篇文章.\n最终配置文件# 最终使用的 hugo.toml 配置文件如下所示\nbaseURL = \u0026#39;https://example.org/\u0026#39; languageCode = \u0026#39;zh-cn\u0026#39; title = \u0026#34;EiEddie\u0026#39;s Mind\u0026#34; # theme = [\u0026#34;hugo-admonitions\u0026#34;, \u0026#34;book\u0026#34;] theme = [\u0026#34;book\u0026#34;] [params] math = true BookTheme = \u0026#39;auto\u0026#39; BookDateFormat = \u0026#39;January 2, 2006\u0026#39; [markup.tableOfContents] startLevel = 2 endLevel = 4 ordered = false [markup.goldmark.renderer] unsafe = true [markup.goldmark.extensions.passthrough] enable = true delimiters = { block = [[\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;]], inline = [[\u0026#39;\\(\u0026#39;, \u0026#39;\\)\u0026#39;]] }"},{"id":2,"href":"/docs/calc-with-unit/","title":"带有单位的物理计算","section":"Docs","content":"带有单位的物理计算# Mathematica# Mathematica 中可以带单位计算; 同样, 可以获取任意物理常数, 并以任意精度进行计算.\n要使用物理常数, 首先使用 Quantity 函数获取它并保存在变量里, 接着就可以在运算中使用这一常数的带有单位的精确值. 例如\nh = Quantity[\u0026quot;PlanckConstant\u0026quot;] 获取了普朗克常量的值并保存在变量 h 中.\n如果想要知道该常数在国际单位制下的准确值, 可以使用函数 UnitConvert. 例如\nUnitConvert@Quantity[\u0026quot;PlanckConstant\u0026quot;] 将给出结果 $$\\frac{132521403}{200000000000000000000000000000000000000000} \\mathrm{kg ~ m^2 / s}$$要定义带有单位的变量, 依旧使用 Quantity, 只需如下所示\nQuantity[600*^6, \u0026quot;Hz\u0026quot;] (* 给出 600000000 Hz *) Quantity[1, \u0026quot;kg m/s^2\u0026quot;] (* 给出 1 kg m/s^2 *) 软件在解析单位时较慢, 但识别较为精确.\n还可以使用语法 Ctrl+= 输入, 这其实是自然语言输入, 可以替换函数 Quantity, 只需按下 Ctrl+= 后输入想要的常数或带单位量即可. 例如 600*^6Hz, 1 kg m/s^2, Planck Constant 等等, 都可被正常识别.\n要将带单位的运算结果约化为最简单的国际单位, 或是转化为想要的其他单位, 依旧使用 UnitConvert. 具体操作可以查看该函数的文档.\n在处理常数时, 其实软件也会将所需常数也视为一个单位来处理, 这样可以将两者通过同一套自然的方式统一起来.\nJulia# 一些简单的物理计算可以在 Julia 中完成, 物理常数与带单位的量通过包 Unitful 提供支持. 需要注意的是 Julia 只能完成数值计算, 无法进行符号计算.\n使用 using Unitful.DefaultSymbols 激活单位功能, 此时就可以为数值添加单位, 例如 1kg*m/s^2 给出结果 1 kg m s^-2 等等. 对于没有以变量形式给出的单位, 可以使用单位字符串 u\u0026quot;\u0026quot; 指定, 例如 1u\u0026quot;eV\u0026quot; 给出 1 电子伏特. 阅读 文档 以获取更多信息.\n单位同样也被注册为函数, 作为转换器, 使用目标单位可以将物理量转换为以该单位表示, 例如 J(1u\u0026quot;eV\u0026quot;) 与 1u\u0026quot;eV\u0026quot; |\u0026gt; J 都会将能量单位电子伏特的值转为按焦耳为单位 1.602176634e-19 J. 同样支持语法 u\u0026quot;eV\u0026quot;(1J) 或 1J |\u0026gt; u\u0026quot;eV\u0026quot;.\nUnitful 内置了许多带单位物理常量, 但是无法全部一次性加载到环境中, 必须显式 include. 可供使用的物理常数列举在 文档 中,\n"},{"id":3,"href":"/docs/qm-angular-momentum/","title":"量子力学中的角动量","section":"Docs","content":"量子力学中的角动量# 在量子力学中, 除了我们能够想象的沿轨道运动和绕自转轴转动的公转角动量与自转角动量, 这两者分别称为轨道角动量与自旋角动量, 对于任意 \\(\\mathbf{J}\\), 只要其分量 \\(J_\\alpha\\) 满足 $$ [J_\\alpha, J_\\beta] = \\mathrm{i} \\hbar \\, \\varepsilon_{\\alpha \\beta \\gamma} \\, J_\\gamma $$ 则我们称它为一种角动量. 角动量都具有以下对易关系 $$[\\mathbf{J}^2, J_\\alpha] = 0$$ 这说明角动量的值与某一个角动量分量可以被同时测得, 一般我们选择 \\(z\\) 轴分量 \\(J_z\\).\n我们将角动量值 \\(\\mathbf{J}^2\\) 与 \\(z\\) 轴角动量 \\(J_z\\) 的共同本征态记作 \\(\\ket{\\lambda, m}\\), 其中 \\(\\mathbf{J}^2 \\ket{\\lambda, m} = \\lambda \\hbar^2 \\ket{\\lambda, m}\\), \\(J_z \\ket{\\lambda, m} = m \\hbar \\ket{\\lambda, m}\\).\n阶梯算符# 定义两个重要的阶梯算符 \\(J_\\pm := J_x \\pm \\mathrm{i} J_y\\). 这两个算符不是厄米算符, 因此它不能对应一种可观测的力学量. 我们可以发现它的对易关系 $$[J_+, J_-] = 2\\hbar \\, J_z$$ $$[J_z, J_\\pm] = \\pm \\hbar \\, J_\\pm$$ $$[\\mathbf{J}^2, J_\\pm] = 0$$\\(J_\\pm\\) 的物理意义与其本征态及其本征值可以通过下面的方法得到. 注意到 $$\\begin{align} J_z (J_\\pm \\ket{\\lambda, m}) \u0026= ([J_z, J_\\pm] + J_\\pm J_z) \\ket{\\lambda, m} \\\\ \u0026= (\\pm \\hbar J_\\pm + J_\\pm J_z) \\ket{\\lambda, m} \\\\ \u0026= \\pm \\hbar \\, J_\\pm \\ket{\\lambda, m} + m \\hbar \\, J_\\pm \\ket{\\lambda, m} \\\\ \u0026= (m \\pm 1) \\hbar \\, (J_\\pm \\ket{\\lambda, m}) \\end{align}$$ 于是 \\(J_\\pm \\ket{\\lambda, m}\\) 仍然是 \\(J_z\\) 的本征态, 但是被 \\(J_\\pm\\) 作用后本征值发生了改变, 即 $$J_\\pm \\ket{\\lambda, m} = k_\\pm \\ket{\\lambda, m \\pm 1}$$ 系数 \\(k_\\pm\\) 目前还不能确定. 就像在台阶上运动一样, 有上有下, 这就是为什么这两个算符得名阶梯算符.\n容易证明, \\(J_\\pm \\ket{\\lambda, m}\\) 仍然是 \\(\\mathbf{J}^2\\) 的本征态, 于是这一态矢依然为 \\(J_z\\) 与 \\(\\mathbf{J}^2\\) 的共同本征态.\n现在我们尝试确定系数 \\(k_\\pm\\) 的值. 首先, 一个重要的等式如下 $$\\begin{align} J_\\pm J_\\mp \u0026= (J_x \\pm \\mathrm{i} J_y) (J_x \\mp \\mathrm{i} J_y) \\\\ \u0026= J_x^2 + J_y^2 \\mp \\mathrm{i} [J_x, J_y] \\\\ \u0026= \\mathbf{J}^2 - J_z^2 \\pm \\hbar J_z \\end{align}$$ 或者是其另一种写法 $$\\mathbf{J}^2 = J_\\pm J_\\mp + J_z^2 \\mp \\hbar J_z$$ 这将角动量的值与升降算符和 \\(J_z\\) 联系起来. 你也可以用这个等式证明上面给出的 \\(J_+\\) 与 \\(J_-\\) 的对易关系. 我们计算 \\(J_\\pm \\ket{\\lambda, m}\\) 的模 $$\\begin{align} ||J_\\pm \\ket{\\lambda, m}||^2 \u0026= \\bra{\\lambda, m} J_\\pm^\\dagger J_\\pm \\ket{\\lambda, m} \\\\ \u0026= \\bra{\\lambda, m} J_\\mp J_\\pm \\ket{\\lambda, m} \\\\ \u0026= \\bra{\\lambda, m} \\mathbf{J}^2 - J_z^2 \\mp \\hbar J_z \\ket{\\lambda, m} \\\\ \u0026= (\\lambda - m^2 \\mp m) \\hbar^2 \\end{align}$$ 同时还要保证 \\(\\ket{\\lambda, m \\pm 1} = k_\\pm^{-1} J_\\pm \\ket{\\lambda, m}\\) 仍然是归一化的, 正如我们对每个态矢都要求的那样, 从这一点得到 $$\\begin{align} ||k_\\pm||^2 \u0026= ||J_\\pm \\ket{\\lambda, m}||^2 \\\\ \u0026= (\\lambda - m^2 \\mp m) \\hbar^2 \\end{align}$$ 此处有一个重要的问题: 是否能容忍 \\(k_\\pm\\) 中存在相因子? 或者说, \\(k_\\pm\\) 是一个复数, 还是一个实数? 我们将会发现, 引入这一相因子不会有任何好处, 只会带来无穷的麻烦. 于是我们希望 \\(k_\\pm\\) 是一个单纯的实数. 这样一来 \\(k_\\pm = \\sqrt{\\lambda - m^2 \\mp m} \\hbar \\ge 0\\), $$J_\\pm \\ket{\\lambda, m} = \\sqrt{\\lambda - m (m \\pm 1)} \\, \\hbar \\, \\ket{\\lambda, m \\pm 1}$$共同本征态# 现在我们确定 \\(\\mathbf{J}^2\\) 与 \\(J_z\\) 的共同本征态 \\(\\ket{\\lambda, m}\\) 中参数 \\(\\lambda\\) 与 \\(m\\) 的取值与意义.\n无论何时, 我们知道 \\(\\mathbf{J}^2 \\ge J_z^2\\), 将其作用到态矢上得到 $$\\lambda \\ge m^2$$ 这启示我们, \\(m\\) 必须有界, 记其最大值为 \\(\\overline{m}\\), 最小值 \\(\\underline{m}\\); 目前没有证据表明 \\(m\\) 必须为正, 事实上我们现在可以猜测到的约束仅有 \\(\\overline{m} = -\\underline{m} \\ge 0\\), 这一猜想将在后文被证明是正确的. 重申一下, 我们设的 \\(\\overline{m}\\) 是 \\(J_z\\) 能够存在的最大本征值; \\(\\underline{m}\\) 则是最小本征值. 需要注意的是我们的确可以知道 \\(\\lambda \\ge 0\\), 考虑到当 \\(\\lambda = 0\\) 时量子将不具有角动量 \\(\\mathbf{J}^2 \\ket{0, m} = 0\\), 我们认为这是无意义的, 因此规定 \\(\\lambda \u003e 0\\).\n考虑一个 \\(m\\) 处于最高的态 \\(\\ket{\\lambda, \\overline{m}}\\), 对其使用升算符 \\(J_+\\) 将不能使 \\(m\\) 再继续升高, 因为其已经在能到达的最大值. 我们假设 \\(J_+ \\ket{\\lambda, \\overline{m}}\\) 处于一个与众不同的态 \\(\\ket{\\psi} := J_+ \\ket{\\lambda, \\overline{m}}\\), 其有 \\(L_z \\ket{\\psi} = (\\overline{m}+1) \\ket{\\psi}\\), 这一等式的推导与上文完全相同. 可以发现这与我们要求的 \\(\\overline{m}\\) 为最大本征值矛盾, 因此只能有 \\(\\ket{\\psi} = 0\\). 于是 $$\\begin{align} 0 \u0026= \\bra{\\lambda, \\overline{m}} J_- J_+ \\ket{\\lambda, \\overline{m}} \\\\ \u0026= \\bra{\\lambda, \\overline{m}} \\mathbf{J}^2 - J_z^2 - \\hbar J_z \\ket{\\lambda, \\overline{m}} \\\\ \u0026= (\\lambda - \\overline{m}^2 - \\overline{m}) \\hbar^2 \\\\ \u0026\\Leftrightarrow \\lambda = (\\overline{m} + 1) \\overline{m} \\end{align}$$ 同理, 对 \\(\\underline{m}\\) 讨论, 可以得到类似的结论 $$\\lambda = (\\underline{m} - 1) \\underline{m}$$ 比较这两个式子, 可以得到 $$\\underline{m} = -\\overline{m}$$ 与我们的猜测一致.\n\\(m\\) 的取值为 \\(\\underline{m} \\le m \\le \\overline{m}\\), 从最低态 \\(\\ket{\\lambda, \\underline{m}}\\) 出发, 经过 \\(n\\) 次升算符 \\(L_+\\) 的作用, 态矢将来到最高态 \\(\\ket{\\lambda, \\overline{m}}\\). 这意味着 \\(\\underline{m} + n = \\overline{m}\\), 即 \\(\\overline{m} = \\frac{n}{2}\\), 其中 \\(n \\in \\mathbb{N}_+\\), \\(\\overline{m}\\) 的取值可以是整数或半奇数.\n我们采取一种新的量子数表征总角动量 \\(\\mathbf{J}^2\\) 的本征值 \\(l (l+1) = \\lambda\\), 此时本征态为 \\(\\ket{l, m}\\) $$\\mathbf{J}^2 \\ket{l, m} = l (l+1) \\hbar^2 \\ket{l, m}$$ 其中 \\(l\\) 的取值为 \\(l \u003e 0\\), 且 \\(l\\) 可以是半奇数或整数. 对于给定的 \\(l\\), 允许的 \\(m\\) 值为 \\(-l, -l + 1, \\cdots, l - 1, l\\), 共 \\(2l + 1\\) 个.\n算符的矩阵元# 下面来求各种角动量算符的矩阵元.\n已知 \\(l\\), \\(m\\) 不同的态矢是正交的, \\(\\ket{l, m}\\) 是归一化的. 于是 \\(\\mathbf{J}^2\\) 和 \\(J_z\\) 的矩阵元为 $$\\bra{l', m'} \\mathbf{J}^2 \\ket{l, m} = l (l+1) \\hbar^2 \\delta_{l l'} \\delta_{m m'}$$ $$\\bra{l', m'} J_z \\ket{l, m} = m \\hbar \\, \\delta_{l l'} \\delta_{m m'}$$\\(J_\\pm\\) 作用在基矢上的表达式我们已经得到, 从这一点可以推导出 \\(J_\\pm\\) 的矩阵元为 $$\\begin{align} \\bra{l', m'} J_\\pm \\ket{l, m} \u0026= \\sqrt{\\lambda - m (m \\pm 1)} \\hbar \\braket{l', m' | l, m \\pm 1} \\\\ \u0026= \\sqrt{l (l+1) - m (m \\pm 1)} \\hbar \\, \\delta_{l l'} \\delta_{m \\pm 1, m'} \\\\ \u0026= \\sqrt{(l \\mp m) (l \\pm m + 1)} \\hbar \\, \\delta_{l l'} \\delta_{m \\pm 1, m'} \\end{align}$$从 \\(J_\\pm = J_x \\pm \\mathrm{i} J_y\\) 可以得出 \\(J_x = \\frac{1}{2} (J_+ + J_-)\\), \\(J_y = \\frac{1}{2 \\mathrm{i}} (J_+ - J_-)\\). 由此可得 $$\\bra{l', m'} J_x \\ket{l, m} = \\frac{\\hbar}{2} (\\sqrt{(l - m) (l + m + 1)} \\, \\delta_{l l'} \\delta_{m + 1, m'} + \\sqrt{(l + m) (l - m + 1)} \\, \\delta_{l l'} \\delta_{m - 1, m'})$$ $$\\bra{l', m'} J_y \\ket{l, m} = \\frac{\\hbar}{2 \\mathrm{i}} (\\sqrt{(l - m) (l + m + 1)} \\, \\delta_{l l'} \\delta_{m + 1, m'} - \\sqrt{(l + m) (l - m + 1)} \\, \\delta_{l l'} \\delta_{m - 1, m'})$$ 非零的矩阵元可以写作 $$\\bra{l, m+1} J_x \\ket{l, m} = \\frac{\\hbar}{2} \\sqrt{(l - m) (l + m + 1)}$$ $$\\bra{l, m-1} J_x \\ket{l, m} = \\frac{\\hbar}{2} \\sqrt{(l + m) (l - m + 1)}$$ $$\\bra{l, m+1} J_y \\ket{l, m} = \\frac{\\hbar}{2 \\mathrm{i}} \\sqrt{(l - m) (l + m + 1)}$$ $$\\bra{l, m-1} J_y \\ket{l, m} = -\\frac{\\hbar}{2 \\mathrm{i}} \\sqrt{(l + m) (l - m + 1)}$$下面是一段计算不同角动量算符矩阵形式的代码, 使用 Mathematica 编写.\n(*\\mathbf{J}^2*) JJ[l_] := Table[l (l + 1) \\[HBar] DiscreteDelta[m-m\\[Prime]], {m\\[Prime], l, -l, -1}, {m, l, -l, -1}] (*J_z*) Jz[l_] := Table[m \\[HBar] DiscreteDelta[m-m\\[Prime]], {m\\[Prime], l, -l, -1}, {m, l, -l, -1}] (*J_x*) Jx[l_] := \\[HBar]/2 Table[Sqrt[(l - m) (l + m + 1)] DiscreteDelta[m+1-m\\[Prime]] + Sqrt[(l + m) (l - m + 1)] DiscreteDelta[m-1-m\\[Prime]], {m\\[Prime], l, -l, -1}, {m, l, -l, -1}] (*J_y*) Jy[l_] := \\[HBar]/(2 I) Table[Sqrt[(l - m) (l + m + 1)] DiscreteDelta[m+1-m\\[Prime]] - Sqrt[(l + m) (l - m + 1)] DiscreteDelta[m-1-m\\[Prime]], {m\\[Prime], l, -l, -1}, {m, l, -l, -1}]我们计算 \\(l=\\frac{1}{2}\\) 时的 \\(J_x\\), \\(J_y\\), \\(J_z\\) 矩阵作为例子. 结果为 \\(J_\\alpha = \\frac{\\hbar}{2} \\sigma_\\alpha\\), \\(\\alpha = x, y, z\\) $$\\sigma_x = \\begin{pmatrix} \u0026 1 \\\\ 1 \u0026 \\\\ \\end{pmatrix}$$ $$\\sigma_y = \\begin{pmatrix} \u0026 -\\mathrm{i} \\\\ \\mathrm{i} \u0026 \\\\ \\end{pmatrix}$$ $$\\sigma_z = \\begin{pmatrix} 1 \u0026 \\\\ \u0026 -1 \\\\ \\end{pmatrix}$$ 这就是著名的泡利自旋矩阵.\n轨道角动量# 我们所熟知的经典力学中的角动量 \\(\\mathbf{L} = \\mathbf{r} \\times \\mathbf{p}\\) 也有相应的量子对应, 只需将动量 \\(\\mathbf{p}\\) 改写为算符形式 $$ \\mathbf{L} = - \\mathrm{i} \\hbar \\, \\mathbf{r} \\times \\nabla$$ 这被称之为轨道角动量. 按不怎么量子的说法, 这是粒子, 如电子在轨道上公转的角动量. 当然, 我们知道, 电子既没有确定的位置, 也并不像地球绕太阳那样公转.\n球坐标系下的算符# 对于角动量而言, 我们总是习惯于使用球坐标系进行讨论, 因为它天然具有良好的对称性. 在球坐标系下, 有 $$\\nabla = \\hat{\\mathbf{r}} \\, \\partial_r + \\frac{1}{r} \\nabla_\\Omega$$ 其中 \\(\\nabla_\\Omega\\) 是角向算子, 有 $$\\nabla_\\Omega = \\hat{\\mathbf{\\theta}} \\, \\partial_\\theta + \\hat{\\mathbf{\\phi}} \\, \\frac{1}{\\sin{\\theta}} \\partial_\\phi$$于是有 $$\\begin{align} \\mathbf{L} \u0026= - \\mathrm{i} \\hbar \\, \\mathbf{r} \\times \\nabla \\\\ \u0026= - \\mathrm{i} \\hbar \\, r \\hat{\\mathbf{r}} \\times (\\hat{\\mathbf{r}} \\, \\partial_r + \\frac{1}{r} \\nabla_\\Omega) \\\\ \u0026= - \\mathrm{i} \\hbar \\, \\hat{\\mathbf{r}} \\times \\nabla_\\Omega \\\\ \u0026= - \\mathrm{i} \\hbar \\, (\\hat{\\mathbf{\\phi}} \\, \\partial_\\theta - \\hat{\\mathbf{\\theta}} \\frac{1}{\\sin{\\theta}} \\partial_\\phi) \\end{align}$$ 将 \\(\\hat{\\mathbf{\\theta}}\\) 与 \\(\\hat{\\mathbf{\\phi}}\\) 在平面直角坐标系下展开, 有 \\(\\hat{\\mathbf{\\theta}} = \\cos{\\theta} \\cos{\\phi} \\, \\hat{\\mathbf{i}} + \\cos{\\theta} \\sin{\\phi} \\, \\hat{\\mathbf{j}} - \\sin{\\theta} \\, \\hat{\\mathbf{k}}\\), \\(\\hat{\\mathbf{\\phi}} = -\\sin{\\phi} \\, \\hat{\\mathbf{i}} + \\cos{\\phi} \\, \\hat{\\mathbf{j}}\\), 代入 \\(\\mathbf{L}\\), 将分量集中可以得到 $$L_x = - \\mathrm{i} \\hbar (-\\sin{\\phi} \\, \\partial_\\theta - \\cos{\\phi} \\cot{\\theta} \\, \\partial_\\phi)$$ $$L_y = - \\mathrm{i} \\hbar (\\cos{\\phi} \\, \\partial_\\theta - \\sin{\\phi} \\cot{\\theta} \\, \\partial_\\phi)$$ $$L_z = - \\mathrm{i} \\hbar \\, \\partial_\\phi$$ 这样我们还得到了阶梯算符 \\(L_\\pm\\) $$L_\\pm = \\pm \\hbar \\mathrm{e}^{\\pm \\mathrm{i} \\phi} (\\partial_\\theta \\pm \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi)$$可以看到上述算符都不涉及径向分量 \\(r\\), 于是我们选择转轴 \\(\\hat{\\mathbf{n}}\\) 表象来讨论角动量态矢的具体表达式 \\(Y_{l m}(\\theta, \\phi)\\), 即 $$\\braket{\\hat{\\mathbf{n}} | l, m} = Y_{l m}(\\theta, \\phi)$$最高权态# 我们首先研究的是 \\(m\\) 取最大值, 即 \\(m = l\\) 时 \\(\\braket{\\hat{\\mathbf{n}} | l, l}\\) 的具体表达式, 这被称之为最高权态.\n假设其具有分离变量形式 \\(\\braket{\\hat{\\mathbf{n}} | l, l} = \\Theta(\\theta) \\, \\Phi(\\phi)\\), 考虑到算符 \\(L_z\\) 与 \\(L_+\\) 作用的结果, 我们有 $$\\begin{align} \u0026 L_z \\braket{\\hat{\\mathbf{n}} | l, l} = l \\hbar \\braket{\\hat{\\mathbf{n}} | l, l} \\\\ \\Rightarrow \u0026 - \\mathrm{i} \\hbar \\, \\partial_\\phi \\braket{\\hat{\\mathbf{n}} | l, l} = l \\hbar \\braket{\\hat{\\mathbf{n}} | l, l} \\\\ \\Rightarrow \u0026 \\, \\frac{\\mathrm{d} \\Phi}{\\mathrm{d} \\phi} = \\mathrm{i} l \\Phi \\\\ \\Rightarrow \u0026 \\, \\Phi(\\phi) = \\mathrm{e}^{\\mathrm{i} l \\phi} \\end{align}$$ 进一步确定 \\(\\Theta\\) 的表达式 $$\\begin{align} \u0026 L_+ \\braket{\\hat{\\mathbf{n}} | l, l} = 0 \\\\ \\Rightarrow \u0026 - \\mathrm{i} \\hbar \\, \\mathrm{e}^{\\mathrm{i} \\phi} (\\mathrm{i} \\, \\partial_\\theta - \\cot{\\theta} \\, \\partial_\\phi) \\braket{\\hat{\\mathbf{n}} | l, l} = 0 \\\\ \\Rightarrow \u0026 \\, \\mathrm{i} \\Phi \\frac{\\mathrm{d} \\Theta}{\\mathrm{d} \\theta} = \\cot{\\theta} \\, \\Theta \\frac{\\mathrm{d} \\Phi}{\\mathrm{d} \\phi} = \\cot{\\theta} \\, \\Theta \\, \\mathrm{i} l \\Phi \\\\ \\Rightarrow \u0026 \\, \\frac{\\mathrm{d} \\Theta}{\\mathrm{d} \\theta} = l \\cot{\\theta} \\, \\Theta \\end{align}$$ 分离变量得 $$\\begin{align} \u0026 \\frac{\\mathrm{d} \\Theta}{\\Theta} = l \\cot{\\theta} \\, \\mathrm{d} \\theta \\\\ \\Rightarrow \u0026 \\, \\ln{\\Theta} + C' = l \\ln{\\sin{\\theta}} \\\\ \\Rightarrow \u0026 \\, \\Theta(\\theta) = C \\sin^l{\\theta} \\end{align}$$综上, $$\\braket{\\hat{\\mathbf{n}} | l, l} = C \\mathrm{e}^{\\mathrm{i} l \\phi} \\sin^l{\\theta}$$接下来确定归一化系数 \\(C\\) 的值. 对 \\(||\\braket{\\hat{\\mathbf{n}} | l, l} \\, ||^2 = C^2 \\sin^{2l}{\\theta}\\) 做积分 $$\\begin{align} \\int_0^{2\\pi} \\mathrm{d} \\phi \\int_0^\\pi \\sin{\\theta} \\, \\mathrm{d} \\theta \\; \\sin^{2l}{\\theta} \u0026= 2 \\pi \\int_0^\\pi \\sin^{2l+1}{\\theta} \\, \\mathrm{d} \\theta \\\\ \u0026= 4 \\pi \\int_0^{\\frac{\\pi}{2}} \\sin^{2l+1}{\\theta} \\, \\mathrm{d} \\theta \\\\ \u0026= 4 \\pi \\frac{(2l)!!}{(2l+1)!!} \\\\ \u0026= 4 \\pi \\frac{((2l)!!)^2}{(2l+1) (2l)!} \\\\ \u0026= 4 \\pi \\frac{(2^l \\, l!)^2}{(2l+1) (2l)!} \\end{align}$$ 过程使用了 \\((2l)!! (2l+1)!! = (2l+1)!\\), \\((2l)!! = 2^l \\, l!\\), 这里我们不证. 为了使 \\(\\braket{\\hat{\\mathbf{n}} | l, l}\\) 归一化, 需要使 \\(C\\) 取 $$C = \\frac{(-1)^l}{2^l \\, l!} \\sqrt{\\frac{(2l+1) (2l)!}{4 \\pi}}$$当然, 归一化条件确定不了相因子 \\((-1)^l\\), 加入这一项是为了从 \\(\\braket{\\hat{\\mathbf{n}} | l, l}\\) 连续使用 \\(L_-\\) 下降到 \\(\\braket{\\hat{\\mathbf{n}} | l, 0}\\) 时, 得到的 \\(Y_{l 0}\\) 有着与勒让德多项式相同的符号.\n球谐函数# 从最高权态出发, 连续使用降算符, 我们可以得到从 \\(m = l\\) 到 \\(m = 0\\) 的一系列态. 我们将使用这种方法得到一般情况下 \\(\\braket{\\hat{\\mathbf{n}} | l, m}\\) 的表达式.\n降算符为 \\(L_- = \\hbar \\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi)\\), 为了使从 \\(\\braket{\\hat{\\mathbf{n}} | l, m}\\) 降低的态 \\(\\braket{\\hat{\\mathbf{n}} | l, m-1}\\) 保证仍是归一化的, 我们将要使用上文推导的 \\(k_-\\) 系数, 将降算符改写为 $$\\begin{align} \\braket{\\hat{\\mathbf{n}} | l, m-1} \u0026= \\frac{\\bra{\\hat{\\mathbf{n}}} L_- \\ket{l, m}}{k_-} \\\\ \u0026= \\frac{\\bra{\\hat{\\mathbf{n}}} L_- \\ket{l, m}}{\\sqrt{l (l + 1) - m (m - 1)} \\, \\hbar} \\\\ \u0026= \\frac{\\bra{\\hat{\\mathbf{n}}} L_- \\ket{l, m}}{\\sqrt{(l + m) (l - m + 1)} \\, \\hbar} \\\\ \u0026= \\frac{1}{\\sqrt{(l + m) (l - m + 1)}} \\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi) \\braket{\\hat{\\mathbf{n}} | l, m} \\end{align}$$我们将先略去系数, 只讨论函数形式的变化; 得到表达式后补上系数使其归一化. 现在我们将从 \\(\\braket{\\hat{\\mathbf{n}} | l, l}\\) 态降低 \\(n := l - m\\) 次到达 \\(\\braket{\\hat{\\mathbf{n}} | l, m}\\), 即 $$\\begin{align} \\braket{\\hat{\\mathbf{n}} | l, m} \u0026\\sim (\\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi))^n \\braket{\\hat{\\mathbf{n}} | l, l} \\\\ \u0026 \\sim (\\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi))^n \\, \\mathrm{e}^{\\mathrm{i} l \\phi} \\sin^l{\\theta} \\\\ \u0026= (\\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi))^{n-1} ~ (\\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi)) ~ \\mathrm{e}^{\\mathrm{i} l \\phi} \\sin^l{\\theta} \\\\ \u0026= (\\mathrm{e}^{- \\mathrm{i} \\phi} (-\\partial_\\theta + \\mathrm{i} \\cot{\\theta} \\, \\partial_\\phi))^{n-1} ~ \\mathrm{e}^{\\mathrm{i} (l-1) \\phi} ~ (-\\partial_\\theta - l \\cot{\\theta}) ~ \\sin^l{\\theta} \\\\ \u0026= \\cdots \\\\ \u0026= \\mathrm{e}^{\\mathrm{i} (l-n) \\phi} (-\\partial_\\theta - (m+1) \\cot{\\theta}) (-\\partial_\\theta - (m+2) \\cot{\\theta}) \\cdots (-\\partial_\\theta - l \\cot{\\theta}) \\sin^l{\\theta} \\\\ \u0026= (-1)^n \\mathrm{e}^{\\mathrm{i} m \\phi} (\\partial_\\theta + (m+1) \\cot{\\theta}) (\\partial_\\theta + (m+2) \\cot{\\theta}) \\cdots (\\partial_\\theta + l \\cot{\\theta}) \\sin^l{\\theta} \\end{align}$$为了求解后面的 \\(n\\) 次求导, 关键的一点是注意到 $$\\partial_\\theta + r \\cot{\\theta} = \\frac{1}{\\sin^r{\\theta}} \\partial_\\theta \\sin^r{\\theta}$$ 需要注意 \\(\\partial_\\theta \\sin^r{\\theta}\\) 仍然是算符, 需要与右侧待给出的表达式结合后计算. 证明这一等式是容易的 $$\\begin{align} \\partial_\\theta \\sin^r{\\theta} \u0026= \\frac{\\mathrm{d}}{\\mathrm{d} \\theta} \\sin^r{\\theta} + \\sin^r{\\theta} \\, \\partial_\\theta \\\\ \u0026= r \\cos{\\theta} \\sin^{r-1}{\\theta} + \\sin^r{\\theta} \\, \\partial_\\theta \\\\ \u0026= \\sin^r{\\theta} \\, (r \\cot{\\theta} + \\, \\partial_\\theta) \\end{align}$$接下来可以处理 \\(n\\) 次求导了. $$\\begin{align} \u0026 (\\partial_\\theta + (m+1) \\cot{\\theta}) \\cdots (\\partial_\\theta + (l-1) \\cot{\\theta}) (\\partial_\\theta + l \\cot{\\theta}) \\sin^l{\\theta} \\\\ = \u0026 (\\partial_\\theta + (m+1) \\cot{\\theta}) \\cdots (\\partial_\\theta + (l-1) \\cot{\\theta}) ~ \\frac{1}{\\sin^l{\\theta}} \\partial_\\theta \\sin^{2l}{\\theta} \\\\ = \u0026 (\\partial_\\theta + (m+1) \\cot{\\theta}) \\cdots \\frac{1}{\\sin^{l-1}{\\theta}} \\partial_\\theta \\sin^{l-1}{\\theta} ~ \\frac{1}{\\sin^l{\\theta}} \\partial_\\theta \\sin^{2l}{\\theta} \\\\ = \u0026 (\\partial_\\theta + (m+1) \\cot{\\theta}) \\cdots \\frac{1}{\\sin^{l-1}{\\theta}} \\partial_\\theta (\\frac{1}{\\sin{\\theta}} \\partial_\\theta) \\sin^{2l}{\\theta} \\\\ = \u0026 \\cdots \\\\ = \u0026 \\frac{1}{\\sin^{m+1}{\\theta}} \\partial_\\theta \\cdots (\\frac{1}{\\sin{\\theta}} \\partial_\\theta) (\\frac{1}{\\sin{\\theta}} \\partial_\\theta) \\sin^{2l}{\\theta} \\\\ = \u0026 \\frac{1}{\\sin^m{\\theta}} (\\frac{1}{\\sin{\\theta}} \\partial_\\theta)^n \\sin^{2l}{\\theta} \\\\ = \u0026 \\frac{(-1)^n}{\\sin^m{\\theta}} \\frac{\\mathrm{d}^n}{\\mathrm{d} (\\cos{\\theta})^n} \\sin^{2l}{\\theta} \\end{align}$$ 其中用到了 \\(\\frac{\\mathrm{d}}{\\mathrm{d} \\cos{\\theta}} = - \\frac{1}{\\sin{\\theta}} \\frac{\\mathrm{d}}{\\mathrm{d} \\theta}\\).\n最后考虑 \\(n\\) 次求导过程中归一化系数的变化 $$\\begin{align} \u0026\\frac{1}{\\sqrt{(l+m+1)(l-m)}} \\frac{1}{\\sqrt{(l+m+2)(l-m-1)}} \\cdots \\frac{1}{\\sqrt{(2l-1) \\, 2}} \\frac{1}{\\sqrt{2l}} \\\\ = \u0026 \\frac{1}{\\sqrt{\\frac{(2l)!}{(l+m)!}(l-m)!}} \\\\ = \u0026 \\sqrt{\\frac{(l+m)!}{(2l)! (l-m)!}} \\end{align}$$综上所述, 我们得到了 $$\\begin{align} Y_{l m} \u0026= \\braket{\\hat{\\mathbf{n}} | l, m} \\\\ \u0026= C \\sqrt{\\frac{(l+m)!}{(2l)! (l-m)!}} ~ (-1)^n \\mathrm{e}^{\\mathrm{i} m \\phi} ~ \\frac{(-1)^n}{\\sin^m{\\theta}} \\frac{\\mathrm{d}^n}{\\mathrm{d} (\\cos{\\theta})^n} \\sin^{2l}{\\theta} \\\\ \u0026= \\frac{(-1)^l}{2^l \\, l!} \\sqrt{\\frac{(2l+1) (2l)!}{4 \\pi}} \\sqrt{\\frac{(l+m)!}{(2l)! (l-m)!}} ~ \\mathrm{e}^{\\mathrm{i} m \\phi} ~ \\frac{1}{\\sin^m{\\theta}} \\frac{\\mathrm{d}^n}{\\mathrm{d} (\\cos{\\theta})^n} \\sin^{2l}{\\theta} \\\\ \u0026= \\frac{(-1)^l}{2^l \\, l!} \\sqrt{\\frac{(2l+1) (l+m)!}{4 \\pi (l-m)!}} ~ \\mathrm{e}^{\\mathrm{i} m \\phi} ~ \\frac{1}{\\sin^m{\\theta}} \\frac{\\mathrm{d}^{l-m}}{\\mathrm{d} (\\cos{\\theta})^{l-m}} \\sin^{2l}{\\theta} \\end{align}$$ 可以认出这就是我们所熟知的球谐函数. 它是球面上正交归一的一族基函数, 这一性质可以从我们对态矢的讨论中得知:\n态矢是归一化的, 对应了球谐函数的归一性; 态矢是厄米算符对应不同本征值的本征态, 根据厄米算符的性质, 这些本征态是正交的, 对应了球谐函数的正交性; 这一组态矢是 \\(\\mathbf{J}^2\\) 与 \\(J_z\\) 的共同本征态, 因此它们能够作为角动量空间的一组基. "},{"id":4,"href":"/docs/jordan-normal-form/","title":"若尔当标准型","section":"Docs","content":"若尔当标准型# 我们对若尔当标准型的讨论始于两个最基本与最常用的问题:\n如何将线性空间 \\(V\\) 分解为线性变换 \\(A\\) 的不变子空间 \\(V_i\\) 的直和? 如何使线性变换 \\(A\\) 在 \\(V\\) 的一组基上具有最简洁的矩阵形式? 对于问题一, 一个合理的附加条件是 \\(A\\) 在这些不变子空间 \\(V_i\\) 上具有良好的性质, 这样要研究 \\(A\\), 只需在每个更小的空间上研究, 并且充分利用那些性质, 最后汇总为 \\(V\\) 即可. 问题二则是为了方便计算, 我们可以利用这种简洁矩阵的性质, 提供远比普通矩阵乘法等更优的算法.\n对于这两个问题, 我们首先想到的应该是线性变化的对角化. 对于可对角化的线性变换, 充要条件之一便是线性空间 \\(V\\) 可以被分解为特征子空间的直和 \\(V = E_{\\lambda_1} \\oplus E_{\\lambda_2} \\oplus \\cdots \\oplus E_{\\lambda_r}\\). 并且我们知道这一变换在其特征向量组成的基下是对角矩阵. 这样两个问题就都得到解决. 遗憾的是, 并非每一个矩阵都可以对角化. 我们要讨论的便是一种类似对角化的, 可以对每个变换进行的分解.\n"},{"id":5,"href":"/docs/commutative-lt/","title":"可交换的线性变换","section":"Docs","content":"可交换的线性变换# 这篇文章讨论可交换的线性变换, 即对于线性变换 \\(A\\), \\(B\\), 有 \\(AB = BA\\).\n引理# \\(f(A)\\) 与 \\(B\\) 可交换的充要条件是 \\(A\\), \\(B\\) 可交换.\n充要条件# 复数域上线性变换 \\(A\\), \\(B\\) 可交换的充要条件是: \u0026gt; \\(A\\) 的每个广义特征空间 \\(E_{\\lambda}\\) 都是 \\(B\\) 的不变子空间.\n其中广义特征空间 \\(E_{\\lambda} = \\{\\mathbf{v} ~ | ~ (A - \\lambda I)^m \\; \\mathbf{v} = \\mathbf{0}, m \\in \\mathbb{N}_+\\}\\). 线性空间 \\(V\\) 总是可以分解为其上某一线性变换的广义特征空间的直和.\n证明:\n充分性: 任取 \\(A\\) 在重数 \\(m\\) 的广义特征空间 \\(E_{\\lambda}\\), \\(\\forall \\mathbf{v} \\in E_{\\lambda}; B \\mathbf{v} \\in E_{\\lambda}\\). 于是 \\(B (A - \\lambda I)^m \\mathbf{v} = B \\; \\mathbf{0} = \\mathbf{0}\\), \\((A - \\lambda I)^m B \\mathbf{v} = (A - \\lambda I)^m (B \\mathbf{v}) = \\mathbf{0}\\). 注意到 \\((A - \\lambda I)^m\\) 是关于 \\(A\\) 的多项式, 由此可得 \\(E_{\\lambda}\\) 上 \\(A\\) 与 \\(B\\) 可交换.\n将复数域上向量空间 \\(V\\) 分解为广义特征空间的直和 \\(V = E_{\\lambda_1} \\oplus E_{\\lambda_2} \\oplus \\dots \\oplus E_{\\lambda_r}\\), 其中 \\(E_{\\lambda_i}\\) 是对应于特征值 \\(\\lambda_i\\) 的广义特征空间. 任取 \\(\\mathbf{u} \\in V\\), \\(\\mathbf{u} = \\sum_i k_i \\mathbf{v}_i\\), 其中 \\(\\mathbf{v}_i \\in E_{\\lambda_i}\\). 对于任意 \\(\\mathbf{v}_i\\) 都有 \\(A\\), \\(B\\) 可交换, 故对于其线性组合 \\(\\mathbf{u}\\) 也可交换.\n综上, \\(A\\), \\(B\\) 在 \\(V\\) 上可交换.\n必要性: 若 \\(A\\), \\(B\\) 可交换, 则对任意 \\(\\mathbf{v} \\in E_{\\lambda}\\), 都有 \\((A - \\lambda I)^m (B \\mathbf{v}) = B ((A - \\lambda I)^m \\mathbf{v}) = B \\; \\mathbf{0} = \\mathbf{0}\\). 故 \\(B \\mathbf{v} \\in E_{\\lambda}\\). 即 \\(E_{\\lambda}\\) 是 \\(B\\) 的不变子空间.\n"},{"id":6,"href":"/docs/dynamic-simulation-of-density-fluids/","title":"密度流体的动态模拟","section":"Docs","content":"密度流体的动态模拟# 我们将不可压缩流体的模拟分为两类, 一类聚焦于流体本身, 另一类则聚焦依托于流场的标量场. 前者称为体积流体, 如水与空气二相的模拟, 我们更关心流体本身的运动; 后者称为密度流体, 如充斥于密闭容器中的浊液的模拟, 我们关注的是溶质的物质的量密度这一标量. 需要注意的是这两个词仅为本篇文章的约定, 而非正式的学术用语.\n本文讲述了不可压缩密度流体的运动学模拟. 纵览符合这一条件的流场, 如附加温度场, 容质的密度场等, 其标量场都耦合于流体的速度场. 这是指标量会被流体输运, 例如温度的对流; 标量场同时可以反过来影响速度场, 例如渗透压导致的流体运动, 但我们一般不认为它会破坏流体的不可压缩性, 否则这将导致被求解方程的形式变得极端复杂.\n写出不可压缩流体的纳维 - 斯托克斯方程: $$\\nabla \\cdot \\mathbf{u} = 0$$ $$\\frac{\\mathrm{D} \\mathbf{u}}{\\mathrm{D} t} = -\\nabla \\frac{p}{\\rho} + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{a}$$ 前者是质量守恒定律对应的连续性方程在不可压缩, 即 \\(\\rho \\equiv \\mathrm{const}\\) 时的推论; 后者是牛顿第二定律. 其中 \\(\\nu\\) 是运动粘度, \\(\\nu := \\mu/\\rho\\), \\(\\mu\\) 是动力粘度. 流体力学中, 我们一般用 \\(\\mathbf{u}\\) 代表速度.\n后式中出现的随质导数, 或称物质导数 \\(\\frac{\\mathrm{D}}{\\mathrm{D} t} := \\frac{\\partial}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\). 这一式中前者表示欧拉导数; 后者表示拉格朗日导数, 即由于流体的运动带来的变化, 这个效应称为移流. 将其拆开可以写为 $$\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla \\frac{p}{\\rho} - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{a}$$接下来, 我们将首先讨论速度场的模拟, 这一过程中积累的经验可以被移用到标量场的模拟内. 必须注意: 本文将聚焦于视觉效果而非真实的物理过程. 本文主要参考 Stam 发表的论文1.\n速度场# 为了在计算机中模拟, 需要对空间进行离散化. 最显而易见的方式是网格法. 这一方法将空间划分为许多细密的网格, 每一格点都保存有这一位置的模拟量, 在这里是速度 \\(\\mathbf{u}\\). 当网格划分地足够细时, 我们认为系统的演化收敛于连续情况, 这是显然的.\n值得注意的是, 为了方便施予边界条件, 我们将网格靠外再扩充一层. 这一层并不属于网格的范围, 也不参与计算, 它被称为幽灵层; 而紧贴幽灵层的, 属于网格范围的最外层被称为边界. 对于我们希望观察的密闭容器, 微分方程的边界条件可以被简单地设置为: 幽灵层是边界的相反数. 这样便可保证边界的动能被幽灵层全部消耗, 不会有速度逸散出去. 在下面的每一步后, 都必须重新设置幽灵层的值, 以保证边界条件始终满足.\n算子分裂# 速度场的模拟将被分为几个步骤顺序进行, 这是由于时间离散化导致的妥协, 但我们仍可以认为当时间步取得足够小时, 最终的效果与理想的连续时间演化相差甚微.\n首先进行的是将源, 即外加的力或加速度添加到速度场中; 其次是扩散 (diffuse), 这使流体表现出粘性; 接着是平流 (advect), 这使速度随流体运动而运输, 形成速度流. 每一步都必须在设定的边界条件下进行; 并且都要进行投影 (project), 以保证流体不可压缩.\n我们之所以这样做, 是因为以下两点.\n第一, 方程中 \\(-\\nabla \\frac{p}{\\rho}\\) 项的作用是保证流体的不可压缩性, 即 \\(\\nabla \\cdot \\mathbf{u} = 0\\). 此处的进一步论述可以查看后文 投影 一节.\n第二, 方程可以被拆分为以下形式: $$\\mathbf{u}^*(t+\\mathrm{d}t) = \\mathbf{u}(t) + \\mathbf{a} \\; \\mathrm{d}t + \\nu \\nabla^2 \\mathbf{u} \\; \\mathrm{d}t - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} \\; \\mathrm{d}t$$ 上式中 \\(\\mathbf{u}(t)\\) 是 \\(t\\) 时刻的速度; \\(\\mathbf{u}^*(t+\\mathrm{d}t)\\) 是 \\(t + \\mathrm{d}t\\) 时刻的速度, \\((\\cdot)^*\\) 代表此时的速度因为方程中缺少 \\(-\\nabla \\frac{p}{\\rho}\\) 一项而导致散度不为 \\(0\\), 即不可压缩性被破坏. \\(\\mathbf{u}\\) 代表在 \\(t \\sim t+\\mathrm{d}t\\) 内某个时间的速度, 在式中出现多次时每次对应的时间都不同. 由拉格朗日中值定理, 这一时间必然存在以使上式成立.\n定义 \\(\\mathbf{u}^{\\mathrm{f}*} := \\mathbf{u}(t) + \\mathbf{a} \\; \\mathrm{d}t\\) 为加入源后的速度场, 注意此时仍然不满足不可压缩性;\n\\(\\mathbf{u}^{\\mathrm{d}*} := \\mathbf{u}^{\\mathrm{f}*} + \\nu \\nabla^2 \\mathbf{u} \\; \\mathrm{d}t\\) 为扩散后的速度场;\n\\(\\mathbf{u}^* = \\mathbf{u}^{\\mathrm{v}*} := \\mathbf{u}^{\\mathrm{d}*} - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} \\; \\mathrm{d}t\\) 为平流后的速度场.\n此时便可以明显看出顺序进行几个步骤. 为了保证物理实际, 对每个得到的中间步骤 (除加入源后的) 进行投影, 最后得到的场 \\(\\mathbf{u}\\) 便是推进了时间 \\(\\mathrm{d}t\\) 的不可压缩的速度. 用图表示为 $$\\mathbf{u}(t) \\rightarrow \\mathbf{u}^{\\mathrm{f}*} \\rightarrow \\mathbf{u}^{\\mathrm{d}*} \\rightarrow \\mathbf{u}^{\\mathrm{d}} \\rightarrow (\\mathbf{u}^{*} = \\mathbf{u}^{\\mathrm{v}*}) \\rightarrow \\mathbf{u}(t+\\mathrm{d}t)$$一个被回避的问题是我们只说明了每一个步骤中使用的 \\(\\mathbf{u}\\) 的存在性, 而没有给出其具体取值. Stam 的指导是使用前一步计算出的速度. 这一指导的动机在于始终避免用具有散度的不正常速度进行计算, 同时保证速度的实时性. 下面的章节将展示具体的计算过程.\n上面的方法被称为算子分裂. 它将耦合的复杂方程拆分为几个简单便于求解的方程, 降低了处理难度. 值得注意的是扩散与对流的顺序似乎是任意的, 但只要考虑到扩散过程会将速度平滑化, 有助于避免出现尖锐的速度区, 就会知道将其放置于更靠前的位置可以改善后续步骤的数值稳定性与精度, 因此这一顺序更加合理.\n扩散# 扩散对应的方程为 $$\\frac{\\partial \\mathbf{u}}{\\partial t} = \\nu \\nabla^2 \\mathbf{u}$$ 将其写为离散时间形式 $$\\mathbf{u}^{\\mathrm{d}*}(t+\\Delta t) = \\mathbf{u}(t) + (\\nu \\nabla^2 \\mathbf{u}(t)) \\Delta t$$较为困难的是将 Laplace 算子 \\(\\nabla^2\\) 进行空间的离散化. 在平面直角坐标系中, 有 \\(\\nabla^2 = \\partial_x^2 + \\partial_y^2\\); 并且 $$\\frac{\\partial \\mathbf{u}(\\mathbf{r})}{\\partial x} = \\frac{\\mathbf{u}(\\mathbf{r}+\\mathrm{d}\\mathbf{x}) - \\mathbf{u}(\\mathbf{r})}{\\mathrm{d}x}$$ $$\\frac{\\partial^2 \\mathbf{u}(\\mathbf{r})}{\\partial x^2} = \\frac{(\\mathbf{u}(\\mathbf{r}+\\mathrm{d}\\mathbf{x}) - \\mathbf{u}(\\mathbf{r})) - (\\mathbf{u}(\\mathbf{r}) - \\mathbf{u}(\\mathbf{r}-\\mathrm{d}\\mathbf{x}))} {\\mathrm{d}x^2}$$ 对 \\(y\\) 求偏导同理. 整理并离散化可得 $$\\begin{align} \\nabla^2 \\mathbf{u}(\\mathbf{r}) = \u0026 \\frac{\\mathbf{u}(\\mathbf{r}+\\Delta \\mathbf{x}) + \\mathbf{u}(\\mathbf{r}-\\Delta \\mathbf{x}) - 2 \\mathbf{u}(\\mathbf{r})}{\\Delta x^2} \\\\ \u0026 + \\frac{\\mathbf{u}(\\mathbf{r}+\\Delta \\mathbf{y}) + \\mathbf{u}(\\mathbf{r}-\\Delta \\mathbf{y}) - 2 \\mathbf{u}(\\mathbf{r})}{\\Delta y^2} \\end{align}$$ 为了计算方便, 我们要求每个格子都是正方形. 设其边长为 \\(l\\), 则 $$\\begin{align} \\nabla^2 \\mathbf{u} = \u0026 \\frac{\\mathbf{u}(x+\\Delta x) + \\mathbf{u}(x-\\Delta x) - 2 \\mathbf{u}}{l^2} \\\\ \u0026 + \\frac{\\mathbf{u}(y+\\Delta y) + \\mathbf{u}(y-\\Delta y) - 2 \\mathbf{u}}{l^2} \\\\ = \u0026 \\frac{\\mathbf{u}(x+\\Delta x) + \\mathbf{u}(x-\\Delta x) + \\mathbf{u}(y+\\Delta y) + \\mathbf{u}(y-\\Delta y) - 4 \\mathbf{u}}{l^2} \\end{align}$$ 这样一来, \\(\\nabla^2\\) 只与当前位置格子, 以及与这一格子直接相邻的 4 格的速度, 他们整体呈十字形分布. 如果要求更高精度, 可以将四个角点也纳入考虑, 但对于我们需要的流体模拟来说上述 5 个点已经足够. 我们将四个邻点之和记作 \\(\\sum_\\mathrm{nbr} \\mathbf{u} := \\mathbf{u}(x+\\Delta x) + \\mathbf{u}(x-\\Delta x) + \\mathbf{u}(y+\\Delta y) + \\mathbf{u}(y-\\Delta y)\\).\n将我们上面求得的 Laplace 算子代入方程, 得到 $$\\mathbf{u}^{\\mathrm{d}*}(t+\\Delta t) - \\mathbf{u}(t) = \\nu \\Delta t \\; \\nabla^2 \\mathbf{u}(\\tau)$$ 其中 \\(\\tau \\in [t, t+\\Delta t]\\). 选择更靠后的时间更有利于保证系统保持最新, 若选择 \\(\\tau = t+\\Delta t\\) 则有 $$\\mathbf{u}^{\\mathrm{d}*} - \\mathbf{u} = \\nu \\Delta t \\; \\nabla^2 \\mathbf{u}^{\\mathrm{d}*}$$ 将上面计算得到的离散 Laplace 算子代入, 得 $$\\begin{align} \\mathbf{u}^{\\mathrm{d}*} - \\mathbf{u} \u0026= \\frac{\\nu \\Delta t}{l^2} \\; (\\sum_{\\mathrm{nbr}} \\mathbf{u}^{\\mathrm{d}*} - 4 \\mathbf{u}^{\\mathrm{d}*}) \\\\ \\Leftrightarrow (1 + 4k) \\mathbf{u}^{\\mathrm{d}*} \u0026= \\mathbf{u} + k \\sum_{\\mathrm{nbr}} \\mathbf{u}^{\\mathrm{d}*} \\\\ \\Leftrightarrow \\mathbf{u}^{\\mathrm{d}*} \u0026= \\frac{\\mathbf{u} + k \\sum_{\\mathrm{nbr}} \\mathbf{u}^{\\mathrm{d}*}}{1 + 4k} \\end{align}$$ 其中 \\(k = \\frac{\\nu \\Delta t}{l^2}\\).\n上式给出了一种使用逐格遍历网格来求解扩散方程的方法, 称为 Gauss\u0026ndash;Seidel 迭代法. 为了提高精度, 通常要按上式迭代数次. 注意, 左侧为迭代结果, 右侧为对原始网格与结果缓冲区的操作. 这一迭代法需要逐格计算, 每次对单个格点的计算依赖于前几步计算, 这一点可以从右侧的求和看出. 这一特性保证了计算时始终能够使用最新的信息, 提高了收敛速度; 但也导致了算法不易并行化.\n扩散前, 需要设置合适的边界条件; 扩散过程结束后, 需要对 \\(\\mathbf{u}^{\\mathrm{d}*}\\) 进行投影得到 \\(\\mathbf{u}^{\\mathrm{d}}\\), 以消除速度场的散度, 保证流体不可压.\n平流# 平流对应的方程为 $$\\frac{\\partial \\mathbf{u}}{\\partial t} = - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u}$$求解这一方程可以使用朴素的欧拉法, 即计算每个微小时间段内的演进, 但是这一方法在速度较大或时间步长过长时数值不稳定. 为了解决这一问题, 我们使用 半 Lagrangian 法 来求解方程.\n半 Lagrangian 法基于这样一个事实:\n对于依赖位置与时间的连续函数 \\(\\phi(\\mathbf{r}, t)\\), 当 \\(\\frac{\\partial \\phi}{\\partial t} = (\\mathbf{v} \\cdot \\nabla) \\phi\\), 则始终有 \\(\\phi(\\mathbf{r} + \\mathrm{d}\\mathbf{r}, t) = \\phi(\\mathbf{r}, t + \\mathrm{d}t)\\), 其中 \\(\\mathrm{d}\\mathbf{r} = \\mathbf{v} \\mathrm{d}t\\).\n下面我们证明这一定理.\n$$\\phi(\\mathbf{r}, t + \\mathrm{d}t) = \\phi(\\mathbf{r}, t) + \\frac{\\partial}{\\partial t} \\phi \\; \\mathrm{d}t$$ $$\\begin{align} \\phi(\\mathbf{r} + \\mathrm{d}\\mathbf{r}, t) \u0026= \\phi(\\mathbf{r}, t) + \\frac{\\partial}{\\partial \\mathbf{r}} \\phi \\cdot \\mathrm{d}\\mathbf{r} \\\\ \u0026= \\phi(\\mathbf{r}, t) + \\frac{\\partial}{\\partial \\mathbf{r}} \\phi \\cdot \\mathbf{v} \\mathrm{d}t \\\\ \u0026= \\phi(\\mathbf{r}, t) + \\mathbf{v} \\cdot \\frac{\\partial}{\\partial \\mathbf{r}} \\phi \\; \\mathrm{d}t \\\\ \u0026= \\phi(\\mathbf{r}, t) + (\\mathbf{v} \\cdot \\nabla) \\phi \\; \\mathrm{d}t \\end{align}$$ 于是 \\(\\phi(\\mathbf{r} + \\mathrm{d}\\mathbf{r}, t) = \\phi(\\mathbf{r}, t + \\mathrm{d}t)\\).\n将这一定理应用到 \\(\\mathbf{u}\\) 的两个分量上, 并令 \\(\\mathbf{v} := -\\mathbf{u}\\), 可以得到 $$\\mathbf{u}^{\\mathrm{v}*} = \\mathbf{u}(\\mathbf{r}, t + \\mathrm{d}t) = \\mathbf{u}(\\mathbf{r} - \\mathbf{u} \\mathrm{d}t, t)$$ 于是求 \\(\\mathrm{d}t\\) 时间之后的速度场等价于将每个点向后平移 \\(\\mathbf{u}\\mathrm{d}t\\) 得到的速度场. 这样取得的结果面对较长时间步长时仍然具有较好的数值稳定性.\n需要注意的是, 格点 \\(\\mathbf{r}\\) 总是处于有序的整数位置, 因此总是可以准确获知其对应的速度, 因为速度被存在相应位置的变量中. 但对格点 \\(\\mathbf{r}\\) 计算 \\(\\mathbf{r}' := \\mathbf{r} - \\mathbf{u} \\mathrm{d}t\\) 得到的值却总是不会出现在整数位置处, 因此如何获取其速度是我们面对的挑战. 一个简单的方法是对包围 \\(\\mathbf{r}'\\) 的四点所对应的速度进行插值, 以此结果作为该点的速度. 所使用的插值方法可以是双线性插值或其他. 这一方法的重大弊端是取得的速度并非精确值, 它总是具有较大的误差, 这是由于插值而引入的. 当我们将平流方法应用在要求严格守恒 (物质的量守恒或质量守恒) 的组分上时, 这一组分的守恒要求便被破坏, 只能通过其他方法来弥补.\n同上, 平流前需要设置合适的边界条件; 平流后需要对 \\(\\mathbf{u}^{*} = \\mathbf{u}^{\\mathrm{v}*}\\) 进行投影得到 \\(\\mathbf{u}\\), 以消除速度场的散度, 保证流体不可压.\n投影# 对纳维-斯托克斯方程两侧求散度, 可得 $$\\frac{\\partial}{\\partial t} \\nabla \\cdot \\mathbf{u} = -\\nabla^2 \\frac{p}{\\rho} - \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla) \\mathbf{u}) + \\nu \\nabla^2 (\\nabla \\cdot \\mathbf{u}) + \\nabla \\cdot \\mathbf{a}$$ 我们的目标为使 \\(\\nabla \\cdot \\mathbf{u} = 0\\), 代入上式得 $$0 = -\\rho^{-1} \\nabla^2 p - \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla) \\mathbf{u}) + \\nabla \\cdot \\mathbf{a}$$ 由亥姆霍兹分解定理, \\(\\mathbf{a} = \\nabla \\phi + \\nabla \\times \\mathbf{A}\\), 代入后因为 \\(\\nabla \\cdot \\nabla \\times \\mathbf{A} = 0\\), 将前一项并入 \\(p\\) 中, 得 $$\\nabla^2 p = -\\rho \\nabla \\cdot ((\\mathbf{u} \\cdot \\nabla) \\mathbf{u}) + \\rho \\nabla^2 \\phi$$ 于是得到了关于压强的泊松方程. 这一压强的结果是使方程速度无散的必要条件. 可以证明当边界条件与初值条件合适时, 这也是充分条件.\n在具体实践中, 我们希望将一个具有散度的场 \\(\\mathbf{u}^*\\) 转为无散场 \\(\\mathbf{u}\\). 使用亥姆霍兹分解定理, 将 \\(\\mathbf{u}^*\\) 分解为标量势 \\(\\phi\\) 与矢量势 \\(\\mathbf{A}\\): \\(\\mathbf{u}^* = \\nabla \\phi + \\nabla \\times \\mathbf{A}\\), 此时两侧取散度得 $$\\begin{align} \\nabla \\cdot \\mathbf{u}^* \u0026= \\nabla^2 \\phi + \\nabla \\cdot \\nabla \\times \\mathbf{A} \\\\ \u0026= \\nabla^2 \\phi \\end{align}$$ 因此投影的重点是找到原场 \\(\\mathbf{u}^*\\) 的标势, 将其梯度从原场中剔除, 只留下矢势的旋度场 \\(\\mathbf{u} = \\nabla \\times \\mathbf{A} = \\mathbf{u}^* - \\nabla \\phi\\). 这时 \\(\\mathbf{u}\\) 是无散的. 标势 \\(\\phi\\) 可通过求解泊松方程取得 $$\\nabla^2 \\phi = \\nabla \\cdot \\mathbf{u}^*$$标量场# 一个与速度场耦合的标量场主要用于产生我们要的视觉效果, 如温度或物质浓度等. 此量随速度场迁移, 并在一定程度上改变速度分布. 以温度场为例简要说明以上两点.\n标量场的方程与一般情况下描述此量的偏微分方程极为相似, 例如无源的热传导方程 $$\\frac{\\partial T}{\\partial t} = \\kappa \\nabla^2 T$$ 这同时也是描述物质扩散的微分方程. 在具有外部的速度场时, 只需将欧拉导数替换为物质导数即可 $$\\begin{align} \u0026 \\frac{\\mathrm{D} T}{\\mathrm{D} t} = \\kappa \\nabla^2 T \\\\ =\u0026 (\\mathbf{u} \\cdot \\nabla) T + \\frac{\\partial T}{\\partial t} \u0026 \\end{align}$$求解这一方程的过程与我们上面介绍的方法完全一致. 对于其他参量, 若能写出微分方程, 也可按照上述方式改写为与速度场耦合的形式并求解.\nJ. Stam, \u0026ldquo;Real-Time Fluid Dynamics for Games\u0026rdquo;, Proceedings of the Game Developers Conference, Mar 2003\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":7,"href":"/docs/long-time-ago-a-essay/","title":"从中科大回来的时候我母亲就预言了我的今天","section":"Docs","content":"从中科大回来的时候我母亲就预言了我的今天# *邓平红 (知乎@wishkind)\n1982 年, 我不辞而别, 离开了中科大, 想要跳到长江自杀.\n因为, 当时寝室同学宋元璋在暗中联络金华的汤杰, 常熟的刘国圣给我捣鬼, 我作为中科大 826 系的学生会主席, 元旦来了, 不知道如何搞班级活动.\n同学晚上聊天到零点, 然后立即停止, 第二天六点种准时起床. 我在这种环境睡不着觉, 因为我在中学虽然是和同学睡在一个教室, 但是, 我睡觉的时候, 同学们都会睡觉, 因为, 我在中学的成绩一直是全校第一名, 我的脑筋坏了, 不能通宵达旦学习, 不能听老师念经, 我只是在有个别疑问的时候, 去找老师问问, 其它时间全是自学, 我一般只需要把课本的目录浏览, 然后, 针对疑问做几个题目, 就可以了, 所以, 我到了九点多钟就要睡觉.\n同学们也因此跟着睡觉.\n但是, 大学就不是我主宰, 寝室同学有三个在暗中捣鬼, 两个安徽的同学汤枫保持中立, 陆宁龙的父亲是芜湖师范大学的政治教授, 他劝我不要去搞文艺, 要用自己的长处对付同学的短处, 我的长处就是读书.\n但是, 我那个时候被魔鬼控制了, 自卑忧郁.\n我在临近元旦的一次考试, 微积分考了 98 分, 我就很痛苦, 我感觉脑袋有点问题, 不能做到百分之百的精确.\n我在很小时候, 仔细观察了我的鸡巴, 为何有个洞呢? 这个洞会通向什么地方? 我翻开看看, 想想到底会通向什么地方?\n等我走进大学, 翻到一本书, 说手淫会导致痴呆.\n我想, 我小时候做的就是手淫, 现在我晚上睡不着觉, 将来要变痴呆, 那是多么耻辱啊. 于是, 我终于走上了自杀的道路.\n我把学生证扔进了厕所, 然后, 买了一张船票, 我还不忘记带上我心爱的二胡.\n在船上, 我看着黑幽幽的长江, 听着单调起伏的波浪声, 我就在想, 掉进水里以后, 我会怎样呢?\n正好, 我的面前有个安徽人, 带着一只鸟, 我看到他塞了一截黄鳝给那只鸟吃, 我好奇地问他:\n\u0026ldquo;这是什么鸟?\u0026rdquo;\n他说:\n\u0026ldquo;这是鹭鸶, 又叫鱼鹰, 它会飞到风高浪急的长江叼鱼.\u0026rdquo;\n我心想:\n\u0026ldquo;这个鸟可怜吧? 它要飞到风高浪急的长江叼鱼, 然后鱼被主人拿走了, 它还要开心地活着, 我在中科大读书, 为何想死呢?\u0026rdquo;\n过了一阵, 有一群要到九江去做生意的安徽人看见了我的二胡, 他们要借去玩玩. 我就给了他们, 他们就拉起瞎子阿炳的曲子来了.\n我又想:\n\u0026ldquo;这些贩夫走卒这么开心, 我是大学生, 为何不开心? 瞎子阿炳都能坚持活着, 我为何多愁善感?\u0026rdquo;\n于是我就回到江西农村了.\n我父母在稻田里面躬腰插秧, 看见我回来了, 很吃惊.\n我父亲就赶紧去镇上给中科大发电报.\n我的母亲就说:\n\u0026ldquo;我的儿子变成逻辑秀才了.\u0026rdquo;\n我问:\n\u0026ldquo;什么是逻辑秀才?\u0026rdquo;\n我母亲说:\n\u0026ldquo;江西有个传说, 有个孩子出生之日, 算命的人对他妈说, 这个孩子长大以后会做皇帝. 于是他妈有一天洗筷子的时候, 把一手筷子在灶台上敲了一下, 恶狠狠地说东家西家得罪她的人都要咋咋咋. 灶神就上天告状, 说这个孩子不能做皇帝, 他妈太恶毒了, 连我都挨了她一百金棍. 于是玉皇大帝派天使下凡给这个孩子抽筋剥皮, 他发高烧痛得嗷嗷叫, 他妈知道得罪了上天, 就叫她儿子咬紧牙关, 所以就留下了金口玉牙. 有一天逻辑秀才走在田坎上, 被一棵草绊了一下, 他说你这个该死的草为何绊我, 还不到田里去？草说我长得矮, 在田里会被稻禾遮住阳光活不下来, 他说你不可以长高一点吗？于是草就跳进田里, 因此我们的稻田里面总会长稗子, 就是那种逻辑秀才叫它到田里生长的杂草. 这个逻辑秀才, 一生有吃有用, 嘴巴恶毒无比, 一事无成.\u0026rdquo;\n我十八岁的时候, 听母亲这么说, 而今我已经 59 岁了, 我没想到我一事无成是被网络喷子, 同济大学通天河乌龟, 我的父母, 我的岳父母, 我的老婆, 和我的女儿, 一起努力造就的, 不光是我脑筋坏了.\n如果有一个方位可以开门, 我都可以逃出升天, 为党和国家, 为人类作出重大贡献.\n今天, 我的同龄人, 功成名就的资本大佬, 庙堂神仙, 没有谁会瞧得起我, 但是, 我要告诉人类:\n\u0026ldquo;只要上天还让我活着, 就是上天在培养我, 盖棺定论. 我这生到底有没有作为, 那要等我死了之后再说, 现在还为时过早. 要知道, 这个世界是上天创造的. 我向上天祈求了五个礼物, 这五个礼物个个都是威力无穷的, 个个都可以让人类魂飞魄散, 个个都可以迅速改变人类的轨迹.\u0026rdquo;\n小记# 本文由作者 邓平红, 知乎名 @wishkind 发布于 2022 年 3 月 31 日午夜, 原链接 在此. 遗憾的是, 邓平红的账号多次被知乎封禁, 最终被永久封禁, 作品也被悉数抹除, 总计有文章两千一百多篇. 若已知文章链接, 可以在互联网历史档案馆查看存档文件.\n高二时我沉迷上课摸鱼, 在知乎上读到此文之后, 念兹在兹. 可惜毕业之后, 摸鱼的设备废弃了, 上面的数据荡然无存; 邓平红的知乎账号也被封禁, 文章悉数抹除. 我在互联网上就找不到这篇文章了.\n三年来此文的只言片语一直埋藏在我脑海中, 比如文中的中科大, 跳江, 稻田和田埂, 以及那个奇怪的外号, 时不时像裸露河床中的砂金一样闪现. 遗憾的是, 除此之外再无线索将他们串联. 这篇文章给我的印象真的非常深刻, 可能是这种略带疯癫的意识流风格所致, 以至于三年后的今天, 我又凭借一点蛛丝马迹, 将它从互联网的故纸堆中发掘了出来. 他的其他文章, 恐怕彻底散佚, 杳无踪迹了.\n三年前, 当我从这篇文章令人迷离的震撼中回过味来, 兴奋地将它截图并四处传阅时, 恐怕不知道这将是我人生中与意识流风格的首度相遇, 并影响我的艺术审美至今. 受其影响, 如今我对这种让人头晕目眩, 好像使自己抽离出身体, 在空中冷眼观察自己与周围一切的神奇风格有了浓厚兴趣. 这篇文章恐怕也不会知道, 它从作者笔下诞生, 在知乎有过昙花一现, 但很快被打入冷宫, 身死形销, 只在寥寥几处残存着虚弱的游魂, 却终有一天得以重见天日的传奇经历. 在互联网的文山中寻觅埋藏的宝藏, 是这个时代独特的浪漫.\n"},{"id":8,"href":"/docs/esp32-dev/","title":"ESP32 环境配置与开发","section":"Docs","content":"ESP32 环境配置与开发# 我必须承认, esp idf 是我配置过最困难的开发环境.\n本篇文章的开发环境选择是 Visual Studio Code 与 esp idf. 以 微雪电子 ESP32-S3-Nano 开发板 为例; 这款开发板理论上与 Arduino Nano esp32 开发板完全兼容. 在 这里 可以找到 Arduino 开发板的引脚定义.\nesp idf 安装与配置# esp idf 有两种安装途径: 通过官方安装器; 或是通过 VSCode 插件安装.\n上述两种方式安装的 esp idf 互不兼容.\n鉴于我们将在 VSCode 中进行开发, 所以最好选择第二种: 通过插件安装.\n具体的安装过程可以在 官方教程 找到.\n安装 USB 设备驱动# 安装 Zadig. 启动它, 选择 Options \u0026gt; List All Devices. 此时应该能在下拉菜单中找到两个 USB JTAG/serial debug unit, 分别以 Interface 0 与 Interface 2 区分. 下面分别设置这两个的驱动.\n首先选择 USB JTAG/serial debug unit (Interface 0), 将驱动替换为 USB Serial (CDC).\n然后选择 USB JTAG/serial debug unit (Interface 2), 将驱动替换为 WinUSB (v6.x).\n如果你的驱动与上面所写的不一致 (USB Serial (CDC) 也显示为 usbser), 你这时应该点击 Replace Driver. 如果按钮为 Install WCID Driver, 你应当在下拉菜单中仔细寻找一番.\n对于 Interface 2, 驱动版本也要严格对应于 v6.x. 更高的版本可能导致问题.\n全部完成后, 可以打开设备管理器, 查看下面两个字段: 端口 (COM 和 LPT), 应该包含一个 USB 串行设备 (COMx), x 表示数字不确定; 通用串行总线设备, 应该包含一个 USB JTAG/serial debug unit.\n经过上面的配置, 能够得到一个串口和一个 JTAG. 其中串口用于通讯, JTAG 用于调试, 两者都可以用于烧录程序. 所以两者缺一不可.\n如果上面驱动设置过程中出现错误, 以至于更换驱动出错, 可以考虑重置所有驱动, 而后重新来过. 彻底重置这两个 Interface 的驱动按下面的步骤进行:\n打开设备管理器, 分别定位到这两个 Interface.\n它们应该只会在 端口 (COM 和 LPT) 和 通用串行总线设备 这两个字段中. 右键, 卸载设备, 勾选上 删除此设备的驱动程序软件, 点击 卸载. 拔掉开发板. 重启计算机. 插入开发板, 此时驱动应该已经被重置. 重新配置驱动. 调试# 在进行下面的操作之前, 请检查驱动是否配置正确.\n在 VSCode 中, 按 Ctrl+Shift+P 打开命令面板, 输入 ESP-IDF: Add VS Code Configuration Folder, 获取预设的运行与调试文件.\n检查设置: 打开 .vscode/settings.json, 检查 idf 相关字段. 两个字段的值应该如下所示.\n\u0026#34;idf.openOcdConfigs\u0026#34;: [ \u0026#34;board/esp32s3-builtin.cfg\u0026#34; ], \u0026#34;idf.customExtraVars\u0026#34;: { \u0026#34;IDF_TARGET\u0026#34;: \u0026#34;esp32s3\u0026#34; },上述都配置好后, 直接在调试菜单里点击 Eclipse CDT GDB Adapter 即可开始调试.\n疑难杂症# 库头文件 (如 stdio.h) 无法被导入.\n打开 .vscode/settings.json, 找到 clangd 相关的字段 clangd.path clangd.arguments. 如果里面的绝对路径以小写的磁盘标识符开头, 如 d:\\\\\\\\opt\\\\\\\\..., 将其改为大写: D:\\\\\\\\opt\\\\\\\\...; 而后重启 VSCode (或重新加载窗口). C 库头文件可以被导入, 但是 C++ 库头文件无法导入.\n在 .vscode/settings.json 的 clangd.arguments 中找到标志 --query-driver, 添加上 C++ 的编译器.\n如果你原来形如 --query-driver=...\\\\\\\\xtensa-esp32s3-elf-gcc.exe, 添加后应该类似 --query-driver=...\\\\\\\\xtensa-esp32s3-elf-gcc.exe,...\\\\\\\\xtensa-esp32s3-elf-g++.exe. 一般上面两个编译器在同一目录下. 烧录时出现 PermissionError(13, '连到系统上的设备没有发挥作用。', None, 31) 报错.\n检查端口, 是否是串口烧录. 若都无误, 你应该将引脚 B1, 也就是 GPIO0 置为低电平, 重置开发板后再次烧录. 运行 monitor 时出现 waiting for download.\n如果 B1 仍被置低, 将它归位为高电平. 只需取消 B1 与 GND 的短接即可. 调试时出现 LIBUSB_ERROR_NOT_FOUND.\n检查驱动配置情况. 尤其着重检查 Interface 2 的 WinUSB 驱动版本是否为 v6.x. 若更高, 将其替换为此版本. 我想使用硬件 JTAG 进行调试.\n可以, 但是我不知道具体怎么做. 我唯一可以给你的提示是:\n此开发板的硬件 JTAG 接口在背面尾部的空焊盘上, 可以检查引脚定义表来获取具体信息. "},{"id":9,"href":"/docs/mahony-complementary-filter/","title":"Mahony 非线性互补滤波器","section":"Docs","content":"Mahony 非线性互补滤波器# Mahony 互补滤波算法是一种成熟的姿态估计算法, 旨在融合多种传感器的数据来估计最优姿态. 本篇文章将介绍这一滤波器的数学推导与应用.\n在第一章中, 我们先约定文章中使用的符号, 并对不同传感器的数据进行建模; 第二章, 从刚体的运动学入手, 使用李群与李代数作为分析工具; 第三章介绍优化姿态的方法, 并引出两个滤波器: 直接互补滤波器 (Direct Complementary Filter) 与被动互补滤波器 (Passive Complementary Filter); 第四章在被动互补滤波器的基础上讨论更方便的向量版本, 称为显式互补滤波器 (Explicit Complementary Filter); 在第五章中, 我们进一步讨论显式互补滤波器的四元数版本. 本文将不涉及系统的 Lyapunov 稳定性分析.\n本文主要编译自 Mahony 等人发表在 IEEE Transactions on Automatic Control 上的论文1.\n符号约定与传感器数据建模# 文章中 \\([\\cdot]_\\times\\) 表示向量的外积矩阵, 它是一个反对称矩阵. 使用 \\(\\dot{R} := \\partial R := \\frac{\\mathrm{d} R}{\\mathrm{d} t}\\) 表示求导. 线性函数 \\(\\mathrm{vex}(\\cdot)\\) 表示将李代数, 即反对称矩阵转为向量; 类似地, 我们有 \\(\\mathrm{wedge}(\\cdot)\\) 将向量转为李代数. 另外, 约定线性函数 \\(\\mathbb{P}_a(A) := \\frac{1}{2} (A - A^T)\\) 将矩阵映射为一个反对称矩阵.\n自然地约定两个参考坐标系, \\(\\{A\\}\\) 表示世界全局坐标系, \\(\\{B\\}\\) 表示固连于刚体上的局部左标系; 另外, 我们还约定 \\(\\{E\\}\\) 为估计后的局部坐标系, 它被表示为与 \\(\\{B\\}\\) 固定于同一点, 但是姿态稍有变化.\n矩阵 \\(\\sideset{_A^B}{}R\\) 表示从 \\(\\{A\\}\\) 向 \\(\\{B\\}\\) 的坐标变换, 同时也是 \\(\\{B\\}\\) 在 \\(\\{A\\}\\) 中的姿态. 我们也为其中的几个代表另取简洁且富有深意的代号: 原始位姿 \\(R_y := \\sideset{_B^A}{}R\\); 估计后的位姿 \\(\\hat{R} := \\sideset{_E^A}{}R\\) 以及描述 \\(\\{B\\}\\) 与 \\(\\{E\\}\\) 的误差 \\(\\tilde{R} := \\sideset{_B^E}{}R = \\hat{R}^T R_y\\). 因为三个参考坐标系都是归一化正交右手坐标系, 因此上述矩阵皆为正交矩阵, 且行列式为正.\n陀螺仪# 陀螺仪测量的是在 \\(\\{B\\}\\) 中的, 刚体绕过测量中心的一轴的角速度 \\(\\mathbf{\\Omega}^y\\), 带有偏置 \\(\\mathbf{b}\\) 与噪声 \\(\\mathbf{\\mu}\\). 测量值与真实值 \\(\\mathbf{\\Omega} \\in \\{B\\}\\) 的关系可以表示为 $$\\mathbf{\\Omega}^y = \\mathbf{\\Omega} + \\mathbf{b} + \\mathbf{\\mu}$$加速度计# 加速度计测量加速度方向, 同样带有偏置 \\(\\mathbf{b}_a\\) 和噪声 \\(\\mathbf{\\mu}_a\\). 因为受重力的缘故, 加速度计测量的始终是比力 (Specific Force), 即刚体的绝对加速度与重力加速度之和. 于是测量得到的 \\(\\{B\\}\\) 中的加速度 \\(\\mathbf{a}\\) 可以表示为 $$\\mathbf{a} = R_y^T (\\sideset{^A}{}{\\dot{\\mathbf{v}}} - \\mathbf{g}_0) + \\mathbf{b}_a + \\mathbf{\\mu}_a$$磁力计# 同样地, 有偏置 \\(\\mathbf{B}_m\\) 与噪声 \\(\\mathbf{\\mu}_b\\), 测量值 \\(\\mathbf{m} \\in \\{B\\}\\) 与真实值 \\(\\sideset{^A}{}{\\mathbf{m}}\\) 的关系为 $$\\mathbf{m} = R_y^T \\sideset{^A}{}{\\mathbf{m}} + \\mathbf{B}_m + \\mathbf{\\mu}_b$$刚体运动学# 我们知道刚体旋转有 \\(R = \\mathrm{e}^{[\\Omega]_\\times t}\\), 于是 \\(\\dot{R} = \\partial \\mathrm{e}^{[\\Omega]_\\times t} = \\mathrm{e}^{[\\Omega]_\\times t} [\\Omega]_\\times = R [\\Omega]_\\times\\).\n进一步地, 因为 \\([R \\Omega]_\\times = R [\\Omega]_\\times R^T\\), 有 $$\\dot{R} = [R \\Omega]_\\times R$$姿态估计# 文章的中心问题, 也就是姿态估计的中心任务, 是如何求出估计后姿态 \\(\\hat{R}\\) 的微分, 以便通过积分来实时确定姿态, 同时确保误差 \\(\\tilde{R}\\) 最小.\n通过上面的运动学分析, 可以得出 \\(\\dot{\\hat{R}} = [R_y \\Omega]_\\times \\hat{R}\\), 这其中作用于 \\(\\Omega\\) 的矩阵为 \\(R_y\\) 而非 \\(\\hat{R}\\), 是因为 \\(\\Omega\\) 所在的参考系为 \\(\\{B\\}\\), 这给了我们设计滤波器方面的一些灵活性.\n可以证明, 此时误差 \\(\\tilde{R}\\) 恒定 $$\\begin{align} \\dot{\\tilde{R}} \u0026= \\partial (\\hat{R}^T R_y) \\\\ \u0026= \\dot{\\hat{R}}^T R_y + \\hat{R}^T \\dot{R_y} \\\\ \u0026= ([R_y \\Omega]_\\times \\hat{R})^T R_y + \\hat{R}^T [R_y \\Omega]_\\times R_y \\\\ \u0026= \\hat{R}^T [R_y \\Omega]_\\times^T R_y + \\hat{R}^T [R_y \\Omega]_\\times R_y \\\\ \u0026= 0 \\end{align}$$为了消除误差, 我们通过添加一项关于误差的函数 \\(\\omega := \\omega(\\tilde{R})\\) 来引入负反馈 $$\\dot{\\hat{R}} = [R_y \\Omega + k_P \\omega]_\\times \\hat{R}$$滤波器设计的核心在于函数 \\(\\omega(\\tilde{R})\\) 的选取. Mahony 等人提出的方案是 $$\\begin{align} \\sideset{^E}{}\\omega \u0026= \\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R}) \\\\ \\sideset{^A}{}\\omega \u0026= \\hat{R} ~ \\sideset{^E}{}\\omega \\end{align}$$如此一来我们有 $$\\begin{align} \u0026 [R_y \\Omega + k_P \\hat{R} ~ \\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R})]_\\times \\\\ =\u0026 ~ [R_y \\Omega]_\\times + k_P [\\hat{R} ~ \\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R})]_\\times \\\\ =\u0026 ~ [R_y \\Omega]_\\times + k_P \\hat{R} [\\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R})]_\\times \\hat{R}^T \\\\ =\u0026 ~ [R_y \\Omega]_\\times + k_P \\hat{R} \\mathbb{P}_a(\\tilde{R}) \\hat{R}^T \\\\ =\u0026 ~ [R_y \\Omega]_\\times + k_P \\mathbb{P}_a(R_y \\hat{R}^T) \\end{align}$$ $$\\dot{\\hat{R}} = ([R_y \\Omega]_\\times + k_P \\mathbb{P}_a(R_y \\hat{R}^T)) \\hat{R}$$可以证明, 引入的负反馈的确使得误差 \\(\\tilde{R}\\) 收敛于 \\(I\\). 为了证明这一点, 引入优化变量 \\(E := \\frac{1}{2} \\|I - \\tilde{R}\\|_F^2 = \\mathrm{tr}(I - \\tilde{R})\\), 对其求导得 \\(\\partial E = \\partial ~ \\mathrm{tr}(I - \\tilde{R}) = -\\mathrm{tr} ~ \\partial \\tilde{R}\\). \\(\\tilde{R}\\) 的导数如下求得 $$\\begin{align} \\dot{\\tilde{R}} \u0026= \\partial (\\hat{R}^T R_y) \\\\ \u0026= \\dot{\\hat{R}}^T R_y + \\hat{R}^T [R_y \\Omega]_\\times R_y \\\\ \u0026= \\hat{R}^T ([R_y \\Omega]_\\times + k_P \\mathbb{P}_a(R_y \\hat{R}^T))^T R_y + \\hat{R}^T [R_y \\Omega]_\\times R_y \\\\ \u0026= - k_P \\hat{R}^T \\mathbb{P}_a(R_y \\hat{R}^T) R_y \\\\ \u0026= \\frac{1}{2} k_P (I - \\tilde{R}^2) \\end{align}$$ 于是有 $$\\begin{align} \\partial E \u0026= - \\mathrm{tr} ~ \\dot{\\tilde{R}} \\\\ \u0026= - \\frac{1}{2} \\mathrm{tr} ~ k_P (I - \\tilde{R}^2) \\\\ \u0026= - \\frac{1}{2} k_P ~ \\mathrm{tr} (\\cos{\\theta} - 1) [\\hat{n}]_\\times^2 \\\\ \u0026= - \\frac{1}{2} k_P (\\cos{\\theta} - 1) (-2 \\|\\hat{n}\\|^2) \\\\ \u0026= - k_P (1 - \\cos{\\theta}) \\\\ \u0026 \\leq 0 \\end{align}$$ 上面证明中用到的旋转矩阵计算公式可以在 这里 中找到. 当且仅当 \\(\\tilde{R}^2\\) 的转角 \\(\\theta = 0, 2\\pi\\) 时取等号, 即 \\(\\tilde{R}\\) 转角为 \\(0\\) 或 \\(\\pi\\) 时. 对于转角为 \\(\\pi\\) 的特殊情况在论文中做了详细讨论. 我们可以认为, 在 \\(\\tilde{R} \\neq I\\) 时 \\(E\\) 单调递减, 且有下界 \\(0\\), 于是其必收敛于 \\(0\\), 这样就证明了 \\(\\tilde{R}\\) 将收敛于 \\(I\\).\n附加上关于陀螺仪偏置 \\(\\mathbf{b}\\) 的估计, 我们可以引出直接互补滤波器: $$\\boxed{\\begin{align} \\dot{\\hat{R}} \u0026= ([R_y (\\Omega^y - \\hat{b})]_\\times + k_P \\mathbb{P}_a(R_y \\hat{R}^T)) \\hat{R} \\\\ \\dot{\\hat{b}} \u0026= - k_I \\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R}) \\end{align}}$$其中 \\(R_y\\) 作为系统输入, 来自一个优化问题: $$R_y = \\arg \\underset{R \\in SO(3)}{\\min} (\\lambda_1 \\| \\mathbf{e}_3 - R \\mathbf{v}_a \\|^2 + \\lambda_2 \\| \\mathbf{v}_m^* - R \\mathbf{v}_m \\|^2)$$ 考虑到求解此问题的复杂性, 直接互补滤波器并不便于使用.\n我们做近似 \\(\\hat{R} \\sim R_y\\), 这是基于 \\(\\{B\\}\\) 与 \\(\\{E\\}\\) 通常十分接近的假设. 这样有 $$\\begin{align} \\dot{\\hat{R}} \u0026= [\\hat{R} \\Omega + k_P \\omega]_\\times \\hat{R} \\\\ \u0026= ([\\hat{R} \\Omega]_\\times + k_P \\mathbb{P}_a(R_y \\hat{R}^T)) \\hat{R} \\\\ \u0026= \\hat{R} ([\\Omega]_\\times + k_P \\mathbb{P}_a (\\tilde{R})) \\end{align}$$接下来我们确认近似的正确性, 通过计算上式是否收敛来检验: $$\\begin{align} \\dot{\\tilde{R}} \u0026= \\dot{\\hat{R}}^T R_y + \\hat{R}^T \\dot{R_y} \\\\ \u0026= (\\hat{R} ([\\Omega]_\\times + k_P \\mathbb{P}_a (\\tilde{R})))^T R_y \\ + \\hat{R}^T R_y [\\Omega]_\\times \\\\ \u0026= ([\\Omega]_\\times + k_P \\mathbb{P}_a (\\tilde{R}))^T \\hat{R}^T R_y \\ + \\hat{R}^T R_y [\\Omega]_\\times \\\\ \u0026= - [\\Omega]_\\times \\tilde{R} + k_P \\mathbb{P}_a (\\tilde{R}^T) \\tilde{R} + \\tilde{R} [\\Omega]_\\times \\\\ \u0026= - [\\Omega]_\\times \\tilde{R} + \\tilde{R} [\\Omega]_\\times + \\frac{k_P}{2} (I - \\tilde{R}^2) \\end{align}$$ \\(\\partial E = - \\mathrm{tr} ~ \\dot{\\tilde{R}} = - \\frac{1}{2} \\mathrm{tr} ~ k_P (I - \\tilde{R}^2)\\), 与上面直接互补滤波器的结果一致, 于是收敛性也得到保证.\n这一结果被称为被动互补滤波器: $$\\boxed{\\begin{align} \\dot{\\hat{R}} \u0026= \\hat{R} ([\\Omega^y - \\hat{b}]_\\times + k_P \\mathbb{P}_a (\\tilde{R})) \\\\ \\dot{\\hat{b}} \u0026= - k_I \\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R}) \\end{align}}$$因为滤波器内含有 \\(\\tilde{R}\\), 包含对 \\(R_y\\) 的依赖, 于是使用同样受到限制.\n显式互补滤波器# 在被动互补滤波器的基础上, 我们消除对 \\(R_y\\) 的显式依赖, 通过直接使用方向向量来构筑滤波器. 这被称为显式互补滤波器.\n假如我们有 \\(n\\) 组可以确定的方向, 它们可以来自重力方向以及磁场方向等, 记为 \\(\\mathbf{v}_{0i} \\in \\{A\\}\\), 另外要求它们是归一化的. 于是我们可以得到在 \\(\\{B\\}\\) 中的方向 \\(\\mathbf{v}_i = R^T \\mathbf{v}_{0i}\\), 以及 \\(\\{E\\}\\) 中的方向 \\(\\hat{\\mathbf{v}}_i = \\hat{R}^T \\mathbf{v}_{0i}\\). 我们不妨令第 \\(i\\) 个估计方向与实际方向的误差为 \\(E_i = 1 - \\mathbf{v}_i^T \\hat{\\mathbf{v}}_i\\). 另外, 引入权重 \\(k_i\\) 表征特定参考方向的不确定性, 若其置信度较低, 则 \\(k_i\\) 值应该较小, 以此减小此方向引入的误差. 综上, 令此时的总误差为 $$\\begin{align} E' \u0026= \\sum_i k_i E_i \\\\ \u0026= \\sum_i k_i (1 - \\mathbf{v}_i^T \\hat{\\mathbf{v}}_i) \\\\ \u0026= \\sum_i k_i - \\sum_i k_i \\mathbf{v}_i^T \\hat{\\mathbf{v}}_i \\end{align}$$ 其中 $$\\begin{align} \\sum_i k_i \\mathbf{v}_i^T \\hat{\\mathbf{v}}_i \u0026= \\ \\mathrm{tr} \\sum_i k_i \\mathbf{v}_i^T \\hat{\\mathbf{v}}_i \\\\ \u0026= \\mathrm{tr} \\sum_i k_i \\hat{\\mathbf{v}}_i \\mathbf{v}_i^T \\\\ \u0026= \\mathrm{tr} \\sum_i k_i (\\hat{R}^T \\mathbf{v}_{0i}) (R^T \\mathbf{v}_{0i})^T \\\\ \u0026= \\mathrm{tr} \\sum_i k_i \\hat{R}^T \\mathbf{v}_{0i} \\mathbf{v}_{0i}^T R \\\\ \u0026= \\mathrm{tr} ~ \\hat{R}^T R \\sum_i k_i R^T \\mathbf{v}_{0i} \\mathbf{v}_{0i}^T R \\\\ \u0026= \\mathrm{tr} ~ \\tilde{R} M, ~~ M = R^T (\\sum_i k_i \\mathbf{v}_{0i} \\mathbf{v}_{0i}^T) R \\end{align}$$从上面也可以看出 \\(\\tilde{R} M = \\sum_i k_i \\hat{\\mathbf{v}}_i \\mathbf{v}_i^T\\).\n此时 \\(E' = \\sum_i k_i - \\mathrm{tr} ~ \\tilde{R} M\\) 的形态已经与上述 \\(E = \\mathrm{tr} (I - \\tilde{R}) = 3 - \\mathrm{tr} ~ \\tilde{R}\\) 极为相似. 仿照 \\(\\sideset{^E}{}\\omega(\\tilde{R}) = \\mathrm{vex} ~ \\mathbb{P}_a(\\tilde{R})\\), 我们令 $$\\begin{align} \\omega \u0026= \\mathrm{vex} ~ \\mathbb{P}_a (\\tilde{R} M) \\\\ \u0026= \\frac{1}{2} \\mathrm{vex} (\\tilde{R} M - M^T \\tilde{R}^T) \\\\ \u0026= \\frac{1}{2} \\mathrm{vex} \\sum_i k_i (\\hat{\\mathbf{v}}_i \\mathbf{v}_i^T - \\mathbf{v}_i \\hat{\\mathbf{v}}_i^T) \\\\ \u0026= \\frac{1}{2} \\mathrm{vex} \\sum_i k_i [\\mathbf{v}_i \\times \\hat{\\mathbf{v}}_i]_\\times \\\\ \u0026= \\frac{1}{2} \\sum_i k_i ~ \\mathbf{v}_i \\times \\hat{\\mathbf{v}}_i \\end{align}$$ 用到的引理 \\(\\mathbf{a} \\mathbf{b}^T - \\mathbf{b} \\mathbf{a}^T = [\\mathbf{b} \\times \\mathbf{a}]_\\times\\) 我们不再证明.\n将其代入被动互补滤波器, 就得到了显式互补滤波器: $$\\boxed{\\begin{align} \\dot{\\hat{R}} \u0026= \\hat{R} ([\\Omega^y - \\hat{b}]_\\times + k_P [\\omega]_\\times) \\\\ \\dot{\\hat{b}} \u0026= - k_I \\omega \\\\ \\text{where} \\\\ \\omega \u0026= \\sum_i \\frac{k_i}{2} ~ \\mathbf{v}_i \\times \\hat{\\mathbf{v}}_i \\\\ \\hat{\\mathbf{v}}_i \u0026= \\hat{R}^T ~ \\mathbf{v}_{0i} \\end{align}}$$四元数滤波运动学# 单位四元数可用于描述旋转, 它们构成群 \\(S^3\\), 并且与 \\(SO(3)\\) 之间存在一个自然的群同态. 其中的元素表示为 \\(q = [\\cos{\\frac{\\Omega}{2}}, \\sin{\\frac{\\Omega}{2}} ~ \\hat{\\mathbf{n}}] \\in S^3\\), 它表示了绕单位轴 \\(\\hat{\\mathbf{n}}\\) 旋转 \\(\\Omega\\).\n将旋转作用在向量上这一动作用四元数表示为 \\(q \\mathbf{v} q^*\\), 其中 \\(q^*\\) 表示 \\(q\\) 的共轭. 特殊地, 旋转矩阵的转置对应于四元数的共轭, 它们都是因为这一操作在各自的约束下与取逆等价. 注意, 这里的向量 \\(\\mathbf{\\Omega}\\) 都是纯虚四元数 \\(\\mathbf{\\Omega} = \\Omega_x \\mathrm{i} + \\Omega_y \\mathrm{j} + \\Omega_z \\mathrm{k}\\), 下同.\n另外, 可以得到 \\(S^3\\) 中元素的李代数指数表示 \\(q = \\exp{\\frac{\\Omega}{2} \\hat{\\mathbf{n}} t} = \\exp{\\mathbf{\\Omega} t/2}\\). 于是运动学方程为 $$\\dot{q} = q \\frac{\\mathbf{\\Omega}}{2}$$注意到显式互补滤波器 \\(\\dot{\\hat{R}} = \\hat{R} ~ [\\Omega^y - \\hat{b} + k_P \\omega]_\\times\\) 与矩阵运动学 \\(\\dot{R} = R ~ [\\Omega]_\\times\\) 之间的联系, 基于四元数运动学的显式互补滤波器可以被自然地导出: $$\\boxed{\\begin{align} \\dot{\\hat{q}} \u0026= \\frac{1}{2} \\hat{q} ~ (\\Omega^y - \\hat{b} + k_P \\omega) \\\\ \\dot{\\hat{b}} \u0026= - k_I \\omega \\\\ \\text{where} \\\\ \\omega \u0026= \\sum_i \\frac{k_i}{2} ~ \\mathbf{v}_i \\times \\hat{\\mathbf{v}}_i \\\\ \\hat{\\mathbf{v}}_i \u0026= \\hat{q}^* ~ \\mathbf{v}_{0i} ~ \\hat{q} \\end{align}}$$定义四元数乘法使用的 Graßmann 积也摘录在此: 对于四元数 \\(q_1 = [u_1, \\mathbf{v}_1]\\), \\(q_2 = [u_2, \\mathbf{v}_2]\\), $$q_1 q_2 = [u_1 u_2 - \\mathbf{v}_1 \\cdot \\mathbf{v}_2, ~ u_2 \\mathbf{v}_1 + u_1 \\mathbf{v}_2 + \\mathbf{v}_1 \\times \\mathbf{v}_2]$$后记# 就本文所介绍的三种滤波器以及一种变种来说, 通常而言使用最广泛的是显式互补滤波器及其四元数版本, 通称 Mahony 互补滤波器也是指这两者.\n在实际使用中, 对于传感器的数据进行预处理是十分有必要的, 例如剔除加速度计的高频分量来获得稳定的重力方向. 此外, 在估计过程中动态调整不同传感器方向的权重也是规避误差的有效方法.\n当已知方向数量在 \\(2\\) 个及以上时, 滤波器在理论上是稳定的. 当参考方向只有 \\(1\\) 个, 例如只有重力方向时, 在正交方向会产生漂移, 此时这一方向上的估计全部依赖于角速度输入. 当没有参考方向时, 滤波器完全退化为对角速度积分.\n滤波器给出的输出为估计姿态与偏置的导数, 通过积分可以得到姿态与偏置. 在实际应用中, 离散化的积分因为步长精度原因, 不可避免地会引入截断误差. 此时需要对位姿进行优化来满足约束. 对于矩阵运动学, 优化过程归结为求解最近旋转矩阵问题, 也就是将稍有偏差的矩阵映射为严格的 \\(SO(3)\\) 中的元素. 对于四元数运动学, 因为四元数只有 \\(4\\) 个自由度, 冗余的自由度不足以优化旋转所需的 \\(3\\) 个自由度, 我们只能选取一个参量来进行优化. 通常而言选择约束转角, 可以证明, 这等价于对四元数进行归一化.\nR. Mahony, T. Hamel, and J.-M. Pflimlin, \u0026ldquo;Nonlinear Complementary Filters on the Special Orthogonal Group\u0026rdquo;, IEEE Transactions on Automatic Control, vol. 53, no. 5, pp. 1203\u0026ndash;1217, May 2008, doi: 10.1109/TAC.2008.923738.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":10,"href":"/docs/async-serial/","title":"异步非阻塞串口数据接收","section":"Docs","content":"异步非阻塞串口数据接收# 异步?# 异步 (asynchronous) 编程是一种并发的编程模式, 可以有效节省 CPU 阻塞等待 I/O 事件造成的时间浪费, 借以提高性能.\n在这里也简单介绍一下 并行 (parallel) 与 并发 (concurrent) 的区别. 并发是指多个任务可以被同时运行的现象; 但需要注意的是, 并发在某一时刻可能并不一定有多个任务在运行. 但是并行是严格的多线程工作模式, 在某一时刻有多个任务在同时工作. 于是很容易看出, 并行也被包含在并发之中.\n异步的核心在于一个字 \u0026ldquo;等\u0026rdquo;. 简而言之, 异步编程好似去食堂窗口买饭, 当你告诉他你要点的餐以后, 不是一定要在窗口前等着, 而是可以去做点别的事情, 比如买瓶饮料什么的, 直到老板通知你取餐, 这就是一次异步事件. 在编程时我们调用一个异步 API, 若它不能立刻返回结果, 那么也不会阻塞等待, 而是立刻向后执行; 直到获取到结果再通知我们进行处理.\n不同的语言有各色的异步支持, JavaScript 和 Rust 的异步模型都很有代表性. JavaScript 中, 异步函数可以返回一个 Promise 对象, 其名字形象地说明了它的功能: 我承诺完成你要的操作; 潜台词则是我保证 将来 会完成你要的操作, 不一定是立刻做到. Rust 的 Future 机制则更为直白: 你的任务我将来会完成的.\n非多线程的异步程序的本质是 CPU 的 时分复用, 它用划分时间片交替运行各项任务来模拟同时运行每项任务. 必须指出, 有些语言实际上使用多线程实现的异步, 在这种情况下可以实现真正的并行, 即每个时刻多项任务同时被运行. 于是很容易推断, 若 CPU 本来就没有空闲时间, 那么非多线程的异步也并不能提高效率. 这也是为什么异步大多都被用于 I/O 操作, 因为可以有效利用好 I/O 事件中因为等待而空闲的 CPU 时间. 若是 CPU 密集型的工作, 例如科学计算等, 使用异步模型反而会因为时间片切换而损失性能. 这种情况更适合用多线程的方法提高效率.\n异步模型的通知机制, 也就是当任务完成时如何处理结果, 是各种异步模型要解决的核心问题, 不同的解决方案也催生出不同的异步模型. 最为简单的方法自然是传递一个回调函数, 当任务完成时调用回调来处理结果. 这也被称为 事件驱动 (Event Driven) 模型.\nlibuv 使用# libuv 是 c 语言编写的强调异步 I/O 的多平台支持库. 我们的目标是使用它编写异步的接收串口数据程序.\n我们以异步打开文件来举例:\nuv_fs_t open_req; void on_open(uv_fs_t *req) { if (req-\u0026gt;result \u0026gt;= 0) { // do something... } } int main() { const char* fname = \u0026#34;/...\u0026#34;; uv_fs_open(uv_default_loop(), \u0026amp;open_req, fname, O_RDONLY, 0, on_open); uv_run(uv_default_loop(), UV_RUN_DEFAULT); uv_fs_req_cleanup(\u0026amp;open_req); return 0; }"},{"id":11,"href":"/docs/rigid-movement/","title":"三维空间中刚体运动的描述","section":"Docs","content":"三维空间中刚体运动的描述# 刚体运动由旋转与平移组成, 与旋转类似, 可以用矩阵来表示: $$ T = \\begin{pmatrix} R \u0026 \\mathbf{\\rho} \\\\ \u0026 1 \\end{pmatrix} $$ 其中 \\(R\\) 是旋转矩阵, \\(\\mathbf{v}\\) 是表征平移的向量. 刚体运动矩阵作用于三维向量的齐次坐标上.\n同样与旋转类似, 所有刚体运动矩阵构成一个群, 称为 特殊欧氏群 \\(SE(3)\\).\n\\(SE(3)\\) 也是一个 李群, 它的 李代数 \\(\\mathfrak{se} (3)\\) 中的元素为如下形式: $$\\begin{pmatrix} \\theta [\\hat{\\mathbf{\\omega}}]_\\times \u0026 \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix}$$ 这里 \\([\\hat{\\mathbf{\\omega}}]_\\times\\) 表示单位向量的外积矩阵.\n本篇文章的工作是推导 \\(SE(3)\\), \\(\\mathfrak{se}(3)\\) 与 \\(\\mathbb{R}^6\\) 中元素的互相转换. \\(\\mathbb{R}^6\\) 中的元素也被称为 运动旋量.\n引理# $$ \\begin{pmatrix} \\theta [\\hat{\\mathbf{\\omega}}]_\\times \u0026 \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix}^n = \\begin{pmatrix} \\theta^n [\\hat{\\mathbf{\\omega}}]_\\times^n \u0026 \\theta^{n-1} [\\hat{\\mathbf{\\omega}}]_\\times^{n-1} \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix} $$直接计算便可得到.\n对于多项式 \\(f(x)\\) 与矩阵 \\(A\\), \\(f(A)\\) 可逆当且仅当 \\(A\\) 的所有特征值都不是 \\(f(x)\\) 的根, 且此时 \\(f(A)^{-1}\\) 也是关于 \\(A\\) 的多项式.\n若 \\(\\forall \\lambda; f(\\lambda) \\neq 0\\), 此时 \\(f(x)\\) 与 \\(g(x)\\) 互质, 其中 \\(g(\\lambda) := \\det{(\\lambda I - A)}\\) 是 \\(A\\) 的特征多项式. 于是有 \\(f(x) ~ u(x) + g(x) ~ v(x) = 1\\). 不定元用 \\(A\\) 代入, 可知 \\(f(A) ~ u(A) + g(A) ~ v(A) = I\\). 由 凯莱-哈密顿定理, \\(g(A) = 0\\). 进而 \\(f(A) ~ u(A) = I\\). 因此 \\(f(A)\\) 可逆, 且它的逆是 \\(A\\) 的多项式形式.\n正文# $$\\begin{align} \\wedge: \\mathbb{R}^6 \u0026\\rightarrow \\mathfrak{se}(3) \\\\ \\mathbf{\\xi} \u0026\\mapsto \\mathbf{\\xi}^\\wedge \\end{align}$$对于 \\(\\mathbf{\\xi} = (\\theta \\hat{\\mathbf{\\omega}}, \\mathbf{v})^T\\), 直接可以得到 $$ \\mathbf{\\xi}^\\wedge = \\begin{pmatrix} \\theta [\\hat{\\mathbf{\\omega}}]_\\times \u0026 \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix} $$ 式中 \\([\\cdot]_\\times\\) 记号与 旋转 一文一致.\n$$\\begin{align*} \\mathrm{exp}: \\mathfrak{se}(3) \u0026\\rightarrow SE(3) \\\\ \\mathbf{\\xi}^\\wedge \u0026\\mapsto T \\end{align*}$$按 \\(\\mathrm{exp}\\) 的级数定义:\n$$\\begin{align*} \\exp{\\mathbf{\\xi}^\\wedge} \u0026= \\sum_{i=0} \\frac{1}{i!} (\\mathbf{\\xi}^\\wedge)^i \\\\ \u0026= I + \\sum_{i=1} \\frac{1}{i!} \\begin{pmatrix} \\theta^i [\\hat{\\mathbf{\\omega}}]_\\times^i \u0026 \\theta^{i-1} [\\hat{\\mathbf{\\omega}}]_\\times^{i-1} \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix} \\\\ \u0026= I + \\begin{pmatrix} \\sum_{i=1} \\frac{\\theta^i}{i!} [\\hat{\\mathbf{\\omega}}]_\\times^i \u0026 (\\sum_{i=1} \\frac{\\theta^{i-1}}{i!} [\\hat{\\mathbf{\\omega}}]_\\times^{i-1}) \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix} \\\\ \u0026= \\begin{pmatrix} \\sum_{i=0} \\frac{\\theta^i}{i!} [\\hat{\\mathbf{\\omega}}]_\\times^i \u0026 (\\sum_{i=0} \\frac{\\theta^i}{(i+1)!} [\\hat{\\mathbf{\\omega}}]_\\times^i) \\mathbf{v} \\\\ \u0026 1 \\end{pmatrix} \\\\ \u0026= \\begin{pmatrix} \\exp{\\theta [\\hat{\\mathbf{\\omega}}]_\\times} \u0026 J \\mathbf{v} \\\\ \u0026 1 \\end{pmatrix} \\end{align*}$$其中\n$$\\begin{align*} J \u0026= \\sum_{i=0} \\frac{\\theta^i}{(i+1)!} [\\hat{\\mathbf{\\omega}}]_\\times^i \\\\ \u0026= \\frac{1}{\\theta} \\sum_{i=1} \\frac{\\theta^i}{i!} [\\hat{\\mathbf{\\omega}}]_\\times^{i-1} \\\\ \u0026= \\frac{1}{\\theta} (\\theta I + \\frac{\\theta^2}{2!} [\\hat{\\mathbf{\\omega}}]_\\times + \\frac{\\theta^3}{3!} [\\hat{\\mathbf{\\omega}}]_\\times^2 + \\cdots) \\\\ \u0026= \\frac{1}{\\theta} (\\theta I + (\\frac{\\theta^2}{2!} - \\frac{\\theta^4}{4!} + \\cdots) [\\hat{\\mathbf{\\omega}}]_\\times - (\\frac{\\theta^3}{3!} - \\frac{\\theta^5}{5!} + \\cdots) [\\hat{\\mathbf{\\omega}}]_\\times^2) \\\\ \u0026= I + \\theta^{-1} (1-\\cos{\\theta}) [\\hat{\\mathbf{\\omega}}]_\\times + (1-\\theta^{-1} \\sin{\\theta}) [\\hat{\\mathbf{\\omega}}]_\\times^2 \\end{align*}$$关于如何从反对称矩阵直接获取 \\(\\theta\\), 可以参考 旋转 中 \\(\\mathrm{exp}\\) 一节.\n$$\\begin{align*} \\mathrm{log}: SE(3) \u0026\\rightarrow \\mathfrak{se}(3) \\\\ T \u0026\\mapsto \\mathbf{\\xi}^\\wedge \\end{align*}$$因为有\n$$\\begin{align*} \\mathrm{exp} \\begin{pmatrix} \\theta [\\hat{\\mathbf{\\omega}}]_\\times \u0026 \\mathbf{v} \\\\ \u0026 0 \\end{pmatrix} \u0026= \\begin{pmatrix} \\exp{\\theta [\\hat{\\mathbf{\\omega}}]_\\times} \u0026 J \\mathbf{v} \\\\ \u0026 1 \\end{pmatrix} \\\\ \u0026= \\begin{pmatrix} R \u0026 \\mathbf{\\rho} \\\\ \u0026 1 \\end{pmatrix} \\end{align*}$$直接得到\n$$ \\mathrm{log} \\begin{pmatrix} R \u0026 \\mathbf{\\rho} \\\\ \u0026 1 \\end{pmatrix} = \\begin{pmatrix} \\mathrm{log} ~ R \u0026 J^{-1} \\mathbf{\\rho} \\\\ \u0026 0 \\end{pmatrix} $$其中 \\(\\mathrm{log} ~ R\\) 我们已经得到, 它是李群 \\(SO(3)\\) 到李代数 \\(\\mathfrak{so}(3)\\) 的对数映射, 在 这里 可以找到.\n接下来的工作是寻找矩阵 \\(J\\) 的逆. 容易发现 \\(J\\) 恰是 \\([\\hat{\\mathbf{\\omega}}]_\\times\\) 的多项式, 不妨令 \\(J = f([\\hat{\\mathbf{\\omega}}]_\\times)\\).\n令 \\([\\hat{\\mathbf{\\omega}}]_\\times\\) 的特征值为 \\(0\\) 与 \\(\\lambda_i \\mathrm{i}\\), 显然 \\(f(0) = 1\\); 因为 \\(\\mathrm{Im} ~ f(\\lambda_i \\mathrm{i}) = \\theta^{-1} (1-\\cos{\\theta}) \\lambda_i \\neq 0\\), 所以 \\(f(\\lambda_i \\mathrm{i}) \\neq 0\\). 于是 \\(J\\) 可逆, 且 \\(J^{-1}\\) 是 \\([\\hat{\\mathbf{\\omega}}]_\\times\\) 的多项式.\n注意到 \\([\\hat{\\mathbf{\\omega}}]_\\times^3 = -[\\hat{\\mathbf{\\omega}}]_\\times\\), 这提示我们 \\([\\hat{\\mathbf{\\omega}}]_\\times\\) 的高次幂可以用 \\(1\\) 到 \\(2\\) 次幂来表示. 不妨使用待定系数法, 令 \\(J^{-1} = a ~ I + b ~ [\\hat{\\mathbf{\\omega}}]_\\times + c ~ [\\hat{\\mathbf{\\omega}}]_\\times^2\\), 由 \\(J^{-1} J = I\\) 求出系数 \\(a\\), \\(b\\) 与 \\(c\\).\n不难求出, \\(a = 1\\), \\(b = -\\frac{1}{2} \\theta\\), \\(c = 1 - \\frac{\\theta}{2} \\cot{\\frac{\\theta}{2}}\\). 于是 $$J^{-1} = I - \\frac {1}{2} \\theta [\\hat{\\mathbf{\\omega}}]_\\times + (1 - \\frac{\\theta}{2} \\cot{\\frac{\\theta}{2}}) [\\hat{\\mathbf{\\omega}}]_\\times^2$$资源# 根据本文编写的代码可以在此处找到 [Web].\n"},{"id":12,"href":"/docs/rigid-rotation/","title":"三维空间中旋转的描述","section":"Docs","content":"三维空间中旋转的描述# 三维空间中所有正交且行列式为 \\(1\\) 的矩阵组成一个群, 称为 特殊正交群 \\(SO(3)\\), 其中的每个元素都代表一种三维空间中的旋转.\n另外, \\(SO(3)\\) 也是一个 李群, 它的 李代数 \\(\\mathfrak{so}(3)\\) 中的元素是轴角向量的外积矩阵.\n本篇文章的工作是推导 \\(SO(3)\\), \\(\\mathfrak{so}(3)\\) 与 \\(\\mathbb{R}^3\\) 中元素的互相转换.\n引理# $$[\\mathbf{\\omega}]_\\times^2 = \\mathbf{\\omega} \\mathbf{\\omega}^T - \\|\\mathbf{\\omega}\\|^2 I$$$$\\begin{align*} ([\\mathbf{\\omega}]_\\times^2)_{ij} \u0026= \\varepsilon_{imk} \\omega_m ~ \\varepsilon_{knj} \\omega_n \\\\ \u0026= \\varepsilon_{kim} \\varepsilon_{knj} ~ \\omega_m \\omega_n \\\\ \u0026= (\\delta_{in} \\delta_{mj} - \\delta_{ij} \\delta_{mn}) \\omega_m \\omega_n \\\\ \u0026= \\omega_i \\omega_j - \\delta_{ij} \\omega_m \\omega_m \\\\ \u0026= (\\mathbf{\\omega} \\mathbf{\\omega}^T - \\|\\mathbf{\\omega}\\|^2 I)_{ij} \\end{align*}$$ $$[\\mathbf{\\omega}]_\\times^3 = - \\|\\mathbf{\\omega}\\|^2 [\\mathbf{\\omega}]_\\times$$$$\\begin{align*} [\\mathbf{\\omega}]_\\times^3 \u0026= (\\mathbf{\\omega} \\mathbf{\\omega}^T - \\|\\mathbf{\\omega}\\|^2 I) [\\mathbf{\\omega}]_\\times \\\\ \u0026= \\mathbf{\\omega} \\mathbf{\\omega}^T [\\mathbf{\\omega}]_\\times - \\|\\mathbf{\\omega}\\|^2 [\\mathbf{\\omega}]_\\times \\\\ \u0026= \\mathbf{\\omega} ([\\mathbf{\\omega}]_\\times \\mathbf{\\omega})^T - \\|\\mathbf{\\omega}\\|^2 [\\mathbf{\\omega}]_\\times \\\\ \u0026= \\mathbf{\\omega} (\\mathbf{\\omega} \\times \\mathbf{\\omega})^T - \\|\\mathbf{\\omega}\\|^2 [\\mathbf{\\omega}]_\\times \\\\ \u0026= - \\|\\mathbf{\\omega}\\|^2 [\\mathbf{\\omega}]_\\times \\end{align*}$$ $$\\mathrm{rank} [\\mathbf{\\omega}]_\\times = 2$$ 其中 \\(\\mathbf{\\omega} \\in \\mathbb{R}^3 \\backslash \\{0\\}\\).\n$$\\begin{align*} \\mathrm{rank} ~ [\\mathbf{\\omega}]_\\times = 2 \u0026 \\Leftrightarrow \\mathrm{dim} ~ \\mathrm{Ker} ~ [\\mathbf{\\omega}]_\\times = 1 \\\\ \u0026 \\Leftrightarrow [\\mathbf{\\omega}]_\\times \\mathbf{x} = 0 ~ \\text{解集的维数为} ~ 1 \\end{align*}$$ 考察上述方程: $$\\begin{align*} [\\mathbf{\\omega}]_\\times \\mathbf{x} = 0 \u0026 \\Leftrightarrow \\mathbf{\\omega} \\times \\mathbf{x} = 0 \\\\ \u0026 \\Leftrightarrow \\| \\mathbf{\\omega} \\times \\mathbf{x} \\| = 0 \\\\ \u0026 \\Leftrightarrow \\| \\mathbf{\\omega} \\| \\| \\mathbf{x} \\| \\sin{\\theta} = 0 \\\\ \u0026 \\Leftrightarrow \\sin{\\theta} = 0 \\\\ \u0026 \\Leftrightarrow \\theta \\in \\pi \\mathbb{Z} \\\\ \u0026 \\Leftrightarrow \\mathbf{x} \\parallel \\mathbf{\\omega} \\\\ \u0026 \\Leftrightarrow \\mathbf{x} \\in \\left\u003c \\mathbf{\\omega} \\right\u003e \\end{align*}$$ 显然 \\(\\mathrm{dim} \\left\u003c \\mathbf{\\omega} \\right\u003e = 1\\), 原式得证.\n正文# $$\\begin{align*} \\wedge: \\mathbb{R}^3 \u0026\\rightarrow \\mathfrak{so}(3) \\\\ \\mathbf{\\omega} \u0026\\mapsto [\\mathbf{\\omega}]_\\times \\end{align*}$$\\(\\wedge\\) 将向量映射为反对称矩阵, 并且要求: $$\\forall \\mathbf{v} \\in \\mathbb{R}^3, \\mathbf{\\omega} \\times \\mathbf{v} = \\mathbf{\\omega}^\\wedge \\mathbf{v}$$ 这也是记号 \\([\\cdot]_\\times\\) 的用处.\n我们知道 \\((\\mathbf{\\omega} \\times \\mathbf{v})_i = \\varepsilon_{ijk} \\omega_j v_k\\), 进而 \\((\\mathbf{\\omega}^\\wedge \\mathbf{v})_i = (\\varepsilon_{ijk} \\omega_j) v_k\\). 于是 \\((\\mathbf{\\omega}^\\wedge)_{ik} = \\varepsilon_{ijk} \\omega_j\\), 即 $$(\\mathbf{\\omega}^\\wedge)_{ij} = \\varepsilon_{ikj} \\omega_k$$ $$\\begin{align*} \\mathrm{exp}: \\mathfrak{so}(3) \u0026\\rightarrow SO(3) \\\\ \\theta [\\hat{\\mathbf{\\omega}}]_\\times \u0026\\mapsto R \\end{align*}$$\\(\\mathrm{exp}\\) 将李代数中的元素映射为对应李群中的元素. \\(R = \\exp{\\theta [\\hat{\\mathbf{\\omega}}]_\\times} = \\mathrm{e}^{\\theta [\\hat{\\mathbf{\\omega}}]_\\times}\\), 且仍按 \\(\\mathrm{exp}\\) 的级数定义. 于是有 $$\\begin{align*} R \u0026= \\mathrm{e}^{\\theta [\\hat{\\mathbf{\\omega}}]_\\times} \\\\ \u0026= I + \\theta [\\hat{\\mathbf{\\omega}}]_\\times + \\frac{1}{2!} \\theta^2 [\\hat{\\mathbf{\\omega}}]_\\times^2 + \\frac{1}{3!} \\theta^3 [\\hat{\\mathbf{\\omega}}]_\\times^3 + \\cdots \\\\ \u0026= I + (\\theta - \\frac{1}{3!} \\theta^3 + \\cdots) [\\hat{\\mathbf{\\omega}}]_\\times + (\\frac{1}{2!} \\theta^2 - \\frac{1}{4!} \\theta^4 + \\cdots) [\\hat{\\mathbf{\\omega}}]_\\times^2 \\\\ \u0026= I + \\sin{\\theta} [\\mathbf{\\omega}]_\\times + (1-\\cos{\\theta}) [\\hat{\\mathbf{\\omega}}]_\\times^2 \\\\ \u0026= \\cos{\\theta} I + (1-\\cos{\\theta}) \\hat{\\mathbf{\\omega}} \\hat{\\mathbf{\\omega}}^T + \\sin{\\theta} [\\hat{\\mathbf{\\omega}}]_\\times \\end{align*}$$另外, 对于 \\([\\mathbf{\\omega}]_\\times = \\theta [\\hat{\\mathbf{\\omega}}]_\\times\\), 其中 \\(\\hat{\\mathbf{\\omega}}\\) 为单位向量, 我们有办法直接从 \\([\\mathbf{\\omega}]_\\times\\) 提取 \\(\\theta\\).\n注意到 \\([\\mathbf{\\omega}]_\\times^2 = \\mathbf{\\omega} \\mathbf{\\omega}^T - \\|\\mathbf{\\omega}\\|^2 I\\), 两边取迹, 有 $$\\begin{align*} \\mathrm{tr} [\\mathbf{\\omega}]_\\times^2 \u0026= \\mathrm{tr} (\\mathbf{\\omega} \\mathbf{\\omega}^T - \\|\\mathbf{\\omega}\\|^2 I) \\\\ \u0026= \\mathrm{tr} \\mathbf{\\omega}^T \\mathbf{\\omega} - \\|\\mathbf{\\omega}\\|^2 \\mathrm{tr} I \\\\ \u0026= \\|\\mathbf{\\omega}\\|^2 - 3 \\|\\mathbf{\\omega}\\|^2 \\\\ \u0026= -2 \\|\\mathbf{\\omega}\\|^2 \\end{align*}$$如此, \\(\\|\\mathbf{\\omega}\\| = \\sqrt{-\\frac{1}{2} \\mathrm{tr} [\\mathbf{\\omega}]_\\times^2}\\).\n$$\\begin{align*} \\mathrm{log}: SO(3) \u0026\\rightarrow \\mathfrak{so}(3) \\\\ R \u0026\\mapsto \\theta [\\hat{\\mathbf{\\omega}}]_\\times \\end{align*}$$首先, 确定转角 \\(\\theta\\). 注意到对 \\(R = \\cos{\\theta} I + (1-\\cos{\\theta}) \\hat{\\mathbf{\\omega}} \\hat{\\mathbf{\\omega}}^T + \\sin{\\theta} [\\hat{\\mathbf{\\omega}}]_\\times\\) 两端取迹, 可得 $$\\begin{align*} \\mathrm{tr} R \u0026= \\mathrm{tr} (\\cos{\\theta} I) + \\mathrm{tr} ((1-\\cos{\\theta}) \\hat{\\mathbf{\\omega}} \\hat{\\mathbf{\\omega}}^T) + \\mathrm{tr} (\\sin{\\theta} [\\hat{\\mathbf{\\omega}}]_\\times) \\\\ \u0026= 3\\cos{\\theta} + (1-\\cos{\\theta}) \\mathrm{tr} (\\hat{\\mathbf{\\omega}}^T \\hat{\\mathbf{\\omega}}) + 0 \\\\ \u0026= 3\\cos{\\theta} + (1-\\cos{\\theta}) \\mathrm{tr} \\| \\hat{\\mathbf{\\omega}} \\|^2 \\\\ \u0026= 2\\cos{\\theta} + 1 \\end{align*}$$ 因此 \\(\\cos{\\theta} = \\frac{\\mathrm{tr} R - 1}{2}\\).\n容易发现, \\(R^T = R^{-1} = \\cos{(-\\theta)} I + (1-\\cos{(-\\theta)}) \\hat{\\mathbf{\\omega}} \\hat{\\mathbf{\\omega}}^T + \\sin{(-\\theta)} [\\hat{\\mathbf{\\omega}}]_\\times = \\cos{\\theta} I + (1-\\cos{\\theta}) \\hat{\\mathbf{\\omega}} \\hat{\\mathbf{\\omega}}^T - \\sin{\\theta} [\\hat{\\mathbf{\\omega}}]_\\times\\). 与 \\(R\\) 作差, 得 \\(R-R^T = 2\\sin{\\theta} [\\hat{\\mathbf{\\omega}}]_\\times\\). 于是 \\([\\hat{\\mathbf{\\omega}}]_\\times = \\frac{1}{2\\sin{\\theta}} (R-R^T)\\).\n这里指出, \\(\\mathrm{arccos}\\) 的值域为 \\([0,\\pi]\\), 貌似会不能覆盖全部 \\([0, 2\\pi)\\) 范围. 事实上, 角度有 \\(\\theta\\) 与 \\(2\\pi-\\theta\\) (或 \\(-\\theta\\)) 两种可能, 后者不能从 \\(\\mathrm{arccos}\\) 得到. 但当实际角度为后者时, \\([\\hat{\\mathbf{\\omega}}]_\\times\\) 也多出一个负号. 因此最终角度为 \\((-\\theta) (-[\\hat{\\mathbf{\\omega}}]_\\times) = \\theta [\\hat{\\mathbf{\\omega}}]_\\times\\), 与实际一致.\n特殊地, 当 \\(\\theta = \\pi\\) 时, 分母为 \\(0\\), 出现奇异解. 此时发现 \\(R = I + \\sin{\\pi} [\\hat{\\mathbf{\\omega}}]_\\times + (1-\\cos{\\pi}) [\\hat{\\mathbf{\\omega}}]_\\times^2 = I + 2 [\\hat{\\mathbf{\\omega}}]_\\times^2\\), 所以 \\([\\hat{\\mathbf{\\omega}}]_\\times^2 = \\frac{1}{2} (R - I)\\).\n注意到 \\([\\mathbf{\\omega}]_\\times^2 \\mathbf{\\omega} = [\\mathbf{\\omega}]_\\times (\\mathbf{\\omega} \\times \\mathbf{\\omega}) = 0\\), 因此 \\(\\mathbf{\\omega} \\in \\mathrm{Ker} [\\mathbf{\\omega}]_\\times^2\\). 又有 \\(\\mathrm{rank} [\\mathbf{\\omega}]_\\times^2 = \\mathrm{rank} ([\\mathbf{\\omega}]_\\times^T)^T [\\mathbf{\\omega}]_\\times = \\mathrm{rank} [\\mathbf{\\omega}]_\\times^T [\\mathbf{\\omega}]_\\times = \\mathrm{rank} [\\mathbf{\\omega}]_\\times = 2\\), 可以得出 \\(\\mathrm{dim} ~ \\mathrm{Ker} [\\mathbf{\\omega}]_\\times^2 = 3 - \\mathrm{rank} [\\mathbf{\\omega}]_\\times^2 = 1\\).\n所以对于 \\(\\theta = \\pi\\), \\(\\hat{\\mathbf{\\omega}} \\in \\mathrm{Ker} (R - I)\\). 不必担心出现多解.\n杂七杂八# $$R [\\mathbf{\\omega}]_\\times R^T = [R \\mathbf{\\omega}]_\\times$$首先, 不加证明地直接给出: 对于三维空间中按右手排列的一组规范正交基 \\(\\mathbf{e}_i\\), \\(i = 1,2,3\\), 有 \\(\\mathbf{e}_i \\times \\mathbf{e}_j = \\varepsilon_{ijk} ~ \\mathbf{e}_k\\).\n$$\\begin{align*} (R [\\mathbf{\\omega}]_\\times R^T)_{ij} \u0026= R_{im} ~ \\varepsilon_{mkn} \\omega_k ~ R_{jn} \\\\ \u0026= \\varepsilon_{mkn} ~ (R_i)_m ~ \\omega_k ~ (R_j)_n \\\\ \u0026= \\mathbf{R}_i \\cdot (\\mathbf{\\omega} \\times \\mathbf{R}_j) \\\\ \u0026= - \\mathbf{\\omega} \\cdot (\\mathbf{R}_i \\times \\mathbf{R}_j) \\\\ \u0026= - \\mathbf{\\omega} \\cdot \\varepsilon_{ijk} \\mathbf{R}_k \\\\ \u0026= \\varepsilon_{ikj} \\mathbf{R}_k \\cdot \\mathbf{\\omega} \\\\ \u0026= \\varepsilon_{ikj} ~ R_{kn} \\omega_n \\\\ \u0026= \\varepsilon_{ikj} ~ (R \\mathbf{\\omega})_k \\\\ \u0026= ([R \\mathbf{\\omega}]_\\times)_{ij} \\end{align*}$$其中 \\(\\mathbf{R_i}\\) 表示 \\(R\\) 的第 \\(i\\) 个列向量. 需要指出, 对于 \\(R \\in SO(3)\\), 因为 \\(\\mathrm{det} R = 1\\), 所以列向量 \\(\\mathbf{R_i}\\), \\(i = 1,2,3\\) 是以右手坐标排列的. 这也是使用引理的必要条件.\n资源# 根据本文编写的代码可以在此处找到 [Web].\n"},{"id":13,"href":"/docs/time-series-forecasting-using-taylor/","title":"使用泰勒展开的运动预测","section":"Docs","content":"使用泰勒展开的运动预测# 在 \\(n\\) 维空间运动的物体, 其运动方程总可以写成 \\(n\\) 个关于时间 \\(t\\) 的参数方程.\n进一步地, 将关于 \\(t\\) 的参数方程泰勒展开为关于 \\(t\\) 的多项式函数, 可以显式得到其表达式, 并且可以计算出超过当前时刻, 也就是未来时刻的位置. 当超出当前时刻的时间不长, 运动轨迹是平滑的且分辨率足够高时, 可以认为此级数收敛于实际的位置.\n泰勒展开所需的各阶导数可以通过数值计算获得.\n参数获取# 假如我们已经获得位置关于时间的一系列数据 \\(\\{r_n\\}\\), 其中 \\(r_n\\) 是当前时刻的数据. 它也可以被记作 \\(r_n^{(0)}\\). 对应的时刻记为 \\(t_n\\), 或 \\(t_n^{(0)}\\).\n根据函数导数的公式, 自然地我们想到当前时刻位置的一阶导数为 \\(r_n^{(1)} = \\frac{r_n - r_{n-1}}{\\Delta t_n}\\), 其中 \\(\\Delta t_n := t_n - t_{n-1}\\), 以及过去时刻的导数同理.\n于是, 我们获得了 \\(n-1\\) 个一阶导数组成的序列 \\(\\{r_n^{(1)}\\}\\). 进一步可以计算二阶乃至 \\(n-1\\) 阶导数:\n$$r_n^{(m)} = \\frac{r_n^{(m-1)} - r_{n-1}^{(m-1)}}{\\Delta t_n^{(m-1)}}$$$$\\Delta t_n^{(m)} = \\frac{\\Delta t_n^{(m-1)} + \\Delta t_{n-1}^{(m-1)}}{2}$$另外 \\(\\Delta t_n^{(0)} := \\Delta t_n\\).\n这样便可递归地求出一阶直到 \\(n-1\\) 阶导数, 如下方的倒金字塔形图:\n1^0 2^0 3^0 4^0 5^0 6^0 2^1 3^1 4^1 5^1 6^1 3^2 4^2 5^2 6^2 4^3 5^3 6^3 5^4 6^4 6^5 如此一来, 末位置的 \\(0\\) 至 \\(n-1\\) 阶导数已经得到. 据此构建泰勒展开便可预测未来时刻的位置.\n需要注意的是, 可以看到 \\(r_6^{(5)}\\) 实际计算的是整个序列中点时刻的导数, 于是序列持续时间越短, 计算越精确.\n增量更新# 我们已经得到末位置 \\(r_n\\) 的 \\(0\\) 至 \\(n-1\\) 阶导数与 \\(\\Delta t_n^{(0)} \\sim \\Delta t_n^{(n-1)}\\), 若又获取到下一时刻的位置 \\(r_{n+1}\\) 与时间差 \\(\\Delta t_{n+1}\\), 如何利用现有数据计算 \\(r_{n+1}\\) 的各阶导数?\n注意到 \\(r_{n+1}^{(1)}\\) 由 \\(r_{n+1}^{(0)}\\) \\(r_{n}^{(0)}\\) 计算而来, 而这些数据我们已经知道. 进一步, \\(r_{n+1}^{(2)}\\) 由 \\(r_{n+1}^{(1)}\\) \\(r_{n}^{(1)}\\) 计算得出. 于是我们有 \\(r_{n+1}^{(m)} = \\frac{r_{n+1}^{(m-1)} - r_{n}^{(m-1)}}{\\Delta t_{n+1}^{(m-1)}}\\). 如下:\n6^0 7^0 6^1 7^1 6^2 7^2 6^3 7^3 6^4 7^4 6^5 7^5 7^6 误差分析# 编程计算时, 因为浮点数所能表示的精度有限, 因此求导多次后误差便会逐步累积变大, 直到不可忽略的程度.\n例如, IEEE 754 标准下双精度浮点数 double 表示某一实数, 其误差最大为 \\(\\epsilon = 2^{-52}\\). 这被称为 机器精度.\n因此, 若原始数据因为浮点舍入造成的误差为 \\(\\epsilon\\), 计算 \\(n\\) 阶导数的误差即为 \\(\\frac{\\epsilon}{\\Delta t^n}\\). 给定能接受的最大误差 \\(\\delta\\), 即有\n$$\\delta \\ge \\frac{\\epsilon}{\\Delta t^n}$$两边取对数有 \\(\\ln{\\delta} \\ge \\ln{\\epsilon} - n \\ln{\\Delta t}\\), 进而 \\(n \\ge \\frac{\\ln{\\epsilon / \\delta}}{\\ln{\\Delta t}}\\). 若 \\(\\Delta t \u003e 1\\), 则不等号取反.\n资源# 根据本文编写的代码可以在此处找到 [Web].\n"},{"id":14,"href":"/docs/ballistics/","title":"抛体运动弹道解算","section":"Docs","content":"抛体运动弹道解算# 模型# 本文考虑使用 线性阻力 模型. 事实上, 在空气中运动的阻力应该由 二次阻力 描述, 关于二者的对比将在 后文 给出.\n之所以使用线性阻力, 是因为如此一来物体的运动微分方程\n$$m \\dot{\\mathbf{v}} = -k \\mathbf{v} - m g \\hat{\\mathbf{j}}$$有封闭解. 进一步令 \\(\\mu := \\frac{k}{m}\\), 上式化为\n$$\\dot{\\mathbf{v}} = -\\mu \\mathbf{v} - g \\hat{\\mathbf{j}}$$容易解得\n$$\\mathbf{v} = \\mathrm{e}^{-\\mu t} \\mathbf{v}_0 - \\mu^{-1} (1-\\mathrm{e}^{-\\mu t}) g \\hat{\\mathbf{j}}$$积分得\n$$ \\mathbf{r} = \\mathbf{r}_0 - \\mu^{-1} (1-\\mathrm{e}^{-\\mu t}) \\mathbf{v}_0 - \\mu^{-2} (\\mu t + \\mathrm{e}^{-\\mu t} - 1) g \\, \\hat{\\mathbf{j}} $$这就是线性阻力情况下的运动方程. 它也可以很轻松地分解为两个方向来运算.\n与二次阻力的对比# 当速度较大 (\\(\\sim 20 ~ \\mathrm{m/s}\\)) 时, 弹丸在空气中运动的 雷诺数 很大, 并不适用于线性阻力. 但是在上升过程中, 速度逐渐下降, 雷诺数也逐渐变小, 于是在上升阶段用线性阻力模型的误差也不是很大.\n下面的图展示了无阻力, 线性阻力与二次阻力在初速 \\(20 ~ \\mathrm{m/s}\\), 射角 \\(60^\\circ\\) 时的运动轨迹, 可以看到上升阶段两条阻力曲线都十分接近, 随着下降时速度越来越快才逐渐分离.\n显然两种阻力的系数量纲不同, 于是其值也必然不同. 找到合适的线性阻力系数就成为逼近真实情况的重点之一. 在流体中的二次阻力可以用 \\(f = \\frac{1}{2} \\rho v^2 C_d S\\) 计算, 其中 \\(\\rho\\) 为流体密度; \\(C_d\\) 为阻力系数, 由实验得出; \\(S\\) 为参考面积. 我们希望由此推出线性阻力的系数, 使二者轨迹相差无几.\n我们令 \\(\\kappa = \\frac{1}{2} \\frac{\\rho C_d S}{m}\\), 于是二次阻力情况下加速度 \\(\\mathbf{a}_f = -\\kappa |\\mathbf{v}| \\mathbf{v}\\); 对比线性阻力情况下 \\(\\mathbf{a}_f = -\\mu \\mathbf{v}\\), 可以看出重点是找到一个合适的 \\(\\mu\\), 使得其在 \\(\\mathbf{v}\\) 不断变化的时候仍有 \\(\\mu \\sim \\kappa |\\mathbf{v}|\\).\n一种朴素的想法是使 \\(\\mu\\) 等于 \\(\\kappa |\\mathbf{v}|\\) 的均值. 也就是令\n$$\\mu = \\kappa \\frac{\\int_{0}^{t} |\\mathbf{v}| ~ \\mathrm{d} t}{t}$$注意到二次阻力模型下运动方程\n$$\\begin{align*} \\dot{v}_x \u0026= -\\kappa |\\mathbf{v}| ~ v_x \\\\ \\dot{v}_y \u0026= -\\kappa |\\mathbf{v}| ~ v_y - g \\end{align*}$$蕴含一个 \\(|\\mathbf{v}|\\). 只考虑 \\(x\\) 方向, 可得\n$$\\begin{align*} \\int_{0}^{t} \\kappa |\\mathbf{v}| ~ \\mathrm{d} t \u0026= -\\int_{0}^{t} \\frac{\\dot{v}_x}{v_x} ~ \\mathrm{d} t \\\\ \u0026= -\\int_{v_{0x}}^{v_x} \\frac{\\mathrm{d} v_x}{v_x} \\\\ \u0026= \\ln{\\frac{v_{0x}}{v_x}} \\end{align*}$$于是 \\(\\mu = t^{-1} \\ln{(v_{0x}/v_x)}\\).\n可以通过欧拉法取得 \\(v_x\\) 的数值解, 对于给定的 \\(t\\), 可以认为在这段时间内 ( \\(0 \\sim t\\) ) 使用 \\(\\mu\\) 的线性阻力模型与使用 \\(\\kappa\\) 的二次阻力模型取得的轨迹相差无几.\n但是应该注意, 随着 \\(t\\) 的增大, \\(v_x\\) 逐渐减小趋近于 \\(0\\), 因此 \\(t\\) 不宜取得太大. 实际应用中, 可以用射角 \\(45^\\circ\\), 在上升到最高点之前的时间段计算的 \\(\\mu\\) 来作为通用结果使用.\n上图展示了参数为 \\(\\kappa\\) 的二次阻力模型与计算得到的使用 \\(\\mu\\) 的线性阻力模型, 以及无阻力模型在 \\(y\\) 方向上的差值. 射角 \\(60^\\circ\\), 初速 \\(20 ~ \\mathrm{m/s}\\). 可以看出线性阻力模型在 \\(x \u003e 15 ~ \\mathrm{m}\\) 时才有显著的偏差.\n轨迹方程# 将运动方程中 \\(t\\) 消去, 即为轨迹方程.\n我们先将初速度 \\(\\mathbf{v}_0\\) 分解为 \\(v_0 ~ (\\cos{\\theta}, \\sin{\\theta})\\), 而后在 \\(x\\) 方向解出 \\(t\\):\n$$t = \\mu^{-1} \\ln{\\frac{v_0 \\cos{\\theta}}{v_0 \\cos{\\theta} - \\mu x}}$$之后将其代入 \\(y\\) 方向, 化简得\n$$ y - \\frac{g}{\\mu^2 v_0} (\\mu x \\sec{\\theta} - v_0 \\ln{\\frac{v_0}{v_0 - \\mu x \\sec{\\theta}}}) - x \\tan{\\theta} = 0 $$轨迹上的点 \\((x, y)\\) 都应满足于上面的方程, 这便是轨迹方程.\n在初速 \\(v_0\\) 确定的情况下, 这是关于 \\(\\theta\\) 的一个方程. 想要得到给定轨道上一点 \\((x, y)\\) 的情况下 \\(\\theta\\) 的值, 只需解这个方程就好. 可以用诸如 牛顿法 等数值方法来获得相当精确的解.\n确定初值# 牛顿法等迭代方法是初值敏感的, 初值的选取决定了迭代的次数与最终精度. 对于有多个根的函数, 初值还决定了最终结果是哪一个根.\n显而易见, 对于一般的目标, 抛体运动总有两条可达的轨迹. 一条是在上升时到达, 一条则在下降时. 我们总是更喜欢上升时到达的情况, 因为这样运动的时间短, 且可以使用线性阻力模型更精确地模拟, 误差更小. 这就对初值的选取提出了要求.\n令轨迹方程左边为目标函数 \\(f(\\theta)\\), 规定定义域为 \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\) 的子集, 作图观察 (曲线; \\(\\mu = 0.01\\), \\(v = 20 ~ \\mathrm{m/s}\\), \\((x, y) = (5, 0.5)\\)):\n显然有两个解. 并且容易想到上升时到达的轨迹, 射角小于下降时到达的, 于是左边一根即为所求射角.\n对目标函数求导并令其等于 \\(0\\), 可以得到其极值. 容易证明, 其极值至多一个, 且为最小值. 这里直接给出目标函数的最小值点:\n$$\\theta = \\arctan{\\frac{v_0^2}{g x}} - \\arctan{\\frac{\\mu x}{\\sqrt{v_0^2 + x^2 ((g / v_0)^2 - \\mu^2)}}}$$假如我们将初值选在最小值点的左侧, 那么迭代求出的根就是较小的一根. 进一步我们想到, 相较于 区间最左端的点 或 最小值点左邻域内的点, 不妨取这两点连线, 即图上斜线与 \\(x\\) 轴的交点, 这样更接近于根. 如此一来还可以避开上述两点附近数值不稳定的区域.\n排除不可达点# 给定的目标点并不总是有可达的抛体轨迹. 若是能在计算前将其排除, 便可避免再在繁杂的计算中消耗时间. 需要注意的是, 排除过程也需耗时, 且对于每个输入数据都需要计算, 因此需要平衡前期排除与正式计算间的平衡, 以优化耗时.\n射角范围# 实际应用中, 射角几乎总是不能达到 \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\), 于是若目标点与原点的夹角大于射角的最大值, 那么显然不能到达.\n尤其注意, 当夹角小于射角最小值时, 仍然有可能到达, 因为物体在重力作用下会下坠.\n包络线# 另外, 若是无阻力模型都到达不了的点, 那么线性乃至于二次阻力模型也一定不可达. 因此可以使用抛物线的包络线来检查, 若是在包络线以外 (以上) 的点, 一定是不可达点.\n对于无阻力的抛体运动, 可以直接写出其运动方程\n$$\\begin{align*} x \u0026= v_0 t \\cos{\\theta} \\\\ y \u0026= v_0 t \\sin{\\theta} - \\frac{1}{2} g t^2 \\end{align*}$$两式联立消去 \\(t\\), 得到\n$$\\begin{align*} y \u0026= v_0 \\sin{\\theta} ~ \\frac{x}{v_0 \\cos{\\theta}} - \\frac{1}{2} g (\\frac{x}{v_0 \\cos{\\theta}})^2 \\\\ \u0026= x \\tan{\\theta} - \\frac{g x^2}{2 v_0^2} \\sec^2{\\theta} \\\\ \u0026= x \\tan{\\theta} - \\frac{g x^2}{2 v_0^2} (1 + \\tan^2{\\theta}) \\end{align*}$$以 \\(\\theta\\) 为未知数, 若是其恰有一解, 则上述轨迹方程处于临界状态; 若目标点再稍抬高则不可达. 注意到上述方程为关于 \\(\\tan{\\theta}\\) 的二次方程, 且 \\(\\tan{x}\\) 在 \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\) 内为双射, 于是令\n$$\\begin{align*} \\Delta \u0026= x^2 - 4 \\frac{g x^2}{2 v_0^2} (\\frac{g x^2}{2 v_0^2} + y) \\\\ \u0026= 0 \\end{align*}$$即\n$$y = -\\frac{g}{2 v_0^2} x^2 + \\frac{v_0^2}{2 g}$$这便是抛体运动的包络线方程. 若点 \\((x, y)\\) 在方程之上, 则不可到达.\n其他# 在实际计算中对于根号与分式要特别注意, 防止出现超出定义域的情况. 可以在计算前简要判断一下, 确保各函数的自变量都在其定义域内.\n代码实现# 代码 [Web] 由 julia 编写. Benchmark 显示其性能十分卓越:\n#@benchmark θ([5.,0.5], 20., 9.8, 0.1, (-pi/6,pi/3)) BenchmarkTools.Trial: 10000 samples with 223 evaluations per sample. Range (min … max): 331.390 ns … 19.150 μs ┊ GC (min … max): 0.00% … 97.41% Time (median): 335.426 ns ┊ GC (median): 0.00% Time (mean ± σ): 363.941 ns ± 333.661 ns ┊ GC (mean ± σ): 1.97% ± 2.52% Memory estimate: 80 bytes, allocs estimate: 2. 可以看到计算一次的时间仅为 \\(335.426 ~ \\mathrm{ns}\\) (中位数), 占用 \\(80\\) 字节空间.\n"},{"id":15,"href":"/docs/conventional-commits/","title":"约定式提交","section":"Docs","content":"约定式提交# 约定式提交规定了一套编写 git 提交信息的规范, 方便写出清晰, 突出重点, 分类明确的提交信息, 尤其在团队协作时十分必要.\n本文中介绍的规范有别于标准的 约定式提交规范, 在一些方面做了让步, 方便新手编写.\n概述# 一个提交应由以下几部分组成\n\u0026lt;类型\u0026gt;: \u0026lt;描述\u0026gt; [正文] 类型 字段见下文 类型 一章.\n描述 应当是对提交的一句话总结, 力求简洁清楚, 重点分明. 对于描述部分的详细解释, 可以写在 正文 部分. 正文并非必要, 最好只在提交十分复杂, 或是包含了多个不同修改时编写.\n要使用约定式提交, 需要对提交本身进行规范:\n拆分不同文件的修改.\n例如文档的修改与源代码的修改应该分开提交; 配置文件, 测试代码, 编译脚本等等都应该尽量分离. 可以阅读 类型 一章, 了解哪些修改应该单独提交. 拆分提交的方法在 这里. 尽量更细致地进行提交, 一次提交一个功能的修改.\n也就是说, 不要一股脑将全部文件的修改送入版本库. 例如在某一源代码文件中, 既修改了数据的展示方式, 又修改了某 API 的实现, 那它们应该被拆分为两个提交. 避免过于细小的提交.\n某些微小又不重要的提交, 例如文档中某个拼写或代码某处符号后的空格, 可以等后面修改此文件时一并提交. 描述与正文部分尽量使用 markdown 语言标记. 特别地, 提到文件名时应使用反引号 ` 括起. 在正文中陈列多条修改时使用 markdown 的列表语法.\n当修改过多以至于无法细致提交时, 可以在描述处写 多次提交, 转而在正文处陈列. 但是强烈建议涉及业务功能的修改不要这样, 以免淹没在不重要的琐碎提交中.\n当目标未完成时, 在 \u0026lt;类型\u0026gt; 之后, 冒号 : 之前添加一个问号 ? 来注明. 例如要为用户页面添加一个新的按钮, 只完成了前端的 UI 绘制, 但后端并没有写相应业务代码. 此时若必须提交, 那么就要添加一个未完成标签 ?. 不能编译或运行的代码必须添加未完成标签. 原则上, 上述修改不允许提交, 未完成标签是与实际情况的无奈妥协. 一个最佳实践是: 将未完成的工作都提交到开发分支, 如 dev; 等目标全部完成后, 将这些提交全部 压缩 为一个提交, 再合并到主线. 不要将未完成的修改合并进去.\n在分支 合并 (merge) 时可以不遵守约定式提交, 但是也要具有统一的规范.\n相较于标准规范, 取消了关于 提交范围 (scope) 和强制说明 破坏性提交 的部分; 增加了未完成标签.\n类型# feat: 新功能, 新特性. fix: 修改 bug. perf: 在不影响代码内部行为的前提下, 更改代码, 对程序性能进行优化. refactor: 代码重构. 在不影响代码内部行为, 功能下的代码修改. docs: 文档修改. style: 代码格式修改. 例如添加分号, 修改或添加空格, 更改缩进格式等. test: 测试的新增, 修改. build: 影响项目构建或依赖项修改. revert: 恢复上一次提交. ci: 持续集成相关文件修改. chore: 其他修改, 即不在上述类型中的修改. 例如 .gitignore 的修改. 更多规范# 每个提交都必须使用类型字段前缀, 它由一个名词构成, 诸如 feat 或 fix, 其后接必要的冒号（英文半角）和空格. 当一个提交为应用或类库实现了新功能时, 必须使用 feat 类型. 当一个提交为应用修复了 bug 时, 必须使用 fix 类型. 在简短描述之后, 可以编写较长的提交正文, 为代码变更提供额外的上下文信息. 正文必须起始于描述字段结束的一个空行后. 提交的正文内容自由编写, 并使用空行分隔不同段落. 所有符号都建议使用半角符号. 可选的破坏性提交说明# 破坏性提交是指不能与修改前代码或 API 相兼容的修改, 例如删除或重命名 API, 修改函数的参数类型或返回类型等等. 若进行了破坏性提交, 可在正文后空一行编写破坏性提交说明. 说明以 BREAKING CHANGE: 起头, 空一格写内容. 若内容有多条, 可换行按列表语法陈列. 破坏性提交也可以加注标签: 在 \u0026lt;类型\u0026gt; 之后, 冒号 : 之前添加一个叹号 ! 来注明.\n若仓库从一开始就执意没有说明破坏性提交, 则后续都不要添加; 直到进入稳定发布版本再添加.\n参考# 约定式提交规范\n"},{"id":16,"href":"/docs/git-submodule/","title":"`git` 子模块","section":"Docs","content":"git 子模块# git 子模块 (submodule) 是挂于某 git 仓库下的子仓库. 当父仓库想使用第三方或者是与主业务分离的模块时, 可以通过将其注册为子模块来增加灵活性.\n添加子模块# 通过在父仓库使用\ngit submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; 可以在 \u0026lt;path\u0026gt; 地址处添加一个子模块.\n其中, url 可以为远程仓库地址, 也可以是本地仓库地址. 例如, 要把下面的 new_repo 仓库添加为 repo 的子模块, 可以使用命令:\ngit submodule add ./3rd/new_repo 3rd/new_repo\n其中 ./3rd/new_repo 即为本地仓库的 url. 需要注意的是本地 url 前面的 ./ 或 ../ 是必须的, \u0026lt;path\u0026gt; 也不能省略.\nrepo ├─ .git └─ 3rd └─ new_repo └─ .git 另外一个远程仓库的例子. 若想把 github.com/user/new_repo.git 仓库添加为 repo 的子模块, 并要求 new_repo 放置在 3rd 文件夹内, 可以使用命令:\ngit submodule add github.com/user/new_repo 3rd\n如果不指定后面的路径 3rd, 则会直接把 new_repo 克隆到父仓库目录下.\n添加子模块后会在父目录下新建一个 .gitmodule 文件, 里面储存了所有子模块的信息.\n修改子模块# 可以对子模块内的文件进行修改.\n前面提到子模块同样是一个完备的 git 仓库, 在子模块内进行的修改会同时反映在子模块本身与父仓库上. 对于子模块, 就是普通的 git 修改; 但是对于父仓库, 提示的是子模块整体发生了修改, 如下在父仓库进行的 git status 结果:\nChanges to be committed: (use \u0026quot;git restore --staged \u0026lt;file\u0026gt;...\u0026quot; to unstage) modified: 3rd/new_repo 因此一次修改需要提交两遍. 一遍是子模块内的提交, 就像普通的提交一样. 第二遍是在父仓库内, 将子模块作为整体暂存并提交.\n删除子模块# 要删除一个子模块, 遵循以下三步走原则:\n卸载 (deinit) 子模块\n使用 git submodule deinit \u0026lt;path\u0026gt; 卸载子模块. 如果子模块包含修改, 需要加上 --force (-f) 来强制卸载. 卸载后目录里的文件仍然还会被保留. 删除子模块目录\n使用 git rm \u0026lt;path\u0026gt; 来删除子模块所在的目录. 提交修改\n最后在父仓库提交上述修改 (在父仓库看来删除子模块同样是一个修改). "},{"id":17,"href":"/docs/repo-struct/","title":"关于知识库框架结构的一些想法","section":"Docs","content":"关于知识库框架结构的一些想法# 因为我的各种文档或笔记过于分散凌乱, 非常需要进行统一管理. 但是使用的技术栈千差万别, 有纯文字用 markdown 写的, 有使用 jupyter 笔记本内嵌代码的, 有使用 mathematica 的, 有用 typst 和 latex 写更专业的出版级文档的, 也有主要写代码附文说明的. 现有的知识库框架不可能支持如此多种类的文件管理, 事实上传统的知识库软件仅能做到管理文字内容, 并且也很难做到与其他编辑器的通用. 例如编写代码另附文档的情况, 势必要在其他编辑器处进行代码的编辑, 也当然希望在那里就完成文档的修改, 而不必打开特定的知识库管理或文档软件.\n我想通过 git submodule 与 obsidian 协同构建一个包罗万象的知识库框架, 力图让专业的软件做专业的事, 而不必让知识库管理它能力范围之外的文件, 例如源代码啊, 交互式笔记本啊什么的.\nobsidian 与 git submodule# obsidian 本质上还是文字编辑软件, 在不加插件的前提下, 只有基础的文字编辑功能 (依托 markdown 标记语言). 因此我们只让 obsidian 管理博文和各类文档, 并辅以 git 进行版本控制.\n项目结构如下:\n. ├─ Blog └─ Work ├─ A └─ B ... 其中 Blog 是记录日常或简单知识的文章; 而偏知识向或更专业的, 以及不使用 markdown 语言写的内容都放置于 Work 目录下, 每组另外再分目录.\nWork 目录下的每个文件夹都是独立的 git 仓库, 并都注册为知识库的 子模块. 这样做有助于知识库挂载各种项目, 并且都高度自治, 提高独立性.\n版本控制# 将整个知识库置于 git 的管理之下, 不仅有助于追溯历史, 而且可以使用 GitHub 实现同步. 但是缺点也显而易见, 就是修改不再随心所欲. 因为你总要为它编写一个提交信息, 而且也不希望提交历史中总是无聊琐碎的标点符号或是遣词造句修改.\n提交信息的编写总体上符合 约定式提交, 只是在另一些方面进行了扩充与修改:\n当新建一篇博客时, 提交信息如下: ``` doc\nyyyy-MM-dd\n下面的日期是文章的写作日期. 因为博客的标题体现在文件的名字上, 没有必要赘述. 但是可能提交的是往年的文章, 所以日期需要特别注明. 当子模块发生了修改, 提交类型写 submodule, 并只是简单写明是增加内容或是发生修改, 抑或是删除内容等. 详细的修改信息可以在子模块所在的仓库查看.\n尽量等子模块更新完成后一并提交. 不同的子模块分开提交.\n"},{"id":18,"href":"/docs/git-tips/","title":"Git Tips","section":"Docs","content":"Git Tips# 文件管理# 工作区# 工作区 即整个工作空间的根目录, 也就是 .git 目录存在的那一级目录. 对每个文件的修改都在这里进行.\n特殊地, 被 .gitignore 排除的文件或目录不属于工作区. 这些文件将被彻底排除出 git 的管理, 对他们的操作也无法使用 git 回退或恢复.\n暂存区# 当在工作区进行操作后, 使用 git add 命令将修改的文件 添加 (add) 到 暂存区. 暂存区可以继续添加或移除文件, 直到使用 git commit 命令将区内的文件一次性 提交 (commit) 到版本库中.\n文件状态# 被 git 管理的文件有以下几种状态:\nU, untrack: 未跟踪\n这是新创建的文件, 此前在工作区从未出现. 例如在工作区新建某一源代码文件, 并且写入部分内容, 这个文件就处于未跟踪状态. M, modified: 已修改\n这是之前已被提交过的文件, 但是经过了一些修改, 使其与之前不同了. 例如在更改某一方法的实现等等. staged: 已暂存\n当把工作区的文件添加到暂存区后, 其状态就变为已暂存. committed: 已提交\n当把暂存区的文件提交到仓库后, 其状态就变为已提交. 快速操作# 为 git 设置代理# git config --global http.proxy \u0026quot;http://127.0.0.1:7890\u0026quot; # 端口待定 git config --global https.proxy \u0026quot;https://127.0.0.1:7890\u0026quot; 查看提交历史# git log 或以 ascii 图形的方式展示树状分支结构:\ngit log --graph 显示操作历史# git reflog 通过这个命令可以检查做过的所有操作, 包括提交, 切换分支, 撤销文件修改, 回滚版本等等.\n给当前版本打标签# git tag \u0026lt;tag-name\u0026gt; 标签可以帮你快速定位版本信息, 或者标记最后一个可以被成功运行的版本.\n拆分提交# 一个已修改的文件 (注意, 不包含未跟踪的文件) 可以被拆分, 有选择地提交. 使用\ngit add -p \u0026lt;file\u0026gt; 在命令行中交互式地操作. 输入命令后将展示文件中被细分出的修改, 同时出现如下操作菜单.\n(1/5) Stage this hunk [y,n,q,a,d,e,?]? 最左边 (1/5) 显示了当前是第几个修改以及修改总数;\ny: 将当前修改放入暂存区 n: 跳过当前修改, 不放入暂存区 q: 退出, 跳过后面所有修改, 但是保留之前放入暂存区的修改 a: 暂存当前以及之后的所有修改 d: 与 q 相似, 但只跳过当前文件, 继续操作下一个文件 e: 尝试继续拆分修改, 更细致地进行操作 ?: 显示帮助 现代编辑器也提供了图形化的操作.\n压缩提交# 使用交互式 变基 (rebase) 来指定要压缩的那些提交, 在指定的提交之后的都可以被操作:\ngit rebase -i \u0026lt;commit\u0026gt; 在打开的编辑器中将开头的 pick 修改为 squash ( 缩写 s ) 或 fixup ( 缩写 f ). 两者的区别在于:\nsquash: 保留提交消息, 允许合并后编辑. fixup: 丢弃提交消息, 直接合并到前一个提交. 撤销修改# 完全放弃暂存区和工作区的所有修改, 无论有没有提交: git reset --hard HEAD\n将文件恢复成上一次提交或暂存时的状态. 注意, 如果文件是新创建的, 则不会对他进行任何操作并报错: git restore \u0026lt;file\u0026gt;\n将所有修改都变为未跟踪状态; 也就是清空暂存区, 但是修改仍然保留: git restore --staged . git reset --mixed HEAD\n取消暂存指定的文件, 保留修改: git restore --staged \u0026lt;file\u0026gt;\n撤销本地提交# 远程提交几乎不可撤销.\n如果你已经推送了, 放弃或者使用 git revert (但这毕竟不是真的撤销).\n撤销到某次提交. 注意, 这将删除那次提交之后的一切修改: git reset --hard \u0026lt;commit\u0026gt; 例如, 撤销最后一次提交1: git reset --hard HEAD^ 撤销到某次提交, 将之后的修改与当前暂存区内的修改移回工作区: git reset --mixed \u0026lt;commit\u0026gt; 撤销到某次提交, 将之后的修改移到暂存区内: git reset --soft \u0026lt;commit\u0026gt; 通过创建一个恰恰相反的新提交, 来重置一个提交: git revert \u0026lt;commit\u0026gt; 修改提交# 远程提交同上, 几乎无法修改.\n直接修改上次提交:\ngit commit --amend 如果要修改的提交是几次之前, 则只能重新排序提交, 将要修改的那次移动到上一次, 再进行修改.\n重新排序的操作可以使用交互式 变基 (rebase) 完成:\ngit rebase -i \u0026lt;commit\u0026gt; 更多# 不妨看看:\nGit Cheat Sheet: 一份 git 命令速查表\nGit Book: 官方中文 git 教程\n使用了 祖先引用\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":19,"href":"/docs/vscode-cmake-with-msvc/","title":"Windows 下的现代 C/C++ 开发环境配置","section":"Docs","content":"Windows 下的现代 C/C++ 开发环境配置# 首先应该确保电脑上有这些必需的软件:\nCMake Ninja vcpkg MSVC 套件 MSVC 安装# 可以使用 Visual Studio 安装工具 针对性地安装 MSVC 套件而不必安装全套 Visual Studio .\n只需在下载的 Visual Studio Installer 中选择 单个组件 → 编译器、生成工具和运行时 → MSVC vXXX - VS 2022 C++ x64/x86 生成工具 选项进行安装. 建议安装最新版本.\nMSVC 环境必须经过初始化才可以使用. 安装完成后会自动出现 Developer Command Prompt for VS 20xx (即 开发人员命令提示符 ) 和 Developer PowerShell for VS 20xx (即 开发人员 PowerShell ), 这两个终端就是已经初始化的环境, 在这两个终端中可以直接调用编译器. 另外 Visual Studio 还提供了初始化脚本来初始化编译器环境.\nvcpkg 安装# 访问 vcpkg 的 GitHub 仓库以查看安装说明.\n将仓库克隆到本地后, 需要将可执行文件添加到 PATH 环境变量中, 并声明 VCPKG_ROOT 环境变量. 我个人的做法是为可执行文件创建符号链接, 就像 Linux 中创建链接到 /usr/local/bin 一样. 声明 VCPKG_ROOT 变量并将值定义为你克隆仓库目录的绝对地址, 这样 vcpkg 才在终端环境中可用.\nNinja 安装# Ninja 是一个跨平台的构建系统, 我们使用它来作为 CMake 的生成器. 安装它的方式很简单, 在 GitHub 仓库下载最新版本后放到 PATH 环境变量中的文件夹即可.\nVS Code 配置# 为了与 CMake 配合, 这些扩展是必须的:\nC/C++ CMake CMake Tools 另外, 为了获得更完备的开发体验, 建议使用 clangd 替代 C/C++ 作为代码静态分析和补全的后端. 但 C/C++ 也得保留, 为了与 CMake 有关插件配合. 我们可以把 C/C++ 的所有代码提示全部关掉, 防止与 clangd 冲突.\nclangd 需要配置才能识别引入的第三方库, 否则就会报 file not found 错误. 可以读取通过 CMake 自动生成的 compile_commands.json 文件来配置第三方库信息. 然而 CMake 只能为 Ninja 和 Makefile 生成此文件1. 因为我们想尽可能做到跨平台, 所以使用 Ninja 是更好的选择.\n在项目的根目录下放置一个 CMakePresets.json 可以控制 VS Code 中 CMake 的配置行为, 各种命令行参数也可以在这里面定义. 下面是一个示例文件, 定义了四个可选的项目配置预设:\n{ \u0026#34;version\u0026#34;: 2, \u0026#34;configurePresets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;vcpkg\u0026#34;, // 隐藏此配置 \u0026#34;hidden\u0026#34;: true, \u0026#34;cacheVariables\u0026#34;: { // 引入 vcpkg 包管理 \u0026#34;CMAKE_TOOLCHAIN_FILE\u0026#34;: \u0026#34;$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;vcpkg\u0026#34;, \u0026#34;hidden\u0026#34;: true, // 指定生成器为 Ninja \u0026#34;generator\u0026#34;: \u0026#34;Ninja\u0026#34;, // 输出文件到项目目录下的 build/debug 文件夹 \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/build/debug\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Debug\u0026#34;, // 生成 compile_commands.json 文件 \u0026#34;CMAKE_EXPORT_COMPILE_COMMANDS\u0026#34;: \u0026#34;True\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;release\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;vcpkg\u0026#34;, \u0026#34;hidden\u0026#34;: true, \u0026#34;generator\u0026#34;: \u0026#34;Ninja\u0026#34;, // 输出文件到项目目录下的 build/release 文件夹 \u0026#34;binaryDir\u0026#34;: \u0026#34;${sourceDir}/build/release\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { \u0026#34;CMAKE_BUILD_TYPE\u0026#34;: \u0026#34;Release\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;windows-debug-x86_64-msvc\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Windows x86_64 MSVC (Debug)\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MSVC with vcpkg for Windows x86_64 - Debug Configuration\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { // 指定使用 MSVC 编译套件 \u0026#34;CMAKE_C_COMPILER\u0026#34;: \u0026#34;cl\u0026#34;, \u0026#34;CMAKE_CXX_COMPILER\u0026#34;: \u0026#34;cl\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;windows-release-x86_64-msvc\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;release\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Windows x86_64 MSVC (Release)\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MSVC with vcpkg for Windows x86_64 - Release Configuration\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { // 指定使用 MSVC 编译套件 \u0026#34;CMAKE_C_COMPILER\u0026#34;: \u0026#34;cl\u0026#34;, \u0026#34;CMAKE_CXX_COMPILER\u0026#34;: \u0026#34;cl\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;windows-debug-x86_64-mingw\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Windows x86_64 MinGW (Debug)\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MinGW with vcpkg for Windows x86_64 - Debug Configuration\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { // 指定使用 GUN gcc 编译套件, 来自 MinGW \u0026#34;CMAKE_C_COMPILER\u0026#34;: \u0026#34;cc\u0026#34;, \u0026#34;CMAKE_CXX_COMPILER\u0026#34;: \u0026#34;c++\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;windows-release-x86_64-mingw\u0026#34;, \u0026#34;inherits\u0026#34;: \u0026#34;release\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;Windows x86_64 MinGW (Release)\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MinGW with vcpkg for Windows x86_64 - Release Configuration\u0026#34;, \u0026#34;cacheVariables\u0026#34;: { // 指定使用 GUN gcc 编译套件, 来自 MinGW \u0026#34;CMAKE_C_COMPILER\u0026#34;: \u0026#34;cc\u0026#34;, \u0026#34;CMAKE_CXX_COMPILER\u0026#34;: \u0026#34;c++\u0026#34; } } ] }CMake Tools 自带一个复制 compile_commands.json 到指定位置的功能. 如果这个指定的位置恰好是文件默认所处的位置, 就会出现错误, 这一点应当注意. 我们可以把生成在 build/debug 的文件复制到 build 文件夹, 以确保一致性. 在 .vscode/settings.json 中添加下面一句来启用这一项功能:\n\u0026#34;cmake.copyCompileCommands\u0026#34;: \u0026#34;${workspaceFolder}/build/compile_commands.json\u0026#34;然后配置 clangd 让它能够找到此文件. 在 .vscode/settings.json 下添加这样一句来向 clangd 指明文件位置:\n\u0026#34;clangd.arguments\u0026#34;: [\u0026#34;--compile-commands-dir=build\u0026#34;]现在这一套组合应该已经可用了.\n构建过程# 当你点击 全部构建 时发生了什么? 最终的二进制文件是怎么编译出来的?\n我们在上面定义了一套比较复杂的调用关系, 具体就是:\ncmake → ninja → cl (MSVC) 当你想要获得最终的编译成果时, 实际上会发生以下步骤:\n配置 Configure\n这一步 cmake 会读取 CMakePresets.json 文件中的内容, 综合我们的要求解析 CMakeLists.txt 输出一个编译文件, 在使用 Ninja 作为生成器时输出的是 build.ninja, 在 build 文件夹中. 构建 Build\n这一步 cmake 会调用指定的生成器 (ninja), 逐条按照编译文件执行指令; 生成器会负责调用指定的编译器按指令进行编译. 编译与链接 Compile \u0026amp; Link\n生成器 ninja 会调用编译器与链接器, 先将源代码文件编译成中间文件 .obj / .o , 而后与外部库进行链接, 输出最终的二进制文件. 如果有动态链接库, 也会被复制过来. 另外, 配置 时会产生 compile_commands.json 文件, 然后 clangd 才能读取进而提供静态分析和代码补全. 所以想用 clangd 的功能时, 必须得先 配置 一遍才行.\n示例# 我们来实际编译一个简单的 OpenCV 项目来验证上述设置都是否正确.\n必须初始化 MSVC 环境后才能调用它的编译套件.\n可以在开发人员 命令提示符中 输入 code \u0026lt;path\u0026gt; 命令打开 VS Code 后进行操作.\n安装 OpenCV# 使用 vcpkg 来安装, 只需使用命令:\nvcpkg install opencv然后 vcpkg 就会自动安装所有依赖项, 并在本地编译.\n因为我们是在 Windows 环境中, 所以库的三元组为 x64-windows , 这也是 Windows 上的默认值.\n编写 CMakeLists.txt# 项目根目录下应该存在一个 CMakeLists.txt 来指定构建选项. 下面是一个示例:\n# CMakeLists.txt cmake_minimum_required(VERSION 3.10) project(\u0026#34;test-opencv\u0026#34;) # 搜索依赖的 OpenCV 库 find_package(\u0026#34;OpenCV\u0026#34; CONFIG REQUIRED) add_executable(\u0026#34;test\u0026#34; \u0026#34;src/main.cpp\u0026#34;) target_link_libraries(\u0026#34;test\u0026#34; PRIVATE ${OpenCV_LIBS}) # 不要用 vcpkg 给出的下面的设置, 会出现链接错误 #target_link_libraries(\u0026#34;text\u0026#34; PRIVATE opencv_ml opencv_dnn opencv_core opencv_flann)源代码# 我们来写一个打印 OpenCV 版本的小程序来验证是否正常安装依赖:\n// src/main.cpp #include \u0026lt;opencv2/opencv.hpp\u0026gt; #include \u0026lt;cstdio\u0026gt; int main() { std::printf(\u0026#34;OpenCV version: \u0026#34; CV_VERSION \u0026#34;\\n\u0026#34;); return 0; }构建项目# 先来检查一下项目结构:\n. ├─ .vscode │ └─ settings.json ├─ src │ └─ main.cpp ├─ CMakeLists.txt └─ CMakePresets.json 之后进行构建, 使用 Windows x86_64 MSVC (Debug) 预设, 应该能在 build/debug 目录里找到 text.exe , 运行它会打印一行 OpenCV 的版本信息.\n构建一遍以后再修改源代码, 应该可以享受到 clangd 的代码分析和补全了.\nhttps://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":20,"href":"/docs/linux-to-go/","title":"在移动介质中安装操作系统","section":"Docs","content":"在移动介质中安装操作系统# 所需工具:\n安装了任意 linux 发行版的电脑 此处使用安装了 debian 的 VMware 虚拟机 系统安装光盘文件 (.iso 文件) 我选择的发行版是 debian 容量足够的移动介质 (如 U 盘) 1. 检查移动介质 (如 U 盘) 的分区表类型# 我们计划使用更现代的 UEFI 引导操作系统启动, 为了具有更好的兼容性, 移动介质的分区表类型应为 GPT.\n因此第一步是将 MBR 类型的移动介质转换为 GPT 分区表类型. 假如你的介质已为 GPT, 可以跳过此章.\n1.1. 检查分区表类型# 使用 fdisk 命令检查介质:\n# fdisk -l Disk /dev/sdb: 15.24 GiB, 16358834176 bytes, 31950848 sectors Disk model: SD/MMC Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x00109879 上面显示了在我的机器上返回的信息, 其中:\n目标设备: sd 卡 被识别为 /dev/sdb sd 卡已预先被我格式化, 因此没有分区 Disklabel type 显示为 dos, 这意味着 sd 卡为 MBR 类型 1.2. 更改分区表类型# 使用 parted 命令交互式地更改分区表类型:\n# parted /dev/sdb GNU Parted 3.5 Using /dev/sdb Welcome to GNU Parted! Type 'help' to view a list of commands. (parted) mklabel gpt Yes/No? Yes (parted) print Model: Generic- SD/MMC (scsi) Disk /dev/sdb: 16.4GB Sector size (logical/physical): 512B/512B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags (parted) quit 键入命令 parted /dev/sdb, 其中应输入你自己的 u 盘设备 在交互式界面里输入 mklabel gpt, 更改分区表类型 此时会给出警告, 将会抹去盘上所有数据. 输入 Yes 以继续 输入 print 查看此时分区表情况, 可以看到 Partition Table 已经变为 gpt 输入 quit 退出 2. 预先手动分区# 在操作系统安装时分区繁琐且麻烦, 因此此时先分好区.\n我们计划分出五个区:\nvfat, 用于 UEFI 引导, 200M 左右 ext4, 挂载到 /, 根文件系统 ext4, 挂载到 /home swap, 不期望使用此分区, 因为频繁读写对 U 盘损害较大 vfat, 此分区使 U 盘插入 Windows 时仍被识别为 U 盘, 可用于方便地在 linux 与 Windows 间传递文件 2.1. 开始分区# 使用 gdisk 交互式命令行分区:\n# gdisk /dev/sdb GPT fdisk (gdisk) version 1.0.9 Partition table scan: MBR: protective BSD: not present APM: not present GPT: damaged **************************************************************************** Caution: Found protective or hybrid MBR and corrupt GPT. Using GPT, but disk verification and recovery are STRONGLY recommended. **************************************************************************** Command (? for help): n Partition number (1-128, default 1): First sector (34-31950814, default = 2048) or {+-}size{KMGTP}: Last sector (2048-31950814, default = 31948799) or {+-}size{KMGTP}: +200M Current type is 8300 (Linux filesystem) Hex code or GUID (L to show codes, Enter = 8300): EF00 Changed type of partition to 'EFI system partition' Command (? for help): n Partition number (2-128, default 2): First sector (34-31950814, default = 411648) or {+-}size{KMGTP}: Last sector (411648-31950814, default = 31948799) or {+-}size{KMGTP}: +8G Current type is 8300 (Linux filesystem) Hex code or GUID (L to show codes, Enter = 8300): 8300 Changed type of partition to 'Linux filesystem' Command (? for help): n Partition number (3-128, default 3): First sector (34-31950814, default = 17188864) or {+-}size{KMGTP}: Last sector (17188864-31950814, default = 31948799) or {+-}size{KMGTP}: +1G Current type is 8300 (Linux filesystem) Hex code or GUID (L to show codes, Enter = 8300): 8200 Changed type of partition to 'Linux swap' Command (? for help): n Partition number (4-128, default 4): First sector (34-31950814, default = 19286016) or {+-}size{KMGTP}: Last sector (19286016-31950814, default = 31948799) or {+-}size{KMGTP}: +2G Current type is 8300 (Linux filesystem) Hex code or GUID (L to show codes, Enter = 8300): 8300 Changed type of partition to 'Linux filesystem' Command (? for help): n Partition number (5-128, default 5): First sector (34-31950814, default = 23480320) or {+-}size{KMGTP}: Last sector (23480320-31950814, default = 31948799) or {+-}size{KMGTP}: +2G Current type is 8300 (Linux filesystem) Hex code or GUID (L to show codes, Enter = 8300): 0700 Changed type of partition to 'Microsoft basic data' Command (? for help): p Disk /dev/sdb: 31950848 sectors, 15.2 GiB Model: SD/MMC Sector size (logical/physical): 512/512 bytes Disk identifier (GUID): 29B98EB7-2B1C-4CD5-B5D0-D49DCEFAA7A5 Partition table holds up to 128 entries Main partition table begins at sector 2 and ends at sector 33 First usable sector is 34, last usable sector is 31950814 Partitions will be aligned on 2048-sector boundaries Total free space is 4278205 sectors (2.0 GiB) Number Start (sector) End (sector) Size Code Name 1 2048 411647 200.0 MiB EF00 EFI system partition 2 411648 17188863 8.0 GiB 8300 Linux filesystem 3 17188864 19286015 1024.0 MiB 8200 Linux swap 4 19286016 23480319 2.0 GiB 8300 Linux filesystem 5 23480320 27674623 2.0 GiB 0700 Microsoft basic data Command (? for help): w Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING PARTITIONS!! Do you want to proceed? (Y/N): y OK; writing new GUID partition table (GPT) to /dev/sdb. Warning: The kernel is still using the old partition table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) The operation has completed successfully. 键入命令 gdisk /dev/sdb, 选择自己的设备 划分 EFI 分区, 依次输入以下命令 n, 创建新分区 \u0026lt;Enter\u0026gt;, 选择默认: 1 \u0026lt;Enter\u0026gt;, 选择默认配置 +200M, 为分区划出 200M 空间 EF00, 设置为 EFI system partition 类型 划分根文件系统分区 n \u0026lt;Enter\u0026gt;, 选择默认: 2 \u0026lt;Enter\u0026gt; +8G, 划出 8GiB 空间 8300, 设置为 Linux filesystem 类型 划分 swap 分区 n \u0026lt;Enter\u0026gt;, 选择默认: 3 \u0026lt;Enter\u0026gt; +1G, 划出 1GiB 空间 8200, 设置为 Linux swap 类型 划分挂载在 /home 处的分区 n \u0026lt;Enter\u0026gt;, 选择默认: 4 \u0026lt;Enter\u0026gt; +2G, 划出 2GiB 空间 8300 划分被 Windows 识别的分区 n \u0026lt;Enter\u0026gt;, 选择默认: 5 \u0026lt;Enter\u0026gt; +2G, 划出 2GiB 空间 0700, 设置为 Microsoft basic data 类型 分区完毕, 键入 p 打印划好的分区 若一切正常, 键入 wq 保存并退出 2.2. 格式化分区# 预先格式化 EFI 分区:\n# mkfs.vfat /dev/sdb1 可选: 格式化为 Windows 准备的分区:\n# mkfs.vfat /dev/sdb5 3. 开始安装# 4. 重建引导# "}]