<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on EiEddie&#39;s Mind</title>
    <link>https://example.org/tags/git/</link>
    <description>Recent content in Git on EiEddie&#39;s Mind</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 26 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.org/tags/git/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>约定式提交</title>
      <link>https://example.org/docs/conventional-commits/</link>
      <pubDate>Sun, 26 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/conventional-commits/</guid>
      <description>&lt;h1 id=&#34;约定式提交&#34;&gt;约定式提交&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%a6%e5%ae%9a%e5%bc%8f%e6%8f%90%e4%ba%a4&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;约定式提交规定了一套编写 &lt;code&gt;git&lt;/code&gt; 提交信息的规范, 方便写出清晰, 突出重点, 分类明确的提交信息, 尤其在团队协作时十分必要.&lt;/p&gt;&#xA;&lt;p&gt;本文中介绍的规范有别于标准的 &lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;约定式提交规范&lt;/a&gt;, 在一些方面做了让步, 方便新手编写.&lt;/p&gt;&#xA;&lt;h2 id=&#34;概述&#34;&gt;概述&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;一个提交应由以下几部分组成&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;类型&amp;gt;: &amp;lt;描述&amp;gt;&#xA;&#xA;[正文]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;em&gt;类型&lt;/em&gt; 字段见下文 &lt;a href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;类型&lt;/a&gt; 一章.&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;描述&lt;/em&gt; 应当是对提交的一句话总结, 力求简洁清楚, 重点分明. 对于描述部分的详细解释, 可以写在 &lt;em&gt;正文&lt;/em&gt; 部分. 正文并非必要, 最好只在提交十分复杂, 或是包含了多个不同修改时编写.&lt;/p&gt;&#xA;&lt;p&gt;要使用约定式提交, 需要对提交本身进行规范:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拆分不同文件的修改.&lt;br&gt;&#xA;例如文档的修改与源代码的修改应该分开提交;&#xA;配置文件, 测试代码, 编译脚本等等都应该尽量分离.&#xA;可以阅读 &lt;a href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;类型&lt;/a&gt; 一章, 了解哪些修改应该单独提交.&#xA;拆分提交的方法在 &lt;a href=&#34;https://example.org/docs/git-tips/#%e6%8b%86%e5%88%86%e6%8f%90%e4%ba%a4&#34;&gt;这里&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;尽量更细致地进行提交, 一次提交一个功能的修改.&lt;br&gt;&#xA;也就是说, 不要一股脑将全部文件的修改送入版本库.&#xA;例如在某一源代码文件中, 既修改了数据的展示方式, 又修改了某 API 的实现,&#xA;那它们应该被拆分为两个提交.&lt;/li&gt;&#xA;&lt;li&gt;避免过于细小的提交.&lt;br&gt;&#xA;某些微小又不重要的提交,&#xA;例如文档中某个拼写或代码某处符号后的空格, 可以等后面修改此文件时一并提交.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;描述与正文部分尽量使用 &lt;code&gt;markdown&lt;/code&gt; 语言标记. 特别地, 提到文件名时应使用反引号 &lt;code&gt;`&lt;/code&gt; 括起.&#xA;在正文中陈列多条修改时使用 &lt;code&gt;markdown&lt;/code&gt; 的列表语法.&lt;/p&gt;&#xA;&lt;p&gt;当修改过多以至于无法细致提交时, 可以在描述处写 &lt;strong&gt;多次提交&lt;/strong&gt;, 转而在正文处陈列.&#xA;但是强烈建议涉及业务功能的修改不要这样, 以免淹没在不重要的琐碎提交中.&lt;/p&gt;</description>
    </item>
    <item>
      <title>`git` 子模块</title>
      <link>https://example.org/docs/git-submodule/</link>
      <pubDate>Sat, 25 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/git-submodule/</guid>
      <description>&lt;h1 id=&#34;git-子模块&#34;&gt;&lt;code&gt;git&lt;/code&gt; 子模块&lt;a class=&#34;anchor&#34; href=&#34;#git-%e5%ad%90%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;git&lt;/code&gt; &lt;em&gt;子模块 (submodule)&lt;/em&gt; 是挂于某 &lt;code&gt;git&lt;/code&gt; 仓库下的子仓库. 当父仓库想使用第三方或者是与主业务分离的模块时, 可以通过将其注册为子模块来增加灵活性.&lt;/p&gt;&#xA;&lt;h2 id=&#34;添加子模块&#34;&gt;添加子模块&lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0%e5%ad%90%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;通过在父仓库使用&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;git submodule add &amp;lt;url&amp;gt; &amp;lt;path&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;可以在 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 地址处添加一个子模块.&lt;/p&gt;&#xA;&lt;p&gt;其中, &lt;code&gt;url&lt;/code&gt; 可以为远程仓库地址, 也可以是本地仓库地址. 例如, 要把下面的 &lt;code&gt;new_repo&lt;/code&gt; 仓库添加为 &lt;code&gt;repo&lt;/code&gt; 的子模块, 可以使用命令:&lt;br&gt;&#xA;&lt;code&gt;git submodule add ./3rd/new_repo 3rd/new_repo&lt;/code&gt;&lt;br&gt;&#xA;其中 &lt;code&gt;./3rd/new_repo&lt;/code&gt; 即为本地仓库的 &lt;code&gt;url&lt;/code&gt;. 需要注意的是本地 &lt;code&gt;url&lt;/code&gt; 前面的 &lt;code&gt;./&lt;/code&gt; 或 &lt;code&gt;../&lt;/code&gt; 是必须的, &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 也不能省略.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;repo&#xA;├─ .git&#xA;└─ 3rd&#xA;    └─ new_repo&#xA;        └─ .git&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;另外一个远程仓库的例子. 若想把 &lt;code&gt;github.com/user/new_repo.git&lt;/code&gt; 仓库添加为 &lt;code&gt;repo&lt;/code&gt; 的子模块, 并要求 &lt;code&gt;new_repo&lt;/code&gt; 放置在 &lt;code&gt;3rd&lt;/code&gt; 文件夹内, 可以使用命令:&lt;br&gt;&#xA;&lt;code&gt;git submodule add github.com/user/new_repo 3rd&lt;/code&gt;&lt;br&gt;&#xA;如果不指定后面的路径 &lt;code&gt;3rd&lt;/code&gt;, 则会直接把 &lt;code&gt;new_repo&lt;/code&gt; 克隆到父仓库目录下.&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于知识库框架结构的一些想法</title>
      <link>https://example.org/docs/repo-struct/</link>
      <pubDate>Sat, 25 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/repo-struct/</guid>
      <description>&lt;h1 id=&#34;关于知识库框架结构的一些想法&#34;&gt;关于知识库框架结构的一些想法&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e4%ba%8e%e7%9f%a5%e8%af%86%e5%ba%93%e6%a1%86%e6%9e%b6%e7%bb%93%e6%9e%84%e7%9a%84%e4%b8%80%e4%ba%9b%e6%83%b3%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;因为我的各种文档或笔记过于分散凌乱, 非常需要进行统一管理. 但是使用的技术栈千差万别, 有纯文字用 &lt;code&gt;markdown&lt;/code&gt; 写的, 有使用 &lt;code&gt;jupyter&lt;/code&gt; 笔记本内嵌代码的, 有使用 &lt;code&gt;mathematica&lt;/code&gt; 的, 有用 &lt;code&gt;typst&lt;/code&gt; 和 &lt;code&gt;latex&lt;/code&gt; 写更专业的出版级文档的, 也有主要写代码附文说明的. 现有的知识库框架不可能支持如此多种类的文件管理, 事实上传统的知识库软件仅能做到管理文字内容, 并且也很难做到与其他编辑器的通用. 例如编写代码另附文档的情况, 势必要在其他编辑器处进行代码的编辑, 也当然希望在那里就完成文档的修改, 而不必打开特定的知识库管理或文档软件.&lt;/p&gt;&#xA;&lt;p&gt;我想通过 &lt;code&gt;git submodule&lt;/code&gt; 与 &lt;code&gt;obsidian&lt;/code&gt; 协同构建一个包罗万象的知识库框架, 力图让专业的软件做专业的事, 而不必让知识库管理它能力范围之外的文件, 例如源代码啊, 交互式笔记本啊什么的.&lt;/p&gt;&#xA;&lt;h2 id=&#34;obsidian-与-git-submodule&#34;&gt;&lt;code&gt;obsidian&lt;/code&gt; 与 &lt;code&gt;git submodule&lt;/code&gt;&lt;a class=&#34;anchor&#34; href=&#34;#obsidian-%e4%b8%8e-git-submodule&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;obsidian&lt;/code&gt; 本质上还是文字编辑软件, 在不加插件的前提下, 只有基础的文字编辑功能 (依托 &lt;code&gt;markdown&lt;/code&gt; 标记语言). 因此我们只让 &lt;code&gt;obsidian&lt;/code&gt; 管理博文和各类文档, 并辅以 &lt;code&gt;git&lt;/code&gt; 进行版本控制.&lt;/p&gt;&#xA;&lt;p&gt;项目结构如下:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;.&#xA;├─ Blog&#xA;└─ Work&#xA;    ├─ A&#xA;    └─ B&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中 &lt;code&gt;Blog&lt;/code&gt; 是记录日常或简单知识的文章; 而偏知识向或更专业的, 以及不使用 &lt;code&gt;markdown&lt;/code&gt; 语言写的内容都放置于 &lt;code&gt;Work&lt;/code&gt; 目录下, 每组另外再分目录.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git Tips</title>
      <link>https://example.org/docs/git-tips/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/git-tips/</guid>
      <description>&lt;h1 id=&#34;git-tips&#34;&gt;Git Tips&lt;a class=&#34;anchor&#34; href=&#34;#git-tips&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文件管理&#34;&gt;文件管理&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工作区&#34;&gt;工作区&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8c%ba&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;工作区&lt;/em&gt; 即整个工作空间的根目录, 也就是 &lt;code&gt;.git&lt;/code&gt; 目录存在的那一级目录. 对每个文件的修改都在这里进行.&lt;/p&gt;&#xA;&lt;p&gt;特殊地, 被 &lt;code&gt;.gitignore&lt;/code&gt; 排除的文件或目录不属于工作区. 这些文件将被彻底排除出 &lt;code&gt;git&lt;/code&gt; 的管理, &lt;strong&gt;对他们的操作也无法使用 &lt;code&gt;git&lt;/code&gt; 回退或恢复&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;暂存区&#34;&gt;暂存区&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9a%82%e5%ad%98%e5%8c%ba&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;当在工作区进行操作后, 使用 &lt;code&gt;git add&lt;/code&gt; 命令将修改的文件 &lt;em&gt;添加 (add)&lt;/em&gt; 到 &lt;em&gt;暂存区&lt;/em&gt;. 暂存区可以继续添加或移除文件, 直到使用 &lt;code&gt;git commit&lt;/code&gt; 命令将区内的文件一次性 &lt;em&gt;提交 (commit)&lt;/em&gt; 到版本库中.&lt;/p&gt;&#xA;&lt;h3 id=&#34;文件状态&#34;&gt;文件状态&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%87%e4%bb%b6%e7%8a%b6%e6%80%81&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;被 &lt;code&gt;git&lt;/code&gt; 管理的文件有以下几种状态:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;U&lt;/code&gt;, &lt;code&gt;untrack&lt;/code&gt;: &lt;em&gt;未跟踪&lt;/em&gt;&lt;br&gt;&#xA;这是新创建的文件, 此前在工作区从未出现. 例如在工作区新建某一源代码文件, 并且写入部分内容, 这个文件就处于未跟踪状态.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;M&lt;/code&gt;, &lt;code&gt;modified&lt;/code&gt;: &lt;em&gt;已修改&lt;/em&gt;&lt;br&gt;&#xA;这是之前已被提交过的文件, 但是经过了一些修改, 使其与之前不同了. 例如在更改某一方法的实现等等.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;staged&lt;/code&gt;: &lt;em&gt;已暂存&lt;/em&gt;&lt;br&gt;&#xA;当把工作区的文件添加到暂存区后, 其状态就变为已暂存.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;committed&lt;/code&gt;: &lt;em&gt;已提交&lt;/em&gt;&lt;br&gt;&#xA;当把暂存区的文件提交到仓库后, 其状态就变为已提交.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;快速操作&#34;&gt;快速操作&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%ab%e9%80%9f%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;为-git-设置代理&#34;&gt;为 &lt;code&gt;git&lt;/code&gt; 设置代理&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba-git-%e8%ae%be%e7%bd%ae%e4%bb%a3%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;git config --global http.proxy &amp;quot;http://127.0.0.1:7890&amp;quot; # 端口待定&#xA;git config --global https.proxy &amp;quot;https://127.0.0.1:7890&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;查看提交历史&#34;&gt;查看提交历史&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8b%e6%8f%90%e4%ba%a4%e5%8e%86%e5%8f%b2&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;git log&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;或以 &lt;code&gt;ascii&lt;/code&gt; 图形的方式展示树状分支结构:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
