<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on EiEddie&#39;s Mind</title>
    <link>https://example.org/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on EiEddie&#39;s Mind</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 05 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.org/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ESP32 环境配置与开发</title>
      <link>https://example.org/docs/esp32-dev/</link>
      <pubDate>Sat, 05 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/esp32-dev/</guid>
      <description>&lt;h1 id=&#34;esp32-环境配置与开发&#34;&gt;ESP32 环境配置与开发&lt;a class=&#34;anchor&#34; href=&#34;#esp32-%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae%e4%b8%8e%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;我必须承认, esp idf 是我配置过最困难的开发环境.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;本篇文章的开发环境选择是 &lt;strong&gt;Visual Studio Code&lt;/strong&gt; 与 &lt;strong&gt;esp idf&lt;/strong&gt;.&#xA;以 &lt;a href=&#34;https://www.waveshare.net/wiki/ESP32-S3-Nano&#34;&gt;&lt;strong&gt;微雪电子 ESP32-S3-Nano&lt;/strong&gt; 开发板&lt;/a&gt; 为例; 这款开发板理论上与 &lt;strong&gt;Arduino Nano esp32&lt;/strong&gt; 开发板完全兼容.&#xA;在 &lt;a href=&#34;https://docs.arduino.cc/resources/pinouts/ABX00083-full-pinout.pdf&#34;&gt;这里&lt;/a&gt; 可以找到 Arduino 开发板的引脚定义.&lt;/p&gt;&#xA;&lt;h2 id=&#34;esp-idf-安装与配置&#34;&gt;esp idf 安装与配置&lt;a class=&#34;anchor&#34; href=&#34;#esp-idf-%e5%ae%89%e8%a3%85%e4%b8%8e%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;esp idf 有两种安装途径: 通过官方安装器; 或是通过 VSCode 插件安装.&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint warning&#39;&gt;&#xA;&lt;p&gt;上述两种方式安装的 esp idf 互不兼容.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;鉴于我们将在 VSCode 中进行开发, 所以最好选择第二种: 通过插件安装.&lt;/p&gt;&#xA;&lt;p&gt;具体的安装过程可以在 &lt;a href=&#34;https://docs.espressif.com/projects/vscode-esp-idf-extension/zh_CN/latest/installation.html&#34;&gt;官方教程&lt;/a&gt; 找到.&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装-usb-设备驱动&#34;&gt;安装 USB 设备驱动&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85-usb-%e8%ae%be%e5%a4%87%e9%a9%b1%e5%8a%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;安装 &lt;a href=&#34;https://zadig.akeo.ie&#34;&gt;Zadig&lt;/a&gt;. 启动它, 选择 &lt;em&gt;Options &amp;gt; List All Devices&lt;/em&gt;.&#xA;此时应该能在下拉菜单中找到两个 &lt;code&gt;USB JTAG/serial debug unit&lt;/code&gt;, 分别以 &lt;code&gt;Interface 0&lt;/code&gt; 与 &lt;code&gt;Interface 2&lt;/code&gt; 区分. 下面分别设置这两个的驱动.&lt;/p&gt;</description>
    </item>
    <item>
      <title>异步非阻塞串口数据接收</title>
      <link>https://example.org/docs/async-serial/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/async-serial/</guid>
      <description>&lt;h1 id=&#34;异步非阻塞串口数据接收&#34;&gt;异步非阻塞串口数据接收&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e%e4%b8%b2%e5%8f%a3%e6%95%b0%e6%8d%ae%e6%8e%a5%e6%94%b6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;异步&#34;&gt;异步?&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;异步 (asynchronous)&lt;/em&gt; 编程是一种并发的编程模式, 可以有效节省 CPU 阻塞等待 I/O 事件造成的时间浪费, 借以提高性能.&lt;/p&gt;&#xA;&lt;p&gt;在这里也简单介绍一下 &lt;em&gt;并行 (parallel)&lt;/em&gt; 与 &lt;em&gt;并发 (concurrent)&lt;/em&gt; 的区别. 并发是指多个任务可以被同时运行的现象; 但需要注意的是, 并发在某一时刻可能并不一定有多个任务在运行. 但是并行是严格的多线程工作模式, 在某一时刻有多个任务在同时工作. 于是很容易看出, 并行也被包含在并发之中.&lt;/p&gt;&#xA;&lt;p&gt;异步的核心在于一个字 &amp;ldquo;&lt;strong&gt;等&lt;/strong&gt;&amp;rdquo;. 简而言之, 异步编程好似去食堂窗口买饭, 当你告诉他你要点的餐以后, 不是一定要在窗口前等着, 而是可以去做点别的事情, 比如买瓶饮料什么的, 直到老板通知你取餐, 这就是一次异步事件. 在编程时我们调用一个异步 API, 若它不能立刻返回结果, 那么也不会阻塞等待, 而是立刻向后执行; 直到获取到结果再通知我们进行处理.&lt;/p&gt;&#xA;&lt;p&gt;不同的语言有各色的异步支持, &lt;code&gt;JavaScript&lt;/code&gt; 和 &lt;code&gt;Rust&lt;/code&gt; 的异步模型都很有代表性. &lt;code&gt;JavaScript&lt;/code&gt; 中, 异步函数可以返回一个 &lt;code&gt;Promise&lt;/code&gt; 对象, 其名字形象地说明了它的功能: 我承诺完成你要的操作; 潜台词则是我保证 &lt;strong&gt;将来&lt;/strong&gt; 会完成你要的操作, 不一定是立刻做到. &lt;code&gt;Rust&lt;/code&gt; 的 &lt;code&gt;Future&lt;/code&gt; 机制则更为直白: 你的任务我将来会完成的.&lt;/p&gt;&#xA;&lt;p&gt;非多线程的异步程序的本质是 CPU 的 &lt;strong&gt;时分复用&lt;/strong&gt;, 它用划分时间片交替运行各项任务来模拟同时运行每项任务. 必须指出, 有些语言实际上使用多线程实现的异步, 在这种情况下可以实现真正的并行, 即每个时刻多项任务同时被运行. 于是很容易推断, 若 CPU 本来就没有空闲时间, 那么非多线程的异步也并不能提高效率. 这也是为什么异步大多都被用于 I/O 操作, 因为可以有效利用好 I/O 事件中因为等待而空闲的 CPU 时间. 若是 CPU 密集型的工作, 例如科学计算等, 使用异步模型反而会因为时间片切换而损失性能. 这种情况更适合用多线程的方法提高效率.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
