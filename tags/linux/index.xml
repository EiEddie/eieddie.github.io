<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on EiEddie&#39;s Mind</title>
    <link>https://example.org/tags/linux/</link>
    <description>Recent content in Linux on EiEddie&#39;s Mind</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 18 Apr 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://example.org/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>异步非阻塞串口数据接收</title>
      <link>https://example.org/docs/async-serial/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/async-serial/</guid>
      <description>&lt;h1 id=&#34;异步非阻塞串口数据接收&#34;&gt;异步非阻塞串口数据接收&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e%e4%b8%b2%e5%8f%a3%e6%95%b0%e6%8d%ae%e6%8e%a5%e6%94%b6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;异步&#34;&gt;异步?&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e6%ad%a5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;异步 (asynchronous)&lt;/em&gt; 编程是一种并发的编程模式, 可以有效节省 CPU 阻塞等待 I/O 事件造成的时间浪费, 借以提高性能.&lt;/p&gt;&#xA;&lt;p&gt;在这里也简单介绍一下 &lt;em&gt;并行 (parallel)&lt;/em&gt; 与 &lt;em&gt;并发 (concurrent)&lt;/em&gt; 的区别. 并发是指多个任务可以被同时运行的现象; 但需要注意的是, 并发在某一时刻可能并不一定有多个任务在运行. 但是并行是严格的多线程工作模式, 在某一时刻有多个任务在同时工作. 于是很容易看出, 并行也被包含在并发之中.&lt;/p&gt;&#xA;&lt;p&gt;异步的核心在于一个字 &amp;ldquo;&lt;strong&gt;等&lt;/strong&gt;&amp;rdquo;. 简而言之, 异步编程好似去食堂窗口买饭, 当你告诉他你要点的餐以后, 不是一定要在窗口前等着, 而是可以去做点别的事情, 比如买瓶饮料什么的, 直到老板通知你取餐, 这就是一次异步事件. 在编程时我们调用一个异步 API, 若它不能立刻返回结果, 那么也不会阻塞等待, 而是立刻向后执行; 直到获取到结果再通知我们进行处理.&lt;/p&gt;&#xA;&lt;p&gt;不同的语言有各色的异步支持, &lt;code&gt;JavaScript&lt;/code&gt; 和 &lt;code&gt;Rust&lt;/code&gt; 的异步模型都很有代表性. &lt;code&gt;JavaScript&lt;/code&gt; 中, 异步函数可以返回一个 &lt;code&gt;Promise&lt;/code&gt; 对象, 其名字形象地说明了它的功能: 我承诺完成你要的操作; 潜台词则是我保证 &lt;strong&gt;将来&lt;/strong&gt; 会完成你要的操作, 不一定是立刻做到. &lt;code&gt;Rust&lt;/code&gt; 的 &lt;code&gt;Future&lt;/code&gt; 机制则更为直白: 你的任务我将来会完成的.&lt;/p&gt;&#xA;&lt;p&gt;非多线程的异步程序的本质是 CPU 的 &lt;strong&gt;时分复用&lt;/strong&gt;, 它用划分时间片交替运行各项任务来模拟同时运行每项任务. 必须指出, 有些语言实际上使用多线程实现的异步, 在这种情况下可以实现真正的并行, 即每个时刻多项任务同时被运行. 于是很容易推断, 若 CPU 本来就没有空闲时间, 那么非多线程的异步也并不能提高效率. 这也是为什么异步大多都被用于 I/O 操作, 因为可以有效利用好 I/O 事件中因为等待而空闲的 CPU 时间. 若是 CPU 密集型的工作, 例如科学计算等, 使用异步模型反而会因为时间片切换而损失性能. 这种情况更适合用多线程的方法提高效率.&lt;/p&gt;</description>
    </item>
    <item>
      <title>在移动介质中安装操作系统</title>
      <link>https://example.org/docs/linux-to-go/</link>
      <pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://example.org/docs/linux-to-go/</guid>
      <description>&lt;h1 id=&#34;在移动介质中安装操作系统&#34;&gt;在移动介质中安装操作系统&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e7%a7%bb%e5%8a%a8%e4%bb%8b%e8%b4%a8%e4%b8%ad%e5%ae%89%e8%a3%85%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;所需工具:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装了任意 linux 发行版的电脑&lt;/li&gt;&#xA;&lt;li&gt;此处使用安装了 debian 的 VMware 虚拟机&lt;/li&gt;&#xA;&lt;li&gt;系统安装光盘文件 (&lt;code&gt;.iso&lt;/code&gt; 文件)&lt;/li&gt;&#xA;&lt;li&gt;我选择的发行版是 debian&lt;/li&gt;&#xA;&lt;li&gt;容量足够的移动介质 (如 U 盘)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&lt;h2 id=&#34;1-检查移动介质-如-u-盘-的分区表类型&#34;&gt;1. 检查移动介质 (如 U 盘) 的分区表类型&lt;a class=&#34;anchor&#34; href=&#34;#1-%e6%a3%80%e6%9f%a5%e7%a7%bb%e5%8a%a8%e4%bb%8b%e8%b4%a8-%e5%a6%82-u-%e7%9b%98-%e7%9a%84%e5%88%86%e5%8c%ba%e8%a1%a8%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们计划使用更现代的 &lt;code&gt;UEFI&lt;/code&gt; 引导操作系统启动,&#xA;为了具有更好的兼容性, 移动介质的分区表类型应为 &lt;code&gt;GPT&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;因此第一步是将 &lt;code&gt;MBR&lt;/code&gt; 类型的移动介质转换为 &lt;code&gt;GPT&lt;/code&gt; 分区表类型.&#xA;假如你的介质已为 &lt;code&gt;GPT&lt;/code&gt;, 可以跳过此章.&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-检查分区表类型&#34;&gt;1.1. 检查分区表类型&lt;a class=&#34;anchor&#34; href=&#34;#11-%e6%a3%80%e6%9f%a5%e5%88%86%e5%8c%ba%e8%a1%a8%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;fdisk&lt;/code&gt; 命令检查介质:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# fdisk -l&#xA;Disk /dev/sdb: 15.24 GiB, 16358834176 bytes, 31950848 sectors&#xA;Disk model: SD/MMC&#xA;Units: sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;Disklabel type: dos&#xA;Disk identifier: 0x00109879&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;上面显示了在我的机器上返回的信息, 其中:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
